use crate as pg_sys;
use crate::pgptr::New;
use crate::PgPtr;
use pgx_macros::*;
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const PG_DIAG_SEVERITY: u8 = 83u8;
pub const PG_DIAG_SEVERITY_NONLOCALIZED: u8 = 86u8;
pub const PG_DIAG_SQLSTATE: u8 = 67u8;
pub const PG_DIAG_MESSAGE_PRIMARY: u8 = 77u8;
pub const PG_DIAG_MESSAGE_DETAIL: u8 = 68u8;
pub const PG_DIAG_MESSAGE_HINT: u8 = 72u8;
pub const PG_DIAG_STATEMENT_POSITION: u8 = 80u8;
pub const PG_DIAG_INTERNAL_POSITION: u8 = 112u8;
pub const PG_DIAG_INTERNAL_QUERY: u8 = 113u8;
pub const PG_DIAG_CONTEXT: u8 = 87u8;
pub const PG_DIAG_SCHEMA_NAME: u8 = 115u8;
pub const PG_DIAG_TABLE_NAME: u8 = 116u8;
pub const PG_DIAG_COLUMN_NAME: u8 = 99u8;
pub const PG_DIAG_DATATYPE_NAME: u8 = 100u8;
pub const PG_DIAG_CONSTRAINT_NAME: u8 = 110u8;
pub const PG_DIAG_SOURCE_FILE: u8 = 70u8;
pub const PG_DIAG_SOURCE_LINE: u8 = 76u8;
pub const PG_DIAG_SOURCE_FUNCTION: u8 = 82u8;
pub const ALIGNOF_DOUBLE: i32 = 8;
pub const ALIGNOF_INT: i32 = 4;
pub const ALIGNOF_LONG: i32 = 8;
pub const ALIGNOF_PG_INT128_TYPE: i32 = 16;
pub const ALIGNOF_SHORT: i32 = 2;
pub const BLCKSZ: i32 = 8192;
pub const DEF_PGPORT: i32 = 28812;
pub const DEF_PGPORT_STR: &'static [u8; 6usize] = b"28812\0";
pub const ENABLE_THREAD_SAFETY: i32 = 1;
pub const HAVE_ATOMICS: i32 = 1;
pub const HAVE_CBRT: i32 = 1;
pub const HAVE_CLOCK_GETTIME: i32 = 1;
pub const HAVE_COMPUTED_GOTO: i32 = 1;
pub const HAVE_COPYFILE: i32 = 1;
pub const HAVE_COPYFILE_H: i32 = 1;
pub const HAVE_CRYPT: i32 = 1;
pub const HAVE_DECL_FDATASYNC: i32 = 0;
pub const HAVE_DECL_F_FULLFSYNC: i32 = 1;
pub const HAVE_DECL_POSIX_FADVISE: i32 = 0;
pub const HAVE_DECL_RTLD_GLOBAL: i32 = 1;
pub const HAVE_DECL_RTLD_NOW: i32 = 1;
pub const HAVE_DECL_STRLCAT: i32 = 1;
pub const HAVE_DECL_STRLCPY: i32 = 1;
pub const HAVE_DECL_STRNLEN: i32 = 1;
pub const HAVE_DECL_STRTOLL: i32 = 1;
pub const HAVE_DECL_STRTOULL: i32 = 1;
pub const HAVE_DLOPEN: i32 = 1;
pub const HAVE_FDATASYNC: i32 = 1;
pub const HAVE_FLS: i32 = 1;
pub const HAVE_FSEEKO: i32 = 1;
pub const HAVE_FUNCNAME__FUNC: i32 = 1;
pub const HAVE_GCC__ATOMIC_INT32_CAS: i32 = 1;
pub const HAVE_GCC__ATOMIC_INT64_CAS: i32 = 1;
pub const HAVE_GCC__SYNC_CHAR_TAS: i32 = 1;
pub const HAVE_GCC__SYNC_INT32_CAS: i32 = 1;
pub const HAVE_GCC__SYNC_INT32_TAS: i32 = 1;
pub const HAVE_GCC__SYNC_INT64_CAS: i32 = 1;
pub const HAVE_GETADDRINFO: i32 = 1;
pub const HAVE_GETIFADDRS: i32 = 1;
pub const HAVE_GETOPT: i32 = 1;
pub const HAVE_GETOPT_H: i32 = 1;
pub const HAVE_GETOPT_LONG: i32 = 1;
pub const HAVE_GETPEEREID: i32 = 1;
pub const HAVE_GETPWUID_R: i32 = 1;
pub const HAVE_GETRLIMIT: i32 = 1;
pub const HAVE_GETRUSAGE: i32 = 1;
pub const HAVE_HISTORY_TRUNCATE_FILE: i32 = 1;
pub const HAVE_IFADDRS_H: i32 = 1;
pub const HAVE_INET_ATON: i32 = 1;
pub const HAVE_INTPTR_T: i32 = 1;
pub const HAVE_INTTYPES_H: i32 = 1;
pub const HAVE_INT_OPTERR: i32 = 1;
pub const HAVE_INT_OPTRESET: i32 = 1;
pub const HAVE_INT_TIMEZONE: i32 = 1;
pub const HAVE_IPV6: i32 = 1;
pub const HAVE_ISINF: i32 = 1;
pub const HAVE_LANGINFO_H: i32 = 1;
pub const HAVE_LIBM: i32 = 1;
pub const HAVE_LIBREADLINE: i32 = 1;
pub const HAVE_LIBZ: i32 = 1;
pub const HAVE_LOCALE_T: i32 = 1;
pub const HAVE_LONG_INT_64: i32 = 1;
pub const HAVE_LONG_LONG_INT: i32 = 1;
pub const HAVE_MBSTOWCS_L: i32 = 1;
pub const HAVE_MEMMOVE: i32 = 1;
pub const HAVE_MEMORY_H: i32 = 1;
pub const HAVE_MKDTEMP: i32 = 1;
pub const HAVE_NETINET_TCP_H: i32 = 1;
pub const HAVE_NET_IF_H: i32 = 1;
pub const HAVE_POLL: i32 = 1;
pub const HAVE_POLL_H: i32 = 1;
pub const HAVE_PREAD: i32 = 1;
pub const HAVE_PTHREAD: i32 = 1;
pub const HAVE_PTHREAD_IS_THREADED_NP: i32 = 1;
pub const HAVE_PTHREAD_PRIO_INHERIT: i32 = 1;
pub const HAVE_PWRITE: i32 = 1;
pub const HAVE_RANDOM: i32 = 1;
pub const HAVE_READLINE_HISTORY_H: i32 = 1;
pub const HAVE_READLINE_READLINE_H: i32 = 1;
pub const HAVE_READLINK: i32 = 1;
pub const HAVE_RINT: i32 = 1;
pub const HAVE_RL_COMPLETION_APPEND_CHARACTER: i32 = 1;
pub const HAVE_RL_COMPLETION_MATCHES: i32 = 1;
pub const HAVE_RL_FILENAME_COMPLETION_FUNCTION: i32 = 1;
pub const HAVE_SETSID: i32 = 1;
pub const HAVE_SHM_OPEN: i32 = 1;
pub const HAVE_SPINLOCKS: i32 = 1;
pub const HAVE_SRANDOM: i32 = 1;
pub const HAVE_STDBOOL_H: i32 = 1;
pub const HAVE_STDINT_H: i32 = 1;
pub const HAVE_STDLIB_H: i32 = 1;
pub const HAVE_STRERROR_R: i32 = 1;
pub const HAVE_STRINGS_H: i32 = 1;
pub const HAVE_STRING_H: i32 = 1;
pub const HAVE_STRLCAT: i32 = 1;
pub const HAVE_STRLCPY: i32 = 1;
pub const HAVE_STRNLEN: i32 = 1;
pub const HAVE_STRSIGNAL: i32 = 1;
pub const HAVE_STRTOF: i32 = 1;
pub const HAVE_STRTOLL: i32 = 1;
pub const HAVE_STRTOULL: i32 = 1;
pub const HAVE_STRUCT_ADDRINFO: i32 = 1;
pub const HAVE_STRUCT_OPTION: i32 = 1;
pub const HAVE_STRUCT_SOCKADDR_SA_LEN: i32 = 1;
pub const HAVE_STRUCT_SOCKADDR_STORAGE: i32 = 1;
pub const HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY: i32 = 1;
pub const HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN: i32 = 1;
pub const HAVE_STRUCT_TM_TM_ZONE: i32 = 1;
pub const HAVE_SYMLINK: i32 = 1;
pub const HAVE_SYSLOG: i32 = 1;
pub const HAVE_SYS_IPC_H: i32 = 1;
pub const HAVE_SYS_RESOURCE_H: i32 = 1;
pub const HAVE_SYS_SELECT_H: i32 = 1;
pub const HAVE_SYS_SEM_H: i32 = 1;
pub const HAVE_SYS_SHM_H: i32 = 1;
pub const HAVE_SYS_SOCKIO_H: i32 = 1;
pub const HAVE_SYS_STAT_H: i32 = 1;
pub const HAVE_SYS_TYPES_H: i32 = 1;
pub const HAVE_SYS_UCRED_H: i32 = 1;
pub const HAVE_SYS_UN_H: i32 = 1;
pub const HAVE_TERMIOS_H: i32 = 1;
pub const HAVE_TM_ZONE: i32 = 1;
pub const HAVE_TYPEOF: i32 = 1;
pub const HAVE_TZNAME: i32 = 1;
pub const HAVE_UINTPTR_T: i32 = 1;
pub const HAVE_UNION_SEMUN: i32 = 1;
pub const HAVE_UNISTD_H: i32 = 1;
pub const HAVE_UNIX_SOCKETS: i32 = 1;
pub const HAVE_UNSETENV: i32 = 1;
pub const HAVE_UNSIGNED_LONG_LONG_INT: i32 = 1;
pub const HAVE_USELOCALE: i32 = 1;
pub const HAVE_UTIME: i32 = 1;
pub const HAVE_UTIMES: i32 = 1;
pub const HAVE_UTIME_H: i32 = 1;
pub const HAVE_WCHAR_H: i32 = 1;
pub const HAVE_WCSTOMBS_L: i32 = 1;
pub const HAVE_WCTYPE_H: i32 = 1;
pub const HAVE_X86_64_POPCNTQ: i32 = 1;
pub const HAVE__BOOL: i32 = 1;
pub const HAVE__BUILTIN_BSWAP16: i32 = 1;
pub const HAVE__BUILTIN_BSWAP32: i32 = 1;
pub const HAVE__BUILTIN_BSWAP64: i32 = 1;
pub const HAVE__BUILTIN_CLZ: i32 = 1;
pub const HAVE__BUILTIN_CONSTANT_P: i32 = 1;
pub const HAVE__BUILTIN_CTZ: i32 = 1;
pub const HAVE__BUILTIN_OP_OVERFLOW: i32 = 1;
pub const HAVE__BUILTIN_POPCOUNT: i32 = 1;
pub const HAVE__BUILTIN_TYPES_COMPATIBLE_P: i32 = 1;
pub const HAVE__BUILTIN_UNREACHABLE: i32 = 1;
pub const HAVE__GET_CPUID: i32 = 1;
pub const HAVE__STATIC_ASSERT: i32 = 1;
pub const INT64_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const LOCALE_T_IN_XLOCALE: i32 = 1;
pub const MAXIMUM_ALIGNOF: i32 = 8;
pub const MEMSET_LOOP_LIMIT: i32 = 1024;
pub const PACKAGE_BUGREPORT: &'static [u8; 32usize] = b"pgsql-bugs@lists.postgresql.org\0";
pub const PACKAGE_NAME: &'static [u8; 11usize] = b"PostgreSQL\0";
pub const PACKAGE_STRING: &'static [u8; 16usize] = b"PostgreSQL 12.4\0";
pub const PACKAGE_TARNAME: &'static [u8; 11usize] = b"postgresql\0";
pub const PACKAGE_URL: &'static [u8; 1usize] = b"\0";
pub const PACKAGE_VERSION: &'static [u8; 5usize] = b"12.4\0";
pub const PG_KRB_SRVNAM: &'static [u8; 9usize] = b"postgres\0";
pub const PG_MAJORVERSION: &'static [u8; 3usize] = b"12\0";
pub const PG_VERSION: &'static [u8; 5usize] = b"12.4\0";
pub const PG_VERSION_NUM: i32 = 120004;
pub const PG_VERSION_STR : & 'static [u8 ; 114usize] = b"PostgreSQL 12.4 on x86_64-apple-darwin19.0.0, compiled by Apple clang version 11.0.0 (clang-1100.0.33.12), 64-bit\0" ;
pub const RELSEG_SIZE: i32 = 131072;
pub const SIZEOF_BOOL: i32 = 1;
pub const SIZEOF_LONG: i32 = 8;
pub const SIZEOF_OFF_T: i32 = 8;
pub const SIZEOF_SIZE_T: i32 = 8;
pub const SIZEOF_VOID_P: i32 = 8;
pub const STDC_HEADERS: i32 = 1;
pub const STRERROR_R_INT: i32 = 1;
pub const USE_ASSERT_CHECKING: i32 = 1;
pub const USE_DEV_URANDOM: i32 = 1;
pub const USE_FLOAT4_BYVAL: i32 = 1;
pub const USE_FLOAT8_BYVAL: i32 = 1;
pub const USE_SSE42_CRC32C_WITH_RUNTIME_CHECK: i32 = 1;
pub const USE_SYSV_SEMAPHORES: i32 = 1;
pub const USE_SYSV_SHARED_MEMORY: i32 = 1;
pub const WCSTOMBS_L_IN_XLOCALE: i32 = 1;
pub const XLOG_BLCKSZ: i32 = 8192;
pub const DEFAULT_XLOG_SEG_SIZE: i32 = 16777216;
pub const NAMEDATALEN: i32 = 64;
pub const FUNC_MAX_ARGS: i32 = 100;
pub const INDEX_MAX_KEYS: i32 = 32;
pub const PARTITION_MAX_KEYS: i32 = 32;
pub const NUM_SPINLOCK_SEMAPHORES: i32 = 128;
pub const NUM_ATOMICS_SEMAPHORES: i32 = 64;
pub const MAXPGPATH: i32 = 1024;
pub const PG_SOMAXCONN: i32 = 10000;
pub const BITS_PER_BYTE: i32 = 8;
pub const ALIGNOF_BUFFER: i32 = 32;
pub const HAVE_WORKING_LINK: i32 = 1;
pub const DEFAULT_BACKEND_FLUSH_AFTER: i32 = 0;
pub const DEFAULT_BGWRITER_FLUSH_AFTER: i32 = 0;
pub const DEFAULT_CHECKPOINT_FLUSH_AFTER: i32 = 0;
pub const WRITEBACK_MAX_PENDING_FLUSHES: i32 = 256;
pub const DEFAULT_PGSOCKET_DIR: &'static [u8; 5usize] = b"/tmp\0";
pub const DEFAULT_EVENT_SOURCE: &'static [u8; 11usize] = b"PostgreSQL\0";
pub const PG_CACHE_LINE_SIZE: i32 = 128;
pub const TRACE_SORT: i32 = 1;
pub const __darwin__: i32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: i32 = 0;
pub const __DARWIN_ONLY_VERS_1050: i32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: i32 = 1;
pub const __DARWIN_UNIX03: i32 = 1;
pub const __DARWIN_64_BIT_INO_T: i32 = 1;
pub const __DARWIN_VERS_1050: i32 = 1;
pub const __DARWIN_NON_CANCELABLE: i32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: i32 = 4096;
pub const __DARWIN_C_FULL: i32 = 900000;
pub const __DARWIN_C_LEVEL: i32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: i32 = 1;
pub const __DARWIN_NO_LONG_LONG: i32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: i32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: i32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: i32 = 3;
pub const __API_TO_BE_DEPRECATED: i32 = 100000;
pub const __MAC_10_0: i32 = 1000;
pub const __MAC_10_1: i32 = 1010;
pub const __MAC_10_2: i32 = 1020;
pub const __MAC_10_3: i32 = 1030;
pub const __MAC_10_4: i32 = 1040;
pub const __MAC_10_5: i32 = 1050;
pub const __MAC_10_6: i32 = 1060;
pub const __MAC_10_7: i32 = 1070;
pub const __MAC_10_8: i32 = 1080;
pub const __MAC_10_9: i32 = 1090;
pub const __MAC_10_10: i32 = 101000;
pub const __MAC_10_10_2: i32 = 101002;
pub const __MAC_10_10_3: i32 = 101003;
pub const __MAC_10_11: i32 = 101100;
pub const __MAC_10_11_2: i32 = 101102;
pub const __MAC_10_11_3: i32 = 101103;
pub const __MAC_10_11_4: i32 = 101104;
pub const __MAC_10_12: i32 = 101200;
pub const __MAC_10_12_1: i32 = 101201;
pub const __MAC_10_12_2: i32 = 101202;
pub const __MAC_10_12_4: i32 = 101204;
pub const __MAC_10_13: i32 = 101300;
pub const __MAC_10_13_1: i32 = 101301;
pub const __MAC_10_13_2: i32 = 101302;
pub const __MAC_10_13_4: i32 = 101304;
pub const __MAC_10_14: i32 = 101400;
pub const __MAC_10_14_1: i32 = 101401;
pub const __MAC_10_14_4: i32 = 101404;
pub const __MAC_10_15: i32 = 101500;
pub const __MAC_10_15_1: i32 = 101501;
pub const __IPHONE_2_0: i32 = 20000;
pub const __IPHONE_2_1: i32 = 20100;
pub const __IPHONE_2_2: i32 = 20200;
pub const __IPHONE_3_0: i32 = 30000;
pub const __IPHONE_3_1: i32 = 30100;
pub const __IPHONE_3_2: i32 = 30200;
pub const __IPHONE_4_0: i32 = 40000;
pub const __IPHONE_4_1: i32 = 40100;
pub const __IPHONE_4_2: i32 = 40200;
pub const __IPHONE_4_3: i32 = 40300;
pub const __IPHONE_5_0: i32 = 50000;
pub const __IPHONE_5_1: i32 = 50100;
pub const __IPHONE_6_0: i32 = 60000;
pub const __IPHONE_6_1: i32 = 60100;
pub const __IPHONE_7_0: i32 = 70000;
pub const __IPHONE_7_1: i32 = 70100;
pub const __IPHONE_8_0: i32 = 80000;
pub const __IPHONE_8_1: i32 = 80100;
pub const __IPHONE_8_2: i32 = 80200;
pub const __IPHONE_8_3: i32 = 80300;
pub const __IPHONE_8_4: i32 = 80400;
pub const __IPHONE_9_0: i32 = 90000;
pub const __IPHONE_9_1: i32 = 90100;
pub const __IPHONE_9_2: i32 = 90200;
pub const __IPHONE_9_3: i32 = 90300;
pub const __IPHONE_10_0: i32 = 100000;
pub const __IPHONE_10_1: i32 = 100100;
pub const __IPHONE_10_2: i32 = 100200;
pub const __IPHONE_10_3: i32 = 100300;
pub const __IPHONE_11_0: i32 = 110000;
pub const __IPHONE_11_1: i32 = 110100;
pub const __IPHONE_11_2: i32 = 110200;
pub const __IPHONE_11_3: i32 = 110300;
pub const __IPHONE_11_4: i32 = 110400;
pub const __IPHONE_12_0: i32 = 120000;
pub const __IPHONE_12_1: i32 = 120100;
pub const __IPHONE_12_2: i32 = 120200;
pub const __IPHONE_12_3: i32 = 120300;
pub const __IPHONE_13_0: i32 = 130000;
pub const __IPHONE_13_1: i32 = 130100;
pub const __IPHONE_13_2: i32 = 130200;
pub const __TVOS_9_0: i32 = 90000;
pub const __TVOS_9_1: i32 = 90100;
pub const __TVOS_9_2: i32 = 90200;
pub const __TVOS_10_0: i32 = 100000;
pub const __TVOS_10_0_1: i32 = 100001;
pub const __TVOS_10_1: i32 = 100100;
pub const __TVOS_10_2: i32 = 100200;
pub const __TVOS_11_0: i32 = 110000;
pub const __TVOS_11_1: i32 = 110100;
pub const __TVOS_11_2: i32 = 110200;
pub const __TVOS_11_3: i32 = 110300;
pub const __TVOS_11_4: i32 = 110400;
pub const __TVOS_12_0: i32 = 120000;
pub const __TVOS_12_1: i32 = 120100;
pub const __TVOS_12_2: i32 = 120200;
pub const __TVOS_12_3: i32 = 120300;
pub const __TVOS_13_0: i32 = 130000;
pub const __TVOS_13_1: i32 = 130100;
pub const __WATCHOS_1_0: i32 = 10000;
pub const __WATCHOS_2_0: i32 = 20000;
pub const __WATCHOS_2_1: i32 = 20100;
pub const __WATCHOS_2_2: i32 = 20200;
pub const __WATCHOS_3_0: i32 = 30000;
pub const __WATCHOS_3_1: i32 = 30100;
pub const __WATCHOS_3_1_1: i32 = 30101;
pub const __WATCHOS_3_2: i32 = 30200;
pub const __WATCHOS_4_0: i32 = 40000;
pub const __WATCHOS_4_1: i32 = 40100;
pub const __WATCHOS_4_2: i32 = 40200;
pub const __WATCHOS_4_3: i32 = 40300;
pub const __WATCHOS_5_0: i32 = 50000;
pub const __WATCHOS_5_1: i32 = 50100;
pub const __WATCHOS_5_2: i32 = 50200;
pub const __WATCHOS_6_0: i32 = 60000;
pub const __WATCHOS_6_0_1: i32 = 60001;
pub const __DRIVERKIT_19_0: i32 = 190000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: i32 = 101500;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: i32 = 1;
pub const __PTHREAD_SIZE__: i32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: i32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: i32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: i32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: i32 = 8;
pub const __PTHREAD_COND_SIZE__: i32 = 40;
pub const __PTHREAD_ONCE_SIZE__: i32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: i32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: i32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: i32 = 2;
pub const RENAME_SECLUDE: i32 = 1;
pub const RENAME_SWAP: i32 = 2;
pub const RENAME_EXCL: i32 = 4;
pub const __SLBF: i32 = 1;
pub const __SNBF: i32 = 2;
pub const __SRD: i32 = 4;
pub const __SWR: i32 = 8;
pub const __SRW: i32 = 16;
pub const __SEOF: i32 = 32;
pub const __SERR: i32 = 64;
pub const __SMBF: i32 = 128;
pub const __SAPP: i32 = 256;
pub const __SSTR: i32 = 512;
pub const __SOPT: i32 = 1024;
pub const __SNPT: i32 = 2048;
pub const __SOFF: i32 = 4096;
pub const __SMOD: i32 = 8192;
pub const __SALC: i32 = 16384;
pub const __SIGN: i32 = 32768;
pub const _IOFBF: i32 = 0;
pub const _IOLBF: i32 = 1;
pub const _IONBF: i32 = 2;
pub const BUFSIZ: i32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: i32 = 20;
pub const FILENAME_MAX: i32 = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: i32 = 1024;
pub const TMP_MAX: i32 = 308915776;
pub const SEEK_SET: i32 = 0;
pub const SEEK_CUR: i32 = 1;
pub const SEEK_END: i32 = 2;
pub const L_ctermid: i32 = 1024;
pub const _USE_FORTIFY_LEVEL: i32 = 2;
pub const __DARWIN_NSIG: i32 = 32;
pub const NSIG: i32 = 32;
pub const _I386_SIGNAL_H_: i32 = 1;
pub const SIGHUP: i32 = 1;
pub const SIGINT: i32 = 2;
pub const SIGQUIT: i32 = 3;
pub const SIGILL: i32 = 4;
pub const SIGTRAP: i32 = 5;
pub const SIGABRT: i32 = 6;
pub const SIGIOT: i32 = 6;
pub const SIGEMT: i32 = 7;
pub const SIGFPE: i32 = 8;
pub const SIGKILL: i32 = 9;
pub const SIGBUS: i32 = 10;
pub const SIGSEGV: i32 = 11;
pub const SIGSYS: i32 = 12;
pub const SIGPIPE: i32 = 13;
pub const SIGALRM: i32 = 14;
pub const SIGTERM: i32 = 15;
pub const SIGURG: i32 = 16;
pub const SIGSTOP: i32 = 17;
pub const SIGTSTP: i32 = 18;
pub const SIGCONT: i32 = 19;
pub const SIGCHLD: i32 = 20;
pub const SIGTTIN: i32 = 21;
pub const SIGTTOU: i32 = 22;
pub const SIGIO: i32 = 23;
pub const SIGXCPU: i32 = 24;
pub const SIGXFSZ: i32 = 25;
pub const SIGVTALRM: i32 = 26;
pub const SIGPROF: i32 = 27;
pub const SIGWINCH: i32 = 28;
pub const SIGINFO: i32 = 29;
pub const SIGUSR1: i32 = 30;
pub const SIGUSR2: i32 = 31;
pub const FP_PREC_24B: i32 = 0;
pub const FP_PREC_53B: i32 = 2;
pub const FP_PREC_64B: i32 = 3;
pub const FP_RND_NEAR: i32 = 0;
pub const FP_RND_DOWN: i32 = 1;
pub const FP_RND_UP: i32 = 2;
pub const FP_CHOP: i32 = 3;
pub const FP_STATE_BYTES: i32 = 512;
pub const SIGEV_NONE: i32 = 0;
pub const SIGEV_SIGNAL: i32 = 1;
pub const SIGEV_THREAD: i32 = 3;
pub const ILL_NOOP: i32 = 0;
pub const ILL_ILLOPC: i32 = 1;
pub const ILL_ILLTRP: i32 = 2;
pub const ILL_PRVOPC: i32 = 3;
pub const ILL_ILLOPN: i32 = 4;
pub const ILL_ILLADR: i32 = 5;
pub const ILL_PRVREG: i32 = 6;
pub const ILL_COPROC: i32 = 7;
pub const ILL_BADSTK: i32 = 8;
pub const FPE_NOOP: i32 = 0;
pub const FPE_FLTDIV: i32 = 1;
pub const FPE_FLTOVF: i32 = 2;
pub const FPE_FLTUND: i32 = 3;
pub const FPE_FLTRES: i32 = 4;
pub const FPE_FLTINV: i32 = 5;
pub const FPE_FLTSUB: i32 = 6;
pub const FPE_INTDIV: i32 = 7;
pub const FPE_INTOVF: i32 = 8;
pub const SEGV_NOOP: i32 = 0;
pub const SEGV_MAPERR: i32 = 1;
pub const SEGV_ACCERR: i32 = 2;
pub const BUS_NOOP: i32 = 0;
pub const BUS_ADRALN: i32 = 1;
pub const BUS_ADRERR: i32 = 2;
pub const BUS_OBJERR: i32 = 3;
pub const TRAP_BRKPT: i32 = 1;
pub const TRAP_TRACE: i32 = 2;
pub const CLD_NOOP: i32 = 0;
pub const CLD_EXITED: i32 = 1;
pub const CLD_KILLED: i32 = 2;
pub const CLD_DUMPED: i32 = 3;
pub const CLD_TRAPPED: i32 = 4;
pub const CLD_STOPPED: i32 = 5;
pub const CLD_CONTINUED: i32 = 6;
pub const POLL_IN: i32 = 1;
pub const POLL_OUT: i32 = 2;
pub const POLL_MSG: i32 = 3;
pub const POLL_ERR: i32 = 4;
pub const POLL_PRI: i32 = 5;
pub const POLL_HUP: i32 = 6;
pub const SA_ONSTACK: i32 = 1;
pub const SA_RESTART: i32 = 2;
pub const SA_RESETHAND: i32 = 4;
pub const SA_NOCLDSTOP: i32 = 8;
pub const SA_NODEFER: i32 = 16;
pub const SA_NOCLDWAIT: i32 = 32;
pub const SA_SIGINFO: i32 = 64;
pub const SA_USERTRAMP: i32 = 256;
pub const SA_64REGSET: i32 = 512;
pub const SA_USERSPACE_MASK: i32 = 127;
pub const SIG_BLOCK: i32 = 1;
pub const SIG_UNBLOCK: i32 = 2;
pub const SIG_SETMASK: i32 = 3;
pub const SI_USER: i32 = 65537;
pub const SI_QUEUE: i32 = 65538;
pub const SI_TIMER: i32 = 65539;
pub const SI_ASYNCIO: i32 = 65540;
pub const SI_MESGQ: i32 = 65541;
pub const SS_ONSTACK: i32 = 1;
pub const SS_DISABLE: i32 = 4;
pub const MINSIGSTKSZ: i32 = 32768;
pub const SIGSTKSZ: i32 = 131072;
pub const SV_ONSTACK: i32 = 1;
pub const SV_INTERRUPT: i32 = 2;
pub const SV_RESETHAND: i32 = 4;
pub const SV_NODEFER: i32 = 16;
pub const SV_NOCLDSTOP: i32 = 8;
pub const SV_SIGINFO: i32 = 64;
pub const __WORDSIZE: i32 = 64;
pub const INT8_MAX: i32 = 127;
pub const INT16_MAX: i32 = 32767;
pub const INT32_MAX: i32 = 2147483647;
pub const INT64_MAX: i64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: i32 = 255;
pub const UINT16_MAX: i32 = 65535;
pub const UINT32_MAX: i64 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: i32 = 127;
pub const INT_LEAST16_MAX: i32 = 32767;
pub const INT_LEAST32_MAX: i32 = 2147483647;
pub const INT_LEAST64_MAX: i64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: i32 = 255;
pub const UINT_LEAST16_MAX: i32 = 65535;
pub const UINT_LEAST32_MAX: i64 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: i32 = 127;
pub const INT_FAST16_MAX: i32 = 32767;
pub const INT_FAST32_MAX: i32 = 2147483647;
pub const INT_FAST64_MAX: i64 = 9223372036854775807;
pub const UINT_FAST8_MAX: i32 = 255;
pub const UINT_FAST16_MAX: i32 = 65535;
pub const UINT_FAST32_MAX: i64 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: i64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: i32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: i32 = 2147483647;
pub const PRIO_PROCESS: i32 = 0;
pub const PRIO_PGRP: i32 = 1;
pub const PRIO_USER: i32 = 2;
pub const PRIO_DARWIN_THREAD: i32 = 3;
pub const PRIO_DARWIN_PROCESS: i32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: i32 = 20;
pub const PRIO_DARWIN_BG: i32 = 4096;
pub const PRIO_DARWIN_NONUI: i32 = 4097;
pub const RUSAGE_SELF: i32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: i32 = 0;
pub const RUSAGE_INFO_V1: i32 = 1;
pub const RUSAGE_INFO_V2: i32 = 2;
pub const RUSAGE_INFO_V3: i32 = 3;
pub const RUSAGE_INFO_V4: i32 = 4;
pub const RUSAGE_INFO_CURRENT: i32 = 4;
pub const RLIMIT_CPU: i32 = 0;
pub const RLIMIT_FSIZE: i32 = 1;
pub const RLIMIT_DATA: i32 = 2;
pub const RLIMIT_STACK: i32 = 3;
pub const RLIMIT_CORE: i32 = 4;
pub const RLIMIT_AS: i32 = 5;
pub const RLIMIT_RSS: i32 = 5;
pub const RLIMIT_MEMLOCK: i32 = 6;
pub const RLIMIT_NPROC: i32 = 7;
pub const RLIMIT_NOFILE: i32 = 8;
pub const RLIM_NLIMITS: i32 = 9;
pub const _RLIMIT_POSIX_FLAG: i32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: i32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: i32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: i32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: i32 = 4;
pub const WAKEMON_ENABLE: i32 = 1;
pub const WAKEMON_DISABLE: i32 = 2;
pub const WAKEMON_GET_PARAMS: i32 = 4;
pub const WAKEMON_SET_DEFAULTS: i32 = 8;
pub const WAKEMON_MAKE_FATAL: i32 = 16;
pub const CPUMON_MAKE_FATAL: i32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: i32 = 1;
pub const IOPOL_TYPE_DISK: i32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: i32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: i32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: i32 = 4;
pub const IOPOL_SCOPE_PROCESS: i32 = 0;
pub const IOPOL_SCOPE_THREAD: i32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: i32 = 2;
pub const IOPOL_DEFAULT: i32 = 0;
pub const IOPOL_IMPORTANT: i32 = 1;
pub const IOPOL_PASSIVE: i32 = 2;
pub const IOPOL_THROTTLE: i32 = 3;
pub const IOPOL_UTILITY: i32 = 4;
pub const IOPOL_STANDARD: i32 = 5;
pub const IOPOL_APPLICATION: i32 = 5;
pub const IOPOL_NORMAL: i32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: i32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: i32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: i32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: i32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: i32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: i32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: i32 = 1;
pub const WNOHANG: i32 = 1;
pub const WUNTRACED: i32 = 2;
pub const WCOREFLAG: i32 = 128;
pub const _WSTOPPED: i32 = 127;
pub const WEXITED: i32 = 4;
pub const WSTOPPED: i32 = 8;
pub const WCONTINUED: i32 = 16;
pub const WNOWAIT: i32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: i32 = 0;
pub const _QUAD_HIGHWORD: i32 = 1;
pub const _QUAD_LOWWORD: i32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: i32 = 1234;
pub const __DARWIN_BIG_ENDIAN: i32 = 4321;
pub const __DARWIN_PDP_ENDIAN: i32 = 3412;
pub const __DARWIN_BYTE_ORDER: i32 = 1234;
pub const LITTLE_ENDIAN: i32 = 1234;
pub const BIG_ENDIAN: i32 = 4321;
pub const PDP_ENDIAN: i32 = 3412;
pub const BYTE_ORDER: i32 = 1234;
pub const EXIT_FAILURE: i32 = 1;
pub const EXIT_SUCCESS: i32 = 0;
pub const RAND_MAX: i32 = 2147483647;
pub const __HAS_FIXED_CHK_PROTOTYPES: i32 = 1;
pub const __GNUC_VA_LIST: i32 = 1;
pub const __DARWIN_FD_SETSIZE: i32 = 1024;
pub const __DARWIN_NBBY: i32 = 8;
pub const NBBY: i32 = 8;
pub const FD_SETSIZE: i32 = 1024;
pub const EPERM: i32 = 1;
pub const ENOENT: i32 = 2;
pub const ESRCH: i32 = 3;
pub const EINTR: i32 = 4;
pub const EIO: i32 = 5;
pub const ENXIO: i32 = 6;
pub const E2BIG: i32 = 7;
pub const ENOEXEC: i32 = 8;
pub const EBADF: i32 = 9;
pub const ECHILD: i32 = 10;
pub const EDEADLK: i32 = 11;
pub const ENOMEM: i32 = 12;
pub const EACCES: i32 = 13;
pub const EFAULT: i32 = 14;
pub const ENOTBLK: i32 = 15;
pub const EBUSY: i32 = 16;
pub const EEXIST: i32 = 17;
pub const EXDEV: i32 = 18;
pub const ENODEV: i32 = 19;
pub const ENOTDIR: i32 = 20;
pub const EISDIR: i32 = 21;
pub const EINVAL: i32 = 22;
pub const ENFILE: i32 = 23;
pub const EMFILE: i32 = 24;
pub const ENOTTY: i32 = 25;
pub const ETXTBSY: i32 = 26;
pub const EFBIG: i32 = 27;
pub const ENOSPC: i32 = 28;
pub const ESPIPE: i32 = 29;
pub const EROFS: i32 = 30;
pub const EMLINK: i32 = 31;
pub const EPIPE: i32 = 32;
pub const EDOM: i32 = 33;
pub const ERANGE: i32 = 34;
pub const EAGAIN: i32 = 35;
pub const EWOULDBLOCK: i32 = 35;
pub const EINPROGRESS: i32 = 36;
pub const EALREADY: i32 = 37;
pub const ENOTSOCK: i32 = 38;
pub const EDESTADDRREQ: i32 = 39;
pub const EMSGSIZE: i32 = 40;
pub const EPROTOTYPE: i32 = 41;
pub const ENOPROTOOPT: i32 = 42;
pub const EPROTONOSUPPORT: i32 = 43;
pub const ESOCKTNOSUPPORT: i32 = 44;
pub const ENOTSUP: i32 = 45;
pub const EPFNOSUPPORT: i32 = 46;
pub const EAFNOSUPPORT: i32 = 47;
pub const EADDRINUSE: i32 = 48;
pub const EADDRNOTAVAIL: i32 = 49;
pub const ENETDOWN: i32 = 50;
pub const ENETUNREACH: i32 = 51;
pub const ENETRESET: i32 = 52;
pub const ECONNABORTED: i32 = 53;
pub const ECONNRESET: i32 = 54;
pub const ENOBUFS: i32 = 55;
pub const EISCONN: i32 = 56;
pub const ENOTCONN: i32 = 57;
pub const ESHUTDOWN: i32 = 58;
pub const ETOOMANYREFS: i32 = 59;
pub const ETIMEDOUT: i32 = 60;
pub const ECONNREFUSED: i32 = 61;
pub const ELOOP: i32 = 62;
pub const ENAMETOOLONG: i32 = 63;
pub const EHOSTDOWN: i32 = 64;
pub const EHOSTUNREACH: i32 = 65;
pub const ENOTEMPTY: i32 = 66;
pub const EPROCLIM: i32 = 67;
pub const EUSERS: i32 = 68;
pub const EDQUOT: i32 = 69;
pub const ESTALE: i32 = 70;
pub const EREMOTE: i32 = 71;
pub const EBADRPC: i32 = 72;
pub const ERPCMISMATCH: i32 = 73;
pub const EPROGUNAVAIL: i32 = 74;
pub const EPROGMISMATCH: i32 = 75;
pub const EPROCUNAVAIL: i32 = 76;
pub const ENOLCK: i32 = 77;
pub const ENOSYS: i32 = 78;
pub const EFTYPE: i32 = 79;
pub const EAUTH: i32 = 80;
pub const ENEEDAUTH: i32 = 81;
pub const EPWROFF: i32 = 82;
pub const EDEVERR: i32 = 83;
pub const EOVERFLOW: i32 = 84;
pub const EBADEXEC: i32 = 85;
pub const EBADARCH: i32 = 86;
pub const ESHLIBVERS: i32 = 87;
pub const EBADMACHO: i32 = 88;
pub const ECANCELED: i32 = 89;
pub const EIDRM: i32 = 90;
pub const ENOMSG: i32 = 91;
pub const EILSEQ: i32 = 92;
pub const ENOATTR: i32 = 93;
pub const EBADMSG: i32 = 94;
pub const EMULTIHOP: i32 = 95;
pub const ENODATA: i32 = 96;
pub const ENOLINK: i32 = 97;
pub const ENOSR: i32 = 98;
pub const ENOSTR: i32 = 99;
pub const EPROTO: i32 = 100;
pub const ETIME: i32 = 101;
pub const EOPNOTSUPP: i32 = 102;
pub const ENOPOLICY: i32 = 103;
pub const ENOTRECOVERABLE: i32 = 104;
pub const EOWNERDEAD: i32 = 105;
pub const EQFULL: i32 = 106;
pub const ELAST: i32 = 106;
pub const LC_ALL: i32 = 0;
pub const LC_COLLATE: i32 = 1;
pub const LC_CTYPE: i32 = 2;
pub const LC_MONETARY: i32 = 3;
pub const LC_NUMERIC: i32 = 4;
pub const LC_TIME: i32 = 5;
pub const LC_MESSAGES: i32 = 6;
pub const _LC_LAST: i32 = 7;
pub const HAVE_PG_ATTRIBUTE_NORETURN: i32 = 1;
pub const true_: i32 = 1;
pub const false_: i32 = 0;
pub const __bool_true_false_are_defined: i32 = 1;
pub const USE_STDBOOL: i32 = 1;
pub const INT64_FORMAT: &'static [u8; 4usize] = b"%ld\0";
pub const UINT64_FORMAT: &'static [u8; 4usize] = b"%lu\0";
pub const HAVE_INT128: i32 = 1;
pub const PG_INT8_MIN: i32 = -128;
pub const PG_INT8_MAX: i32 = 127;
pub const PG_UINT8_MAX: i32 = 255;
pub const PG_INT16_MIN: i32 = -32768;
pub const PG_INT16_MAX: i32 = 32767;
pub const PG_UINT16_MAX: i32 = 65535;
pub const PG_INT32_MIN: i32 = -2147483648;
pub const PG_INT32_MAX: i32 = 2147483647;
pub const PG_UINT32_MAX: i64 = 4294967295;
pub const MAXDIM: i32 = 6;
pub const HIGHBIT: i32 = 128;
pub const ESCAPE_STRING_SYNTAX: u8 = 69u8;
pub const STATUS_OK: i32 = 0;
pub const STATUS_ERROR: i32 = -1;
pub const STATUS_EOF: i32 = -2;
pub const STATUS_FOUND: i32 = 1;
pub const STATUS_WAITING: i32 = 2;
pub const PG_BINARY: i32 = 0;
pub const PG_BINARY_A: &'static [u8; 2usize] = b"a\0";
pub const PG_BINARY_R: &'static [u8; 2usize] = b"r\0";
pub const PG_BINARY_W: &'static [u8; 2usize] = b"w\0";
pub const _CACHED_RUNES: i32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &'static [u8; 9usize] = b"RuneMagA\0";
pub const _CTYPE_A: i32 = 256;
pub const _CTYPE_C: i32 = 512;
pub const _CTYPE_D: i32 = 1024;
pub const _CTYPE_G: i32 = 2048;
pub const _CTYPE_L: i32 = 4096;
pub const _CTYPE_P: i32 = 8192;
pub const _CTYPE_S: i32 = 16384;
pub const _CTYPE_U: i32 = 32768;
pub const _CTYPE_X: i32 = 65536;
pub const _CTYPE_B: i32 = 131072;
pub const _CTYPE_R: i32 = 262144;
pub const _CTYPE_I: i32 = 524288;
pub const _CTYPE_T: i32 = 1048576;
pub const _CTYPE_Q: i32 = 2097152;
pub const _CTYPE_SW0: i32 = 536870912;
pub const _CTYPE_SW1: i32 = 1073741824;
pub const _CTYPE_SW2: i64 = 2147483648;
pub const _CTYPE_SW3: i64 = 3221225472;
pub const _CTYPE_SWM: i64 = 3758096384;
pub const _CTYPE_SWS: i32 = 30;
pub const KEV_INET_SUBCLASS: i32 = 1;
pub const KEV_INET_NEW_ADDR: i32 = 1;
pub const KEV_INET_CHANGED_ADDR: i32 = 2;
pub const KEV_INET_ADDR_DELETED: i32 = 3;
pub const KEV_INET_SIFDSTADDR: i32 = 4;
pub const KEV_INET_SIFBRDADDR: i32 = 5;
pub const KEV_INET_SIFNETMASK: i32 = 6;
pub const KEV_INET_ARPCOLLISION: i32 = 7;
pub const KEV_INET_PORTINUSE: i32 = 8;
pub const KEV_INET_ARPRTRFAILURE: i32 = 9;
pub const KEV_INET_ARPRTRALIVE: i32 = 10;
pub const KEV_DL_SUBCLASS: i32 = 2;
pub const KEV_DL_SIFFLAGS: i32 = 1;
pub const KEV_DL_SIFMETRICS: i32 = 2;
pub const KEV_DL_SIFMTU: i32 = 3;
pub const KEV_DL_SIFPHYS: i32 = 4;
pub const KEV_DL_SIFMEDIA: i32 = 5;
pub const KEV_DL_SIFGENERIC: i32 = 6;
pub const KEV_DL_ADDMULTI: i32 = 7;
pub const KEV_DL_DELMULTI: i32 = 8;
pub const KEV_DL_IF_ATTACHED: i32 = 9;
pub const KEV_DL_IF_DETACHING: i32 = 10;
pub const KEV_DL_IF_DETACHED: i32 = 11;
pub const KEV_DL_LINK_OFF: i32 = 12;
pub const KEV_DL_LINK_ON: i32 = 13;
pub const KEV_DL_PROTO_ATTACHED: i32 = 14;
pub const KEV_DL_PROTO_DETACHED: i32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: i32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: i32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: i32 = 18;
pub const KEV_DL_IFCAP_CHANGED: i32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: i32 = 20;
pub const KEV_DL_NODE_PRESENCE: i32 = 21;
pub const KEV_DL_NODE_ABSENCE: i32 = 22;
pub const KEV_DL_MASTER_ELECTED: i32 = 23;
pub const KEV_DL_ISSUES: i32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: i32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: i32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: i32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: i32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: i32 = 29;
pub const KEV_DL_LOW_POWER_MODE_CHANGED: i32 = 30;
pub const KEV_INET6_SUBCLASS: i32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: i32 = 1;
pub const KEV_INET6_CHANGED_ADDR: i32 = 2;
pub const KEV_INET6_ADDR_DELETED: i32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: i32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: i32 = 5;
pub const KEV_INET6_DEFROUTER: i32 = 6;
pub const KEV_INET6_REQUEST_NAT64_PREFIX: i32 = 7;
pub const SOCK_STREAM: i32 = 1;
pub const SOCK_DGRAM: i32 = 2;
pub const SOCK_RAW: i32 = 3;
pub const SOCK_RDM: i32 = 4;
pub const SOCK_SEQPACKET: i32 = 5;
pub const SO_DEBUG: i32 = 1;
pub const SO_ACCEPTCONN: i32 = 2;
pub const SO_REUSEADDR: i32 = 4;
pub const SO_KEEPALIVE: i32 = 8;
pub const SO_DONTROUTE: i32 = 16;
pub const SO_BROADCAST: i32 = 32;
pub const SO_USELOOPBACK: i32 = 64;
pub const SO_LINGER: i32 = 128;
pub const SO_OOBINLINE: i32 = 256;
pub const SO_REUSEPORT: i32 = 512;
pub const SO_TIMESTAMP: i32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: i32 = 2048;
pub const SO_DONTTRUNC: i32 = 8192;
pub const SO_WANTMORE: i32 = 16384;
pub const SO_WANTOOBFLAG: i32 = 32768;
pub const SO_SNDBUF: i32 = 4097;
pub const SO_RCVBUF: i32 = 4098;
pub const SO_SNDLOWAT: i32 = 4099;
pub const SO_RCVLOWAT: i32 = 4100;
pub const SO_SNDTIMEO: i32 = 4101;
pub const SO_RCVTIMEO: i32 = 4102;
pub const SO_ERROR: i32 = 4103;
pub const SO_TYPE: i32 = 4104;
pub const SO_LABEL: i32 = 4112;
pub const SO_PEERLABEL: i32 = 4113;
pub const SO_NREAD: i32 = 4128;
pub const SO_NKE: i32 = 4129;
pub const SO_NOSIGPIPE: i32 = 4130;
pub const SO_NOADDRERR: i32 = 4131;
pub const SO_NWRITE: i32 = 4132;
pub const SO_REUSESHAREUID: i32 = 4133;
pub const SO_NOTIFYCONFLICT: i32 = 4134;
pub const SO_UPCALLCLOSEWAIT: i32 = 4135;
pub const SO_LINGER_SEC: i32 = 4224;
pub const SO_RANDOMPORT: i32 = 4226;
pub const SO_NP_EXTENSIONS: i32 = 4227;
pub const SO_NUMRCVPKT: i32 = 4370;
pub const SO_NET_SERVICE_TYPE: i32 = 4374;
pub const SO_NETSVC_MARKING_LEVEL: i32 = 4377;
pub const NET_SERVICE_TYPE_BE: i32 = 0;
pub const NET_SERVICE_TYPE_BK: i32 = 1;
pub const NET_SERVICE_TYPE_SIG: i32 = 2;
pub const NET_SERVICE_TYPE_VI: i32 = 3;
pub const NET_SERVICE_TYPE_VO: i32 = 4;
pub const NET_SERVICE_TYPE_RV: i32 = 5;
pub const NET_SERVICE_TYPE_AV: i32 = 6;
pub const NET_SERVICE_TYPE_OAM: i32 = 7;
pub const NET_SERVICE_TYPE_RD: i32 = 8;
pub const NETSVC_MRKNG_UNKNOWN: i32 = 0;
pub const NETSVC_MRKNG_LVL_L2: i32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: i32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: i32 = 3;
pub const SAE_ASSOCID_ANY: i32 = 0;
pub const SAE_CONNID_ANY: i32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: i32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: i32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: i32 = 4;
pub const SONPX_SETOPTSHUT: i32 = 1;
pub const SOL_SOCKET: i32 = 65535;
pub const AF_UNSPEC: i32 = 0;
pub const AF_UNIX: i32 = 1;
pub const AF_LOCAL: i32 = 1;
pub const AF_INET: i32 = 2;
pub const AF_IMPLINK: i32 = 3;
pub const AF_PUP: i32 = 4;
pub const AF_CHAOS: i32 = 5;
pub const AF_NS: i32 = 6;
pub const AF_ISO: i32 = 7;
pub const AF_OSI: i32 = 7;
pub const AF_ECMA: i32 = 8;
pub const AF_DATAKIT: i32 = 9;
pub const AF_CCITT: i32 = 10;
pub const AF_SNA: i32 = 11;
pub const AF_DECnet: i32 = 12;
pub const AF_DLI: i32 = 13;
pub const AF_LAT: i32 = 14;
pub const AF_HYLINK: i32 = 15;
pub const AF_APPLETALK: i32 = 16;
pub const AF_ROUTE: i32 = 17;
pub const AF_LINK: i32 = 18;
pub const pseudo_AF_XTP: i32 = 19;
pub const AF_COIP: i32 = 20;
pub const AF_CNT: i32 = 21;
pub const pseudo_AF_RTIP: i32 = 22;
pub const AF_IPX: i32 = 23;
pub const AF_SIP: i32 = 24;
pub const pseudo_AF_PIP: i32 = 25;
pub const AF_NDRV: i32 = 27;
pub const AF_ISDN: i32 = 28;
pub const AF_E164: i32 = 28;
pub const pseudo_AF_KEY: i32 = 29;
pub const AF_INET6: i32 = 30;
pub const AF_NATM: i32 = 31;
pub const AF_SYSTEM: i32 = 32;
pub const AF_NETBIOS: i32 = 33;
pub const AF_PPP: i32 = 34;
pub const pseudo_AF_HDRCMPLT: i32 = 35;
pub const AF_RESERVED_36: i32 = 36;
pub const AF_IEEE80211: i32 = 37;
pub const AF_UTUN: i32 = 38;
pub const AF_MAX: i32 = 40;
pub const SOCK_MAXADDRLEN: i32 = 255;
pub const _SS_MAXSIZE: i32 = 128;
pub const PF_UNSPEC: i32 = 0;
pub const PF_LOCAL: i32 = 1;
pub const PF_UNIX: i32 = 1;
pub const PF_INET: i32 = 2;
pub const PF_IMPLINK: i32 = 3;
pub const PF_PUP: i32 = 4;
pub const PF_CHAOS: i32 = 5;
pub const PF_NS: i32 = 6;
pub const PF_ISO: i32 = 7;
pub const PF_OSI: i32 = 7;
pub const PF_ECMA: i32 = 8;
pub const PF_DATAKIT: i32 = 9;
pub const PF_CCITT: i32 = 10;
pub const PF_SNA: i32 = 11;
pub const PF_DECnet: i32 = 12;
pub const PF_DLI: i32 = 13;
pub const PF_LAT: i32 = 14;
pub const PF_HYLINK: i32 = 15;
pub const PF_APPLETALK: i32 = 16;
pub const PF_ROUTE: i32 = 17;
pub const PF_LINK: i32 = 18;
pub const PF_XTP: i32 = 19;
pub const PF_COIP: i32 = 20;
pub const PF_CNT: i32 = 21;
pub const PF_SIP: i32 = 24;
pub const PF_IPX: i32 = 23;
pub const PF_RTIP: i32 = 22;
pub const PF_PIP: i32 = 25;
pub const PF_NDRV: i32 = 27;
pub const PF_ISDN: i32 = 28;
pub const PF_KEY: i32 = 29;
pub const PF_INET6: i32 = 30;
pub const PF_NATM: i32 = 31;
pub const PF_SYSTEM: i32 = 32;
pub const PF_NETBIOS: i32 = 33;
pub const PF_PPP: i32 = 34;
pub const PF_RESERVED_36: i32 = 36;
pub const PF_UTUN: i32 = 38;
pub const PF_MAX: i32 = 40;
pub const NET_MAXID: i32 = 40;
pub const NET_RT_DUMP: i32 = 1;
pub const NET_RT_FLAGS: i32 = 2;
pub const NET_RT_IFLIST: i32 = 3;
pub const NET_RT_STAT: i32 = 4;
pub const NET_RT_TRASH: i32 = 5;
pub const NET_RT_IFLIST2: i32 = 6;
pub const NET_RT_DUMP2: i32 = 7;
pub const NET_RT_FLAGS_PRIV: i32 = 10;
pub const NET_RT_MAXID: i32 = 11;
pub const SOMAXCONN: i32 = 128;
pub const MSG_OOB: i32 = 1;
pub const MSG_PEEK: i32 = 2;
pub const MSG_DONTROUTE: i32 = 4;
pub const MSG_EOR: i32 = 8;
pub const MSG_TRUNC: i32 = 16;
pub const MSG_CTRUNC: i32 = 32;
pub const MSG_WAITALL: i32 = 64;
pub const MSG_DONTWAIT: i32 = 128;
pub const MSG_EOF: i32 = 256;
pub const MSG_WAITSTREAM: i32 = 512;
pub const MSG_FLUSH: i32 = 1024;
pub const MSG_HOLD: i32 = 2048;
pub const MSG_SEND: i32 = 4096;
pub const MSG_HAVEMORE: i32 = 8192;
pub const MSG_RCVMORE: i32 = 16384;
pub const MSG_NEEDSA: i32 = 65536;
pub const SCM_RIGHTS: i32 = 1;
pub const SCM_TIMESTAMP: i32 = 2;
pub const SCM_CREDS: i32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: i32 = 4;
pub const SHUT_RD: i32 = 0;
pub const SHUT_WR: i32 = 1;
pub const SHUT_RDWR: i32 = 2;
pub const IPPROTO_IP: i32 = 0;
pub const IPPROTO_HOPOPTS: i32 = 0;
pub const IPPROTO_ICMP: i32 = 1;
pub const IPPROTO_IGMP: i32 = 2;
pub const IPPROTO_GGP: i32 = 3;
pub const IPPROTO_IPV4: i32 = 4;
pub const IPPROTO_IPIP: i32 = 4;
pub const IPPROTO_TCP: i32 = 6;
pub const IPPROTO_ST: i32 = 7;
pub const IPPROTO_EGP: i32 = 8;
pub const IPPROTO_PIGP: i32 = 9;
pub const IPPROTO_RCCMON: i32 = 10;
pub const IPPROTO_NVPII: i32 = 11;
pub const IPPROTO_PUP: i32 = 12;
pub const IPPROTO_ARGUS: i32 = 13;
pub const IPPROTO_EMCON: i32 = 14;
pub const IPPROTO_XNET: i32 = 15;
pub const IPPROTO_CHAOS: i32 = 16;
pub const IPPROTO_UDP: i32 = 17;
pub const IPPROTO_MUX: i32 = 18;
pub const IPPROTO_MEAS: i32 = 19;
pub const IPPROTO_HMP: i32 = 20;
pub const IPPROTO_PRM: i32 = 21;
pub const IPPROTO_IDP: i32 = 22;
pub const IPPROTO_TRUNK1: i32 = 23;
pub const IPPROTO_TRUNK2: i32 = 24;
pub const IPPROTO_LEAF1: i32 = 25;
pub const IPPROTO_LEAF2: i32 = 26;
pub const IPPROTO_RDP: i32 = 27;
pub const IPPROTO_IRTP: i32 = 28;
pub const IPPROTO_TP: i32 = 29;
pub const IPPROTO_BLT: i32 = 30;
pub const IPPROTO_NSP: i32 = 31;
pub const IPPROTO_INP: i32 = 32;
pub const IPPROTO_SEP: i32 = 33;
pub const IPPROTO_3PC: i32 = 34;
pub const IPPROTO_IDPR: i32 = 35;
pub const IPPROTO_XTP: i32 = 36;
pub const IPPROTO_DDP: i32 = 37;
pub const IPPROTO_CMTP: i32 = 38;
pub const IPPROTO_TPXX: i32 = 39;
pub const IPPROTO_IL: i32 = 40;
pub const IPPROTO_IPV6: i32 = 41;
pub const IPPROTO_SDRP: i32 = 42;
pub const IPPROTO_ROUTING: i32 = 43;
pub const IPPROTO_FRAGMENT: i32 = 44;
pub const IPPROTO_IDRP: i32 = 45;
pub const IPPROTO_RSVP: i32 = 46;
pub const IPPROTO_GRE: i32 = 47;
pub const IPPROTO_MHRP: i32 = 48;
pub const IPPROTO_BHA: i32 = 49;
pub const IPPROTO_ESP: i32 = 50;
pub const IPPROTO_AH: i32 = 51;
pub const IPPROTO_INLSP: i32 = 52;
pub const IPPROTO_SWIPE: i32 = 53;
pub const IPPROTO_NHRP: i32 = 54;
pub const IPPROTO_ICMPV6: i32 = 58;
pub const IPPROTO_NONE: i32 = 59;
pub const IPPROTO_DSTOPTS: i32 = 60;
pub const IPPROTO_AHIP: i32 = 61;
pub const IPPROTO_CFTP: i32 = 62;
pub const IPPROTO_HELLO: i32 = 63;
pub const IPPROTO_SATEXPAK: i32 = 64;
pub const IPPROTO_KRYPTOLAN: i32 = 65;
pub const IPPROTO_RVD: i32 = 66;
pub const IPPROTO_IPPC: i32 = 67;
pub const IPPROTO_ADFS: i32 = 68;
pub const IPPROTO_SATMON: i32 = 69;
pub const IPPROTO_VISA: i32 = 70;
pub const IPPROTO_IPCV: i32 = 71;
pub const IPPROTO_CPNX: i32 = 72;
pub const IPPROTO_CPHB: i32 = 73;
pub const IPPROTO_WSN: i32 = 74;
pub const IPPROTO_PVP: i32 = 75;
pub const IPPROTO_BRSATMON: i32 = 76;
pub const IPPROTO_ND: i32 = 77;
pub const IPPROTO_WBMON: i32 = 78;
pub const IPPROTO_WBEXPAK: i32 = 79;
pub const IPPROTO_EON: i32 = 80;
pub const IPPROTO_VMTP: i32 = 81;
pub const IPPROTO_SVMTP: i32 = 82;
pub const IPPROTO_VINES: i32 = 83;
pub const IPPROTO_TTP: i32 = 84;
pub const IPPROTO_IGP: i32 = 85;
pub const IPPROTO_DGP: i32 = 86;
pub const IPPROTO_TCF: i32 = 87;
pub const IPPROTO_IGRP: i32 = 88;
pub const IPPROTO_OSPFIGP: i32 = 89;
pub const IPPROTO_SRPC: i32 = 90;
pub const IPPROTO_LARP: i32 = 91;
pub const IPPROTO_MTP: i32 = 92;
pub const IPPROTO_AX25: i32 = 93;
pub const IPPROTO_IPEIP: i32 = 94;
pub const IPPROTO_MICP: i32 = 95;
pub const IPPROTO_SCCSP: i32 = 96;
pub const IPPROTO_ETHERIP: i32 = 97;
pub const IPPROTO_ENCAP: i32 = 98;
pub const IPPROTO_APES: i32 = 99;
pub const IPPROTO_GMTP: i32 = 100;
pub const IPPROTO_PIM: i32 = 103;
pub const IPPROTO_IPCOMP: i32 = 108;
pub const IPPROTO_PGM: i32 = 113;
pub const IPPROTO_SCTP: i32 = 132;
pub const IPPROTO_DIVERT: i32 = 254;
pub const IPPROTO_RAW: i32 = 255;
pub const IPPROTO_MAX: i32 = 256;
pub const IPPROTO_DONE: i32 = 257;
pub const __DARWIN_IPPORT_RESERVED: i32 = 1024;
pub const IPPORT_RESERVED: i32 = 1024;
pub const IPPORT_USERRESERVED: i32 = 5000;
pub const IPPORT_HIFIRSTAUTO: i32 = 49152;
pub const IPPORT_HILASTAUTO: i32 = 65535;
pub const IPPORT_RESERVEDSTART: i32 = 600;
pub const IN_CLASSA_NET: i64 = 4278190080;
pub const IN_CLASSA_NSHIFT: i32 = 24;
pub const IN_CLASSA_HOST: i32 = 16777215;
pub const IN_CLASSA_MAX: i32 = 128;
pub const IN_CLASSB_NET: i64 = 4294901760;
pub const IN_CLASSB_NSHIFT: i32 = 16;
pub const IN_CLASSB_HOST: i32 = 65535;
pub const IN_CLASSB_MAX: i32 = 65536;
pub const IN_CLASSC_NET: i64 = 4294967040;
pub const IN_CLASSC_NSHIFT: i32 = 8;
pub const IN_CLASSC_HOST: i32 = 255;
pub const IN_CLASSD_NET: i64 = 4026531840;
pub const IN_CLASSD_NSHIFT: i32 = 28;
pub const IN_CLASSD_HOST: i32 = 268435455;
pub const INADDR_NONE: i64 = 4294967295;
pub const IN_LOOPBACKNET: i32 = 127;
pub const INET_ADDRSTRLEN: i32 = 16;
pub const IP_OPTIONS: i32 = 1;
pub const IP_HDRINCL: i32 = 2;
pub const IP_TOS: i32 = 3;
pub const IP_TTL: i32 = 4;
pub const IP_RECVOPTS: i32 = 5;
pub const IP_RECVRETOPTS: i32 = 6;
pub const IP_RECVDSTADDR: i32 = 7;
pub const IP_RETOPTS: i32 = 8;
pub const IP_MULTICAST_IF: i32 = 9;
pub const IP_MULTICAST_TTL: i32 = 10;
pub const IP_MULTICAST_LOOP: i32 = 11;
pub const IP_ADD_MEMBERSHIP: i32 = 12;
pub const IP_DROP_MEMBERSHIP: i32 = 13;
pub const IP_MULTICAST_VIF: i32 = 14;
pub const IP_RSVP_ON: i32 = 15;
pub const IP_RSVP_OFF: i32 = 16;
pub const IP_RSVP_VIF_ON: i32 = 17;
pub const IP_RSVP_VIF_OFF: i32 = 18;
pub const IP_PORTRANGE: i32 = 19;
pub const IP_RECVIF: i32 = 20;
pub const IP_IPSEC_POLICY: i32 = 21;
pub const IP_FAITH: i32 = 22;
pub const IP_STRIPHDR: i32 = 23;
pub const IP_RECVTTL: i32 = 24;
pub const IP_BOUND_IF: i32 = 25;
pub const IP_PKTINFO: i32 = 26;
pub const IP_RECVPKTINFO: i32 = 26;
pub const IP_RECVTOS: i32 = 27;
pub const IP_FW_ADD: i32 = 40;
pub const IP_FW_DEL: i32 = 41;
pub const IP_FW_FLUSH: i32 = 42;
pub const IP_FW_ZERO: i32 = 43;
pub const IP_FW_GET: i32 = 44;
pub const IP_FW_RESETLOG: i32 = 45;
pub const IP_OLD_FW_ADD: i32 = 50;
pub const IP_OLD_FW_DEL: i32 = 51;
pub const IP_OLD_FW_FLUSH: i32 = 52;
pub const IP_OLD_FW_ZERO: i32 = 53;
pub const IP_OLD_FW_GET: i32 = 54;
pub const IP_NAT__XXX: i32 = 55;
pub const IP_OLD_FW_RESETLOG: i32 = 56;
pub const IP_DUMMYNET_CONFIGURE: i32 = 60;
pub const IP_DUMMYNET_DEL: i32 = 61;
pub const IP_DUMMYNET_FLUSH: i32 = 62;
pub const IP_DUMMYNET_GET: i32 = 64;
pub const IP_TRAFFIC_MGT_BACKGROUND: i32 = 65;
pub const IP_MULTICAST_IFINDEX: i32 = 66;
pub const IP_ADD_SOURCE_MEMBERSHIP: i32 = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: i32 = 71;
pub const IP_BLOCK_SOURCE: i32 = 72;
pub const IP_UNBLOCK_SOURCE: i32 = 73;
pub const IP_MSFILTER: i32 = 74;
pub const MCAST_JOIN_GROUP: i32 = 80;
pub const MCAST_LEAVE_GROUP: i32 = 81;
pub const MCAST_JOIN_SOURCE_GROUP: i32 = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: i32 = 83;
pub const MCAST_BLOCK_SOURCE: i32 = 84;
pub const MCAST_UNBLOCK_SOURCE: i32 = 85;
pub const IP_DEFAULT_MULTICAST_TTL: i32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: i32 = 1;
pub const IP_MIN_MEMBERSHIPS: i32 = 31;
pub const IP_MAX_MEMBERSHIPS: i32 = 4095;
pub const IP_MAX_GROUP_SRC_FILTER: i32 = 512;
pub const IP_MAX_SOCK_SRC_FILTER: i32 = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: i32 = 128;
pub const MCAST_UNDEFINED: i32 = 0;
pub const MCAST_INCLUDE: i32 = 1;
pub const MCAST_EXCLUDE: i32 = 2;
pub const IP_PORTRANGE_DEFAULT: i32 = 0;
pub const IP_PORTRANGE_HIGH: i32 = 1;
pub const IP_PORTRANGE_LOW: i32 = 2;
pub const IPPROTO_MAXID: i32 = 52;
pub const IPCTL_FORWARDING: i32 = 1;
pub const IPCTL_SENDREDIRECTS: i32 = 2;
pub const IPCTL_DEFTTL: i32 = 3;
pub const IPCTL_RTEXPIRE: i32 = 5;
pub const IPCTL_RTMINEXPIRE: i32 = 6;
pub const IPCTL_RTMAXCACHE: i32 = 7;
pub const IPCTL_SOURCEROUTE: i32 = 8;
pub const IPCTL_DIRECTEDBROADCAST: i32 = 9;
pub const IPCTL_INTRQMAXLEN: i32 = 10;
pub const IPCTL_INTRQDROPS: i32 = 11;
pub const IPCTL_STATS: i32 = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: i32 = 13;
pub const IPCTL_FASTFORWARDING: i32 = 14;
pub const IPCTL_KEEPFAITH: i32 = 15;
pub const IPCTL_GIF_TTL: i32 = 16;
pub const IPCTL_MAXID: i32 = 17;
pub const __KAME_VERSION: &'static [u8; 18usize] = b"2009/apple-darwin\0";
pub const IPV6PORT_RESERVED: i32 = 1024;
pub const IPV6PORT_ANONMIN: i32 = 49152;
pub const IPV6PORT_ANONMAX: i32 = 65535;
pub const IPV6PORT_RESERVEDMIN: i32 = 600;
pub const IPV6PORT_RESERVEDMAX: i32 = 1023;
pub const INET6_ADDRSTRLEN: i32 = 46;
pub const __IPV6_ADDR_SCOPE_NODELOCAL: i32 = 1;
pub const __IPV6_ADDR_SCOPE_INTFACELOCAL: i32 = 1;
pub const __IPV6_ADDR_SCOPE_LINKLOCAL: i32 = 2;
pub const __IPV6_ADDR_SCOPE_SITELOCAL: i32 = 5;
pub const __IPV6_ADDR_SCOPE_ORGLOCAL: i32 = 8;
pub const __IPV6_ADDR_SCOPE_GLOBAL: i32 = 14;
pub const IPV6_SOCKOPT_RESERVED1: i32 = 3;
pub const IPV6_UNICAST_HOPS: i32 = 4;
pub const IPV6_MULTICAST_IF: i32 = 9;
pub const IPV6_MULTICAST_HOPS: i32 = 10;
pub const IPV6_MULTICAST_LOOP: i32 = 11;
pub const IPV6_JOIN_GROUP: i32 = 12;
pub const IPV6_LEAVE_GROUP: i32 = 13;
pub const IPV6_PORTRANGE: i32 = 14;
pub const ICMP6_FILTER: i32 = 18;
pub const IPV6_2292PKTINFO: i32 = 19;
pub const IPV6_2292HOPLIMIT: i32 = 20;
pub const IPV6_2292NEXTHOP: i32 = 21;
pub const IPV6_2292HOPOPTS: i32 = 22;
pub const IPV6_2292DSTOPTS: i32 = 23;
pub const IPV6_2292RTHDR: i32 = 24;
pub const IPV6_2292PKTOPTIONS: i32 = 25;
pub const IPV6_CHECKSUM: i32 = 26;
pub const IPV6_V6ONLY: i32 = 27;
pub const IPV6_BINDV6ONLY: i32 = 27;
pub const IPV6_IPSEC_POLICY: i32 = 28;
pub const IPV6_FAITH: i32 = 29;
pub const IPV6_FW_ADD: i32 = 30;
pub const IPV6_FW_DEL: i32 = 31;
pub const IPV6_FW_FLUSH: i32 = 32;
pub const IPV6_FW_ZERO: i32 = 33;
pub const IPV6_FW_GET: i32 = 34;
pub const IPV6_RECVTCLASS: i32 = 35;
pub const IPV6_TCLASS: i32 = 36;
pub const IPV6_BOUND_IF: i32 = 125;
pub const IPV6_RTHDR_LOOSE: i32 = 0;
pub const IPV6_RTHDR_STRICT: i32 = 1;
pub const IPV6_RTHDR_TYPE_0: i32 = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: i32 = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: i32 = 1;
pub const IPV6_MIN_MEMBERSHIPS: i32 = 31;
pub const IPV6_MAX_MEMBERSHIPS: i32 = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: i32 = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: i32 = 128;
pub const IPV6_PORTRANGE_DEFAULT: i32 = 0;
pub const IPV6_PORTRANGE_HIGH: i32 = 1;
pub const IPV6_PORTRANGE_LOW: i32 = 2;
pub const IPV6PROTO_MAXID: i32 = 104;
pub const IPV6CTL_FORWARDING: i32 = 1;
pub const IPV6CTL_SENDREDIRECTS: i32 = 2;
pub const IPV6CTL_DEFHLIM: i32 = 3;
pub const IPV6CTL_FORWSRCRT: i32 = 5;
pub const IPV6CTL_STATS: i32 = 6;
pub const IPV6CTL_MRTSTATS: i32 = 7;
pub const IPV6CTL_MRTPROTO: i32 = 8;
pub const IPV6CTL_MAXFRAGPACKETS: i32 = 9;
pub const IPV6CTL_SOURCECHECK: i32 = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: i32 = 11;
pub const IPV6CTL_ACCEPT_RTADV: i32 = 12;
pub const IPV6CTL_KEEPFAITH: i32 = 13;
pub const IPV6CTL_LOG_INTERVAL: i32 = 14;
pub const IPV6CTL_HDRNESTLIMIT: i32 = 15;
pub const IPV6CTL_DAD_COUNT: i32 = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: i32 = 17;
pub const IPV6CTL_DEFMCASTHLIM: i32 = 18;
pub const IPV6CTL_GIF_HLIM: i32 = 19;
pub const IPV6CTL_KAME_VERSION: i32 = 20;
pub const IPV6CTL_USE_DEPRECATED: i32 = 21;
pub const IPV6CTL_RR_PRUNE: i32 = 22;
pub const IPV6CTL_V6ONLY: i32 = 24;
pub const IPV6CTL_RTEXPIRE: i32 = 25;
pub const IPV6CTL_RTMINEXPIRE: i32 = 26;
pub const IPV6CTL_RTMAXCACHE: i32 = 27;
pub const IPV6CTL_USETEMPADDR: i32 = 32;
pub const IPV6CTL_TEMPPLTIME: i32 = 33;
pub const IPV6CTL_TEMPVLTIME: i32 = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: i32 = 35;
pub const IPV6CTL_RIP6STATS: i32 = 36;
pub const IPV6CTL_PREFER_TEMPADDR: i32 = 37;
pub const IPV6CTL_ADDRCTLPOLICY: i32 = 38;
pub const IPV6CTL_USE_DEFAULTZONE: i32 = 39;
pub const IPV6CTL_MAXFRAGS: i32 = 41;
pub const IPV6CTL_MCAST_PMTU: i32 = 44;
pub const IPV6CTL_NEIGHBORGCTHRESH: i32 = 46;
pub const IPV6CTL_MAXIFPREFIXES: i32 = 47;
pub const IPV6CTL_MAXIFDEFROUTERS: i32 = 48;
pub const IPV6CTL_MAXDYNROUTES: i32 = 49;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: i32 = 50;
pub const IPV6CTL_MAXID: i32 = 51;
pub const _PATH_HEQUIV: &'static [u8; 17usize] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &'static [u8; 11usize] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &'static [u8; 14usize] = b"/etc/networks\0";
pub const _PATH_PROTOCOLS: &'static [u8; 15usize] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &'static [u8; 14usize] = b"/etc/services\0";
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: i32 = 0;
pub const HOST_NOT_FOUND: i32 = 1;
pub const TRY_AGAIN: i32 = 2;
pub const NO_RECOVERY: i32 = 3;
pub const NO_DATA: i32 = 4;
pub const NO_ADDRESS: i32 = 4;
pub const EAI_ADDRFAMILY: i32 = 1;
pub const EAI_AGAIN: i32 = 2;
pub const EAI_BADFLAGS: i32 = 3;
pub const EAI_FAIL: i32 = 4;
pub const EAI_FAMILY: i32 = 5;
pub const EAI_MEMORY: i32 = 6;
pub const EAI_NODATA: i32 = 7;
pub const EAI_NONAME: i32 = 8;
pub const EAI_SERVICE: i32 = 9;
pub const EAI_SOCKTYPE: i32 = 10;
pub const EAI_SYSTEM: i32 = 11;
pub const EAI_BADHINTS: i32 = 12;
pub const EAI_PROTOCOL: i32 = 13;
pub const EAI_OVERFLOW: i32 = 14;
pub const EAI_MAX: i32 = 15;
pub const AI_PASSIVE: i32 = 1;
pub const AI_CANONNAME: i32 = 2;
pub const AI_NUMERICHOST: i32 = 4;
pub const AI_NUMERICSERV: i32 = 4096;
pub const AI_ALL: i32 = 256;
pub const AI_V4MAPPED_CFG: i32 = 512;
pub const AI_ADDRCONFIG: i32 = 1024;
pub const AI_V4MAPPED: i32 = 2048;
pub const AI_DEFAULT: i32 = 1536;
pub const AI_UNUSABLE: i32 = 268435456;
pub const NI_MAXHOST: i32 = 1025;
pub const NI_MAXSERV: i32 = 32;
pub const NI_NOFQDN: i32 = 1;
pub const NI_NUMERICHOST: i32 = 2;
pub const NI_NAMEREQD: i32 = 4;
pub const NI_NUMERICSERV: i32 = 8;
pub const NI_NUMERICSCOPE: i32 = 256;
pub const NI_DGRAM: i32 = 16;
pub const NI_WITHSCOPEID: i32 = 32;
pub const SCOPE_DELIMITER: u8 = 37u8;
pub const _PATH_PWD: &'static [u8; 5usize] = b"/etc\0";
pub const _PATH_PASSWD: &'static [u8; 12usize] = b"/etc/passwd\0";
pub const _PASSWD: &'static [u8; 7usize] = b"passwd\0";
pub const _PATH_MASTERPASSWD: &'static [u8; 19usize] = b"/etc/master.passwd\0";
pub const _PATH_MASTERPASSWD_LOCK: &'static [u8; 10usize] = b"/etc/ptmp\0";
pub const _MASTERPASSWD: &'static [u8; 14usize] = b"master.passwd\0";
pub const _PATH_MP_DB: &'static [u8; 12usize] = b"/etc/pwd.db\0";
pub const _MP_DB: &'static [u8; 7usize] = b"pwd.db\0";
pub const _PATH_SMP_DB: &'static [u8; 13usize] = b"/etc/spwd.db\0";
pub const _SMP_DB: &'static [u8; 8usize] = b"spwd.db\0";
pub const _PATH_PWD_MKDB: &'static [u8; 19usize] = b"/usr/sbin/pwd_mkdb\0";
pub const _PW_KEYBYNAME: u8 = 49u8;
pub const _PW_KEYBYNUM: u8 = 50u8;
pub const _PW_KEYBYUID: u8 = 51u8;
pub const _PASSWORD_EFMT1: u8 = 95u8;
pub const _PASSWORD_LEN: i32 = 128;
pub const _PASSWORD_NOUID: i32 = 1;
pub const _PASSWORD_NOGID: i32 = 2;
pub const _PASSWORD_NOCHG: i32 = 4;
pub const _PASSWORD_NOEXP: i32 = 8;
pub const _PASSWORD_WARNDAYS: i32 = 14;
pub const _PASSWORD_CHGNOW: i32 = -1;
pub const PGINVALID_SOCKET: i32 = -1;
pub const PG_BACKEND_VERSIONSTR: &'static [u8; 28usize] = b"postgres (PostgreSQL) 12.4\n\0";
pub const EXE: &'static [u8; 1usize] = b"\0";
pub const DEVNULL: &'static [u8; 10usize] = b"/dev/null\0";
pub const USE_REPL_SNPRINTF: i32 = 1;
pub const PG_STRERROR_R_BUFLEN: i32 = 256;
pub const PG_IOLBF: i32 = 1;
pub const FP_NAN: i32 = 1;
pub const FP_INFINITE: i32 = 2;
pub const FP_ZERO: i32 = 3;
pub const FP_NORMAL: i32 = 4;
pub const FP_SUBNORMAL: i32 = 5;
pub const FP_SUPERNORMAL: i32 = 6;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: i32 = 1;
pub const MATH_ERREXCEPT: i32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: i32 = 1;
pub const FP_QNAN: i32 = 1;
pub const DOMAIN: i32 = 1;
pub const SING: i32 = 2;
pub const OVERFLOW: i32 = 3;
pub const UNDERFLOW: i32 = 4;
pub const TLOSS: i32 = 5;
pub const PLOSS: i32 = 6;
pub const _JBLEN: i32 = 37;
pub const DEBUG5: i32 = 10;
pub const DEBUG4: i32 = 11;
pub const DEBUG3: i32 = 12;
pub const DEBUG2: i32 = 13;
pub const DEBUG1: i32 = 14;
pub const LOG: i32 = 15;
pub const LOG_SERVER_ONLY: i32 = 16;
pub const COMMERROR: i32 = 16;
pub const INFO: i32 = 17;
pub const NOTICE: i32 = 18;
pub const WARNING: i32 = 19;
pub const ERROR: i32 = 20;
pub const FATAL: i32 = 21;
pub const PANIC: i32 = 22;
pub const LOG_DESTINATION_STDERR: i32 = 1;
pub const LOG_DESTINATION_SYSLOG: i32 = 2;
pub const LOG_DESTINATION_EVENTLOG: i32 = 4;
pub const LOG_DESTINATION_CSVLOG: i32 = 8;
pub const MCXT_ALLOC_HUGE: i32 = 1;
pub const MCXT_ALLOC_NO_OOM: i32 = 2;
pub const MCXT_ALLOC_ZERO: i32 = 4;
pub const VARATT_SHORT_MAX: i32 = 127;
pub const FIELDNO_NULLABLE_DATUM_DATUM: i32 = 0;
pub const FIELDNO_NULLABLE_DATUM_ISNULL: i32 = 1;
pub const SIZEOF_DATUM: i32 = 8;
pub const FIELDNO_FUNCTIONCALLINFODATA_ISNULL: i32 = 4;
pub const FIELDNO_FUNCTIONCALLINFODATA_ARGS: i32 = 6;
pub const PG_MAGIC_FUNCTION_NAME_STRING: &'static [u8; 14usize] = b"Pg_magic_func\0";
pub const AGG_CONTEXT_AGGREGATE: i32 = 1;
pub const AGG_CONTEXT_WINDOW: i32 = 2;
pub const InvalidAttrNumber: i32 = 0;
pub const MaxAttrNumber: i32 = 32767;
pub const AttributeRelationId: i32 = 1249;
pub const AttributeRelation_Rowtype_Id: i32 = 75;
pub const Anum_pg_attribute_attrelid: i32 = 1;
pub const Anum_pg_attribute_attname: i32 = 2;
pub const Anum_pg_attribute_atttypid: i32 = 3;
pub const Anum_pg_attribute_attstattarget: i32 = 4;
pub const Anum_pg_attribute_attlen: i32 = 5;
pub const Anum_pg_attribute_attnum: i32 = 6;
pub const Anum_pg_attribute_attndims: i32 = 7;
pub const Anum_pg_attribute_attcacheoff: i32 = 8;
pub const Anum_pg_attribute_atttypmod: i32 = 9;
pub const Anum_pg_attribute_attbyval: i32 = 10;
pub const Anum_pg_attribute_attstorage: i32 = 11;
pub const Anum_pg_attribute_attalign: i32 = 12;
pub const Anum_pg_attribute_attnotnull: i32 = 13;
pub const Anum_pg_attribute_atthasdef: i32 = 14;
pub const Anum_pg_attribute_atthasmissing: i32 = 15;
pub const Anum_pg_attribute_attidentity: i32 = 16;
pub const Anum_pg_attribute_attgenerated: i32 = 17;
pub const Anum_pg_attribute_attisdropped: i32 = 18;
pub const Anum_pg_attribute_attislocal: i32 = 19;
pub const Anum_pg_attribute_attinhcount: i32 = 20;
pub const Anum_pg_attribute_attcollation: i32 = 21;
pub const Anum_pg_attribute_attacl: i32 = 22;
pub const Anum_pg_attribute_attoptions: i32 = 23;
pub const Anum_pg_attribute_attfdwoptions: i32 = 24;
pub const Anum_pg_attribute_attmissingval: i32 = 25;
pub const Natts_pg_attribute: i32 = 25;
pub const ATTRIBUTE_IDENTITY_ALWAYS: u8 = 97u8;
pub const ATTRIBUTE_IDENTITY_BY_DEFAULT: u8 = 100u8;
pub const ATTRIBUTE_GENERATED_STORED: u8 = 115u8;
pub const AGGSPLITOP_COMBINE: i32 = 1;
pub const AGGSPLITOP_SKIPFINAL: i32 = 2;
pub const AGGSPLITOP_SERIALIZE: i32 = 4;
pub const AGGSPLITOP_DESERIALIZE: i32 = 8;
pub const LP_UNUSED: i32 = 0;
pub const LP_NORMAL: i32 = 1;
pub const LP_REDIRECT: i32 = 2;
pub const LP_DEAD: i32 = 3;
pub const OffsetNumberMask: i32 = 65535;
pub const SpecTokenOffsetNumber: i32 = 65534;
pub const MovedPartitionsOffsetNumber: i32 = 65533;
pub const FIELDNO_HEAPTUPLEDATA_DATA: i32 = 3;
pub const SelfItemPointerAttributeNumber: i32 = -1;
pub const MinTransactionIdAttributeNumber: i32 = -2;
pub const MinCommandIdAttributeNumber: i32 = -3;
pub const MaxTransactionIdAttributeNumber: i32 = -4;
pub const MaxCommandIdAttributeNumber: i32 = -5;
pub const TableOidAttributeNumber: i32 = -6;
pub const FirstLowInvalidHeapAttributeNumber: i32 = -7;
pub const O_RDONLY: i32 = 0;
pub const O_WRONLY: i32 = 1;
pub const O_RDWR: i32 = 2;
pub const O_ACCMODE: i32 = 3;
pub const FREAD: i32 = 1;
pub const FWRITE: i32 = 2;
pub const O_NONBLOCK: i32 = 4;
pub const O_APPEND: i32 = 8;
pub const O_SYNC: i32 = 128;
pub const O_SHLOCK: i32 = 16;
pub const O_EXLOCK: i32 = 32;
pub const O_ASYNC: i32 = 64;
pub const O_FSYNC: i32 = 128;
pub const O_NOFOLLOW: i32 = 256;
pub const O_CREAT: i32 = 512;
pub const O_TRUNC: i32 = 1024;
pub const O_EXCL: i32 = 2048;
pub const AT_FDCWD: i32 = -2;
pub const AT_EACCESS: i32 = 16;
pub const AT_SYMLINK_NOFOLLOW: i32 = 32;
pub const AT_SYMLINK_FOLLOW: i32 = 64;
pub const AT_REMOVEDIR: i32 = 128;
pub const AT_REALDEV: i32 = 512;
pub const AT_FDONLY: i32 = 1024;
pub const O_EVTONLY: i32 = 32768;
pub const O_NOCTTY: i32 = 131072;
pub const O_DIRECTORY: i32 = 1048576;
pub const O_SYMLINK: i32 = 2097152;
pub const O_DSYNC: i32 = 4194304;
pub const O_CLOEXEC: i32 = 16777216;
pub const O_DP_GETRAWENCRYPTED: i32 = 1;
pub const O_DP_GETRAWUNENCRYPTED: i32 = 2;
pub const FAPPEND: i32 = 8;
pub const FASYNC: i32 = 64;
pub const FFSYNC: i32 = 128;
pub const FFDSYNC: i32 = 4194304;
pub const FNONBLOCK: i32 = 4;
pub const FNDELAY: i32 = 4;
pub const O_NDELAY: i32 = 4;
pub const CPF_OVERWRITE: i32 = 1;
pub const CPF_IGNORE_MODE: i32 = 2;
pub const CPF_MASK: i32 = 3;
pub const F_DUPFD: i32 = 0;
pub const F_GETFD: i32 = 1;
pub const F_SETFD: i32 = 2;
pub const F_GETFL: i32 = 3;
pub const F_SETFL: i32 = 4;
pub const F_GETOWN: i32 = 5;
pub const F_SETOWN: i32 = 6;
pub const F_GETLK: i32 = 7;
pub const F_SETLK: i32 = 8;
pub const F_SETLKW: i32 = 9;
pub const F_SETLKWTIMEOUT: i32 = 10;
pub const F_FLUSH_DATA: i32 = 40;
pub const F_CHKCLEAN: i32 = 41;
pub const F_PREALLOCATE: i32 = 42;
pub const F_SETSIZE: i32 = 43;
pub const F_RDADVISE: i32 = 44;
pub const F_RDAHEAD: i32 = 45;
pub const F_NOCACHE: i32 = 48;
pub const F_LOG2PHYS: i32 = 49;
pub const F_GETPATH: i32 = 50;
pub const F_FULLFSYNC: i32 = 51;
pub const F_PATHPKG_CHECK: i32 = 52;
pub const F_FREEZE_FS: i32 = 53;
pub const F_THAW_FS: i32 = 54;
pub const F_GLOBAL_NOCACHE: i32 = 55;
pub const F_ADDSIGS: i32 = 59;
pub const F_ADDFILESIGS: i32 = 61;
pub const F_NODIRECT: i32 = 62;
pub const F_GETPROTECTIONCLASS: i32 = 63;
pub const F_SETPROTECTIONCLASS: i32 = 64;
pub const F_LOG2PHYS_EXT: i32 = 65;
pub const F_GETLKPID: i32 = 66;
pub const F_SETBACKINGSTORE: i32 = 70;
pub const F_GETPATH_MTMINFO: i32 = 71;
pub const F_GETCODEDIR: i32 = 72;
pub const F_SETNOSIGPIPE: i32 = 73;
pub const F_GETNOSIGPIPE: i32 = 74;
pub const F_TRANSCODEKEY: i32 = 75;
pub const F_SINGLE_WRITER: i32 = 76;
pub const F_GETPROTECTIONLEVEL: i32 = 77;
pub const F_FINDSIGS: i32 = 78;
pub const F_ADDFILESIGS_FOR_DYLD_SIM: i32 = 83;
pub const F_BARRIERFSYNC: i32 = 85;
pub const F_ADDFILESIGS_RETURN: i32 = 97;
pub const F_CHECK_LV: i32 = 98;
pub const F_PUNCHHOLE: i32 = 99;
pub const F_TRIM_ACTIVE_FILE: i32 = 100;
pub const F_SPECULATIVE_READ: i32 = 101;
pub const F_GETPATH_NOFIRMLINK: i32 = 102;
pub const FCNTL_FS_SPECIFIC_BASE: i32 = 65536;
pub const F_DUPFD_CLOEXEC: i32 = 67;
pub const FD_CLOEXEC: i32 = 1;
pub const F_RDLCK: i32 = 1;
pub const F_UNLCK: i32 = 2;
pub const F_WRLCK: i32 = 3;
pub const SEEK_HOLE: i32 = 3;
pub const SEEK_DATA: i32 = 4;
pub const S_IFMT: i32 = 61440;
pub const S_IFIFO: i32 = 4096;
pub const S_IFCHR: i32 = 8192;
pub const S_IFDIR: i32 = 16384;
pub const S_IFBLK: i32 = 24576;
pub const S_IFREG: i32 = 32768;
pub const S_IFLNK: i32 = 40960;
pub const S_IFSOCK: i32 = 49152;
pub const S_IFWHT: i32 = 57344;
pub const S_IRWXU: i32 = 448;
pub const S_IRUSR: i32 = 256;
pub const S_IWUSR: i32 = 128;
pub const S_IXUSR: i32 = 64;
pub const S_IRWXG: i32 = 56;
pub const S_IRGRP: i32 = 32;
pub const S_IWGRP: i32 = 16;
pub const S_IXGRP: i32 = 8;
pub const S_IRWXO: i32 = 7;
pub const S_IROTH: i32 = 4;
pub const S_IWOTH: i32 = 2;
pub const S_IXOTH: i32 = 1;
pub const S_ISUID: i32 = 2048;
pub const S_ISGID: i32 = 1024;
pub const S_ISVTX: i32 = 512;
pub const S_ISTXT: i32 = 512;
pub const S_IREAD: i32 = 256;
pub const S_IWRITE: i32 = 128;
pub const S_IEXEC: i32 = 64;
pub const F_ALLOCATECONTIG: i32 = 2;
pub const F_ALLOCATEALL: i32 = 4;
pub const F_PEOFPOSMODE: i32 = 3;
pub const F_VOLPOSMODE: i32 = 4;
pub const LOCK_SH: i32 = 1;
pub const LOCK_EX: i32 = 2;
pub const LOCK_NB: i32 = 4;
pub const LOCK_UN: i32 = 8;
pub const O_POPUP: i64 = 2147483648;
pub const O_ALERT: i32 = 536870912;
pub const InvalidXLogRecPtr: i32 = 0;
pub const PG_O_DIRECT: i32 = 0;
pub const OPEN_SYNC_FLAG: i32 = 128;
pub const OPEN_DATASYNC_FLAG: i32 = 4194304;
pub const FirstGenbkiObjectId: i32 = 10000;
pub const FirstBootstrapObjectId: i32 = 12000;
pub const FirstNormalObjectId: i32 = 16384;
pub const PD_HAS_FREE_LINES: i32 = 1;
pub const PD_PAGE_FULL: i32 = 2;
pub const PD_ALL_VISIBLE: i32 = 4;
pub const PD_VALID_FLAG_BITS: i32 = 7;
pub const PG_PAGE_LAYOUT_VERSION: i32 = 4;
pub const PG_DATA_CHECKSUM_VERSION: i32 = 1;
pub const PAI_OVERWRITE: i32 = 1;
pub const PAI_IS_HEAP: i32 = 2;
pub const MaxTupleAttributeNumber: i32 = 1664;
pub const MaxHeapAttributeNumber: i32 = 1600;
pub const FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK2: i32 = 2;
pub const FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK: i32 = 3;
pub const FIELDNO_HEAPTUPLEHEADERDATA_HOFF: i32 = 4;
pub const FIELDNO_HEAPTUPLEHEADERDATA_BITS: i32 = 5;
pub const HEAP_HASNULL: i32 = 1;
pub const HEAP_HASVARWIDTH: i32 = 2;
pub const HEAP_HASEXTERNAL: i32 = 4;
pub const HEAP_HASOID_OLD: i32 = 8;
pub const HEAP_XMAX_KEYSHR_LOCK: i32 = 16;
pub const HEAP_COMBOCID: i32 = 32;
pub const HEAP_XMAX_EXCL_LOCK: i32 = 64;
pub const HEAP_XMAX_LOCK_ONLY: i32 = 128;
pub const HEAP_XMAX_SHR_LOCK: i32 = 80;
pub const HEAP_LOCK_MASK: i32 = 80;
pub const HEAP_XMIN_COMMITTED: i32 = 256;
pub const HEAP_XMIN_INVALID: i32 = 512;
pub const HEAP_XMIN_FROZEN: i32 = 768;
pub const HEAP_XMAX_COMMITTED: i32 = 1024;
pub const HEAP_XMAX_INVALID: i32 = 2048;
pub const HEAP_XMAX_IS_MULTI: i32 = 4096;
pub const HEAP_UPDATED: i32 = 8192;
pub const HEAP_MOVED_OFF: i32 = 16384;
pub const HEAP_MOVED_IN: i32 = 32768;
pub const HEAP_MOVED: i32 = 49152;
pub const HEAP_XACT_MASK: i32 = 65520;
pub const HEAP_XMAX_BITS: i32 = 7376;
pub const HEAP_NATTS_MASK: i32 = 2047;
pub const HEAP_KEYS_UPDATED: i32 = 8192;
pub const HEAP_HOT_UPDATED: i32 = 16384;
pub const HEAP_ONLY_TUPLE: i32 = 32768;
pub const HEAP2_XACT_MASK: i32 = 57344;
pub const HEAP_TUPLE_HAS_MATCH: i32 = 32768;
pub const MaxAttrSize: i32 = 10485760;
pub const InvalidBuffer: i32 = 0;
pub const TTS_FLAG_EMPTY: i32 = 2;
pub const TTS_FLAG_SHOULDFREE: i32 = 4;
pub const TTS_FLAG_SLOW: i32 = 8;
pub const TTS_FLAG_FIXED: i32 = 16;
pub const FIELDNO_TUPLETABLESLOT_FLAGS: i32 = 1;
pub const FIELDNO_TUPLETABLESLOT_NVALID: i32 = 2;
pub const FIELDNO_TUPLETABLESLOT_TUPLEDESCRIPTOR: i32 = 4;
pub const FIELDNO_TUPLETABLESLOT_VALUES: i32 = 5;
pub const FIELDNO_TUPLETABLESLOT_ISNULL: i32 = 6;
pub const FIELDNO_HEAPTUPLETABLESLOT_TUPLE: i32 = 1;
pub const FIELDNO_HEAPTUPLETABLESLOT_OFF: i32 = 2;
pub const FIELDNO_MINIMALTUPLETABLESLOT_TUPLE: i32 = 1;
pub const FIELDNO_MINIMALTUPLETABLESLOT_OFF: i32 = 4;
pub const CLOCKS_PER_SEC: i32 = 1000000;
pub const TIME_UTC: i32 = 1;
pub const PARAM_FLAG_CONST: i32 = 1;
pub const BTLessStrategyNumber: i32 = 1;
pub const BTLessEqualStrategyNumber: i32 = 2;
pub const BTEqualStrategyNumber: i32 = 3;
pub const BTGreaterEqualStrategyNumber: i32 = 4;
pub const BTGreaterStrategyNumber: i32 = 5;
pub const BTMaxStrategyNumber: i32 = 5;
pub const HTEqualStrategyNumber: i32 = 1;
pub const HTMaxStrategyNumber: i32 = 1;
pub const RTLeftStrategyNumber: i32 = 1;
pub const RTOverLeftStrategyNumber: i32 = 2;
pub const RTOverlapStrategyNumber: i32 = 3;
pub const RTOverRightStrategyNumber: i32 = 4;
pub const RTRightStrategyNumber: i32 = 5;
pub const RTSameStrategyNumber: i32 = 6;
pub const RTContainsStrategyNumber: i32 = 7;
pub const RTContainedByStrategyNumber: i32 = 8;
pub const RTOverBelowStrategyNumber: i32 = 9;
pub const RTBelowStrategyNumber: i32 = 10;
pub const RTAboveStrategyNumber: i32 = 11;
pub const RTOverAboveStrategyNumber: i32 = 12;
pub const RTOldContainsStrategyNumber: i32 = 13;
pub const RTOldContainedByStrategyNumber: i32 = 14;
pub const RTKNNSearchStrategyNumber: i32 = 15;
pub const RTContainsElemStrategyNumber: i32 = 16;
pub const RTAdjacentStrategyNumber: i32 = 17;
pub const RTEqualStrategyNumber: i32 = 18;
pub const RTNotEqualStrategyNumber: i32 = 19;
pub const RTLessStrategyNumber: i32 = 20;
pub const RTLessEqualStrategyNumber: i32 = 21;
pub const RTGreaterStrategyNumber: i32 = 22;
pub const RTGreaterEqualStrategyNumber: i32 = 23;
pub const RTSubStrategyNumber: i32 = 24;
pub const RTSubEqualStrategyNumber: i32 = 25;
pub const RTSuperStrategyNumber: i32 = 26;
pub const RTSuperEqualStrategyNumber: i32 = 27;
pub const RTPrefixStrategyNumber: i32 = 28;
pub const RTMaxStrategyNumber: i32 = 28;
pub const BITS_PER_BITMAPWORD: i32 = 64;
pub const INNER_VAR: i32 = 65000;
pub const OUTER_VAR: i32 = 65001;
pub const INDEX_VAR: i32 = 65002;
pub const PRS2_OLD_VARNO: i32 = 1;
pub const PRS2_NEW_VARNO: i32 = 2;
pub const HASH_PARTITION: i32 = 1;
pub const HASH_SEGMENT: i32 = 2;
pub const HASH_DIRSIZE: i32 = 4;
pub const HASH_FFACTOR: i32 = 8;
pub const HASH_ELEM: i32 = 16;
pub const HASH_BLOBS: i32 = 32;
pub const HASH_FUNCTION: i32 = 64;
pub const HASH_COMPARE: i32 = 128;
pub const HASH_KEYCOPY: i32 = 256;
pub const HASH_ALLOC: i32 = 512;
pub const HASH_CONTEXT: i32 = 1024;
pub const HASH_SHARED_MEM: i32 = 2048;
pub const HASH_ATTACH: i32 = 4096;
pub const HASH_FIXED_SIZE: i32 = 8192;
pub const NO_MAX_DSIZE: i32 = -1;
pub const __DARWIN_MAXNAMLEN: i32 = 255;
pub const __DARWIN_MAXPATHLEN: i32 = 1024;
pub const MAXNAMLEN: i32 = 255;
pub const DT_UNKNOWN: i32 = 0;
pub const DT_FIFO: i32 = 1;
pub const DT_CHR: i32 = 2;
pub const DT_DIR: i32 = 4;
pub const DT_BLK: i32 = 6;
pub const DT_REG: i32 = 8;
pub const DT_LNK: i32 = 10;
pub const DT_SOCK: i32 = 12;
pub const DT_WHT: i32 = 14;
pub const DIRBLKSIZ: i32 = 1024;
pub const DTF_HIDEW: i32 = 1;
pub const DTF_NODUP: i32 = 2;
pub const DTF_REWIND: i32 = 4;
pub const __DTF_READALL: i32 = 8;
pub const __DTF_SKIPREAD: i32 = 16;
pub const __DTF_ATEND: i32 = 32;
pub const PG_TEMP_FILES_DIR: &'static [u8; 10usize] = b"pgsql_tmp\0";
pub const PG_TEMP_FILE_PREFIX: &'static [u8; 10usize] = b"pgsql_tmp\0";
pub const DSM_IMPL_POSIX: i32 = 1;
pub const DSM_IMPL_SYSV: i32 = 2;
pub const DSM_IMPL_WINDOWS: i32 = 3;
pub const DSM_IMPL_MMAP: i32 = 4;
pub const DEFAULT_DYNAMIC_SHARED_MEMORY_TYPE: i32 = 1;
pub const PG_DYNSHMEM_DIR: &'static [u8; 12usize] = b"pg_dynshmem\0";
pub const PG_DYNSHMEM_MMAP_FILE_PREFIX: &'static [u8; 6usize] = b"mmap.\0";
pub const DSM_CREATE_NULL_IF_MAXSEGMENTS: i32 = 1;
pub const DSM_HANDLE_INVALID: i32 = 0;
pub const DEFAULT_SPINS_PER_DELAY: i32 = 100;
pub const SHARED_TUPLESTORE_SINGLE_PASS: i32 = 1;
pub const MAX_TIMESTAMP_PRECISION: i32 = 6;
pub const MAX_INTERVAL_PRECISION: i32 = 6;
pub const TS_PREC_INV: f64 = 1000000.0;
pub const DAYS_PER_YEAR: f64 = 365.25;
pub const MONTHS_PER_YEAR: i32 = 12;
pub const DAYS_PER_MONTH: i32 = 30;
pub const HOURS_PER_DAY: i32 = 24;
pub const SECS_PER_YEAR: i32 = 31557600;
pub const SECS_PER_DAY: i32 = 86400;
pub const SECS_PER_HOUR: i32 = 3600;
pub const SECS_PER_MINUTE: i32 = 60;
pub const MINS_PER_HOUR: i32 = 60;
pub const MAX_TZDISP_HOUR: i32 = 15;
pub const TZDISP_LIMIT: i32 = 57600;
pub const JULIAN_MINYEAR: i32 = -4713;
pub const JULIAN_MINMONTH: i32 = 11;
pub const JULIAN_MINDAY: i32 = 24;
pub const JULIAN_MAXYEAR: i32 = 5874898;
pub const JULIAN_MAXMONTH: i32 = 6;
pub const JULIAN_MAXDAY: i32 = 3;
pub const UNIX_EPOCH_JDATE: i32 = 2440588;
pub const POSTGRES_EPOCH_JDATE: i32 = 2451545;
pub const DATETIME_MIN_JULIAN: i32 = 0;
pub const DATE_END_JULIAN: i32 = 2147483494;
pub const TIMESTAMP_END_JULIAN: i32 = 109203528;
pub const RELCACHE_INIT_FILENAME: &'static [u8; 17usize] = b"pg_internal.init\0";
pub const INDEX_SIZE_MASK: i32 = 8191;
pub const INDEX_AM_RESERVED_BIT: i32 = 8192;
pub const INDEX_VAR_MASK: i32 = 16384;
pub const INDEX_NULL_MASK: i32 = 32768;
pub const __DARWIN_CLK_TCK: i32 = 100;
pub const CHAR_BIT: i32 = 8;
pub const MB_LEN_MAX: i32 = 6;
pub const CLK_TCK: i32 = 100;
pub const SCHAR_MAX: i32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: i32 = 255;
pub const CHAR_MAX: i32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: i32 = 65535;
pub const SHRT_MAX: i32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: i64 = 4294967295;
pub const INT_MAX: i32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: i64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: i64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: i32 = 64;
pub const SSIZE_MAX: i64 = 9223372036854775807;
pub const WORD_BIT: i32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: i64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: i32 = 262144;
pub const CHILD_MAX: i32 = 266;
pub const GID_MAX: i32 = 2147483647;
pub const LINK_MAX: i32 = 32767;
pub const MAX_CANON: i32 = 1024;
pub const MAX_INPUT: i32 = 1024;
pub const NAME_MAX: i32 = 255;
pub const NGROUPS_MAX: i32 = 16;
pub const UID_MAX: i32 = 2147483647;
pub const OPEN_MAX: i32 = 10240;
pub const PATH_MAX: i32 = 1024;
pub const PIPE_BUF: i32 = 512;
pub const BC_BASE_MAX: i32 = 99;
pub const BC_DIM_MAX: i32 = 2048;
pub const BC_SCALE_MAX: i32 = 99;
pub const BC_STRING_MAX: i32 = 1000;
pub const CHARCLASS_NAME_MAX: i32 = 14;
pub const COLL_WEIGHTS_MAX: i32 = 2;
pub const EQUIV_CLASS_MAX: i32 = 2;
pub const EXPR_NEST_MAX: i32 = 32;
pub const LINE_MAX: i32 = 2048;
pub const RE_DUP_MAX: i32 = 255;
pub const NZERO: i32 = 20;
pub const _POSIX_ARG_MAX: i32 = 4096;
pub const _POSIX_CHILD_MAX: i32 = 25;
pub const _POSIX_LINK_MAX: i32 = 8;
pub const _POSIX_MAX_CANON: i32 = 255;
pub const _POSIX_MAX_INPUT: i32 = 255;
pub const _POSIX_NAME_MAX: i32 = 14;
pub const _POSIX_NGROUPS_MAX: i32 = 8;
pub const _POSIX_OPEN_MAX: i32 = 20;
pub const _POSIX_PATH_MAX: i32 = 256;
pub const _POSIX_PIPE_BUF: i32 = 512;
pub const _POSIX_SSIZE_MAX: i32 = 32767;
pub const _POSIX_STREAM_MAX: i32 = 8;
pub const _POSIX_TZNAME_MAX: i32 = 6;
pub const _POSIX2_BC_BASE_MAX: i32 = 99;
pub const _POSIX2_BC_DIM_MAX: i32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: i32 = 99;
pub const _POSIX2_BC_STRING_MAX: i32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: i32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: i32 = 32;
pub const _POSIX2_LINE_MAX: i32 = 2048;
pub const _POSIX2_RE_DUP_MAX: i32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: i32 = 2;
pub const _POSIX_AIO_MAX: i32 = 1;
pub const _POSIX_DELAYTIMER_MAX: i32 = 32;
pub const _POSIX_MQ_OPEN_MAX: i32 = 8;
pub const _POSIX_MQ_PRIO_MAX: i32 = 32;
pub const _POSIX_RTSIG_MAX: i32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: i32 = 256;
pub const _POSIX_SEM_VALUE_MAX: i32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: i32 = 32;
pub const _POSIX_TIMER_MAX: i32 = 32;
pub const _POSIX_CLOCKRES_MIN: i32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: i32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: i32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: i32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: i32 = 4;
pub const PTHREAD_KEYS_MAX: i32 = 512;
pub const PTHREAD_STACK_MIN: i32 = 8192;
pub const _POSIX_HOST_NAME_MAX: i32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: i32 = 9;
pub const _POSIX_SS_REPL_MAX: i32 = 4;
pub const _POSIX_SYMLINK_MAX: i32 = 255;
pub const _POSIX_SYMLOOP_MAX: i32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: i32 = 30;
pub const _POSIX_TRACE_NAME_MAX: i32 = 8;
pub const _POSIX_TRACE_SYS_MAX: i32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: i32 = 32;
pub const _POSIX_TTY_NAME_MAX: i32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: i32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: i32 = 2;
pub const _POSIX_RE_DUP_MAX: i32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: i64 = 9223372036854775807;
pub const PASS_MAX: i32 = 128;
pub const NL_ARGMAX: i32 = 9;
pub const NL_LANGMAX: i32 = 14;
pub const NL_MSGMAX: i32 = 32767;
pub const NL_NMAX: i32 = 1;
pub const NL_SETMAX: i32 = 255;
pub const NL_TEXTMAX: i32 = 2048;
pub const _XOPEN_IOV_MAX: i32 = 16;
pub const IOV_MAX: i32 = 1024;
pub const _XOPEN_NAME_MAX: i32 = 255;
pub const _XOPEN_PATH_MAX: i32 = 1024;
pub const SIZEOF_DSA_POINTER: i32 = 8;
pub const DSA_POINTER_FORMAT: &'static [u8; 7usize] = b"%016lx\0";
pub const DSA_ALLOC_HUGE: i32 = 1;
pub const DSA_ALLOC_NO_OOM: i32 = 2;
pub const DSA_ALLOC_ZERO: i32 = 4;
pub const EEO_FLAG_IS_QUAL: i32 = 1;
pub const FIELDNO_EXPRSTATE_RESNULL: i32 = 2;
pub const FIELDNO_EXPRSTATE_RESVALUE: i32 = 3;
pub const FIELDNO_EXPRSTATE_RESULTSLOT: i32 = 4;
pub const FIELDNO_EXPRCONTEXT_SCANTUPLE: i32 = 1;
pub const FIELDNO_EXPRCONTEXT_INNERTUPLE: i32 = 2;
pub const FIELDNO_EXPRCONTEXT_OUTERTUPLE: i32 = 3;
pub const FIELDNO_EXPRCONTEXT_AGGVALUES: i32 = 8;
pub const FIELDNO_EXPRCONTEXT_AGGNULLS: i32 = 9;
pub const FIELDNO_EXPRCONTEXT_CASEDATUM: i32 = 10;
pub const FIELDNO_EXPRCONTEXT_CASENULL: i32 = 11;
pub const FIELDNO_EXPRCONTEXT_DOMAINDATUM: i32 = 12;
pub const FIELDNO_EXPRCONTEXT_DOMAINNULL: i32 = 13;
pub const FIELDNO_AGGSTATE_CURAGGCONTEXT: i32 = 14;
pub const FIELDNO_AGGSTATE_CURPERTRANS: i32 = 16;
pub const FIELDNO_AGGSTATE_CURRENT_SET: i32 = 20;
pub const FIELDNO_AGGSTATE_ALL_PERGROUPS: i32 = 34;
pub const COMPLETION_TAG_BUFSIZE: i32 = 64;
pub const ACL_INSERT: i32 = 1;
pub const ACL_SELECT: i32 = 2;
pub const ACL_UPDATE: i32 = 4;
pub const ACL_DELETE: i32 = 8;
pub const ACL_TRUNCATE: i32 = 16;
pub const ACL_REFERENCES: i32 = 32;
pub const ACL_TRIGGER: i32 = 64;
pub const ACL_EXECUTE: i32 = 128;
pub const ACL_USAGE: i32 = 256;
pub const ACL_CREATE: i32 = 512;
pub const ACL_CREATE_TEMP: i32 = 1024;
pub const ACL_CONNECT: i32 = 2048;
pub const N_ACL_RIGHTS: i32 = 12;
pub const ACL_NO_RIGHTS: i32 = 0;
pub const ACL_SELECT_FOR_UPDATE: i32 = 4;
pub const FRAMEOPTION_NONDEFAULT: i32 = 1;
pub const FRAMEOPTION_RANGE: i32 = 2;
pub const FRAMEOPTION_ROWS: i32 = 4;
pub const FRAMEOPTION_GROUPS: i32 = 8;
pub const FRAMEOPTION_BETWEEN: i32 = 16;
pub const FRAMEOPTION_START_UNBOUNDED_PRECEDING: i32 = 32;
pub const FRAMEOPTION_END_UNBOUNDED_PRECEDING: i32 = 64;
pub const FRAMEOPTION_START_UNBOUNDED_FOLLOWING: i32 = 128;
pub const FRAMEOPTION_END_UNBOUNDED_FOLLOWING: i32 = 256;
pub const FRAMEOPTION_START_CURRENT_ROW: i32 = 512;
pub const FRAMEOPTION_END_CURRENT_ROW: i32 = 1024;
pub const FRAMEOPTION_START_OFFSET_PRECEDING: i32 = 2048;
pub const FRAMEOPTION_END_OFFSET_PRECEDING: i32 = 4096;
pub const FRAMEOPTION_START_OFFSET_FOLLOWING: i32 = 8192;
pub const FRAMEOPTION_END_OFFSET_FOLLOWING: i32 = 16384;
pub const FRAMEOPTION_EXCLUDE_CURRENT_ROW: i32 = 32768;
pub const FRAMEOPTION_EXCLUDE_GROUP: i32 = 65536;
pub const FRAMEOPTION_EXCLUDE_TIES: i32 = 131072;
pub const FRAMEOPTION_START_OFFSET: i32 = 10240;
pub const FRAMEOPTION_END_OFFSET: i32 = 20480;
pub const FRAMEOPTION_EXCLUSION: i32 = 229376;
pub const FRAMEOPTION_DEFAULTS: i32 = 1058;
pub const PARTITION_STRATEGY_HASH: u8 = 104u8;
pub const PARTITION_STRATEGY_LIST: u8 = 108u8;
pub const PARTITION_STRATEGY_RANGE: u8 = 114u8;
pub const FKCONSTR_ACTION_NOACTION: u8 = 97u8;
pub const FKCONSTR_ACTION_RESTRICT: u8 = 114u8;
pub const FKCONSTR_ACTION_CASCADE: u8 = 99u8;
pub const FKCONSTR_ACTION_SETNULL: u8 = 110u8;
pub const FKCONSTR_ACTION_SETDEFAULT: u8 = 100u8;
pub const FKCONSTR_MATCH_FULL: u8 = 102u8;
pub const FKCONSTR_MATCH_PARTIAL: u8 = 112u8;
pub const FKCONSTR_MATCH_SIMPLE: u8 = 115u8;
pub const OPCLASS_ITEM_OPERATOR: i32 = 1;
pub const OPCLASS_ITEM_FUNCTION: i32 = 2;
pub const OPCLASS_ITEM_STORAGETYPE: i32 = 3;
pub const CURSOR_OPT_BINARY: i32 = 1;
pub const CURSOR_OPT_SCROLL: i32 = 2;
pub const CURSOR_OPT_NO_SCROLL: i32 = 4;
pub const CURSOR_OPT_INSENSITIVE: i32 = 8;
pub const CURSOR_OPT_HOLD: i32 = 16;
pub const CURSOR_OPT_FAST_PLAN: i32 = 32;
pub const CURSOR_OPT_GENERIC_PLAN: i32 = 64;
pub const CURSOR_OPT_CUSTOM_PLAN: i32 = 128;
pub const CURSOR_OPT_PARALLEL_OK: i32 = 256;
pub const FETCH_ALL: i64 = 9223372036854775807;
pub const REINDEXOPT_VERBOSE: i32 = 1;
pub const REINDEXOPT_REPORT_PROGRESS: i32 = 2;
pub const MaxAllocHugeSize: i32 = 0;
pub const ALLOCSET_DEFAULT_MINSIZE: i32 = 0;
pub const ALLOCSET_DEFAULT_INITSIZE: i32 = 8192;
pub const ALLOCSET_DEFAULT_MAXSIZE: i32 = 8388608;
pub const ALLOCSET_SMALL_MINSIZE: i32 = 0;
pub const ALLOCSET_SMALL_INITSIZE: i32 = 1024;
pub const ALLOCSET_SMALL_MAXSIZE: i32 = 8192;
pub const ALLOCSET_SEPARATE_THRESHOLD: i32 = 8192;
pub const SLAB_DEFAULT_BLOCK_SIZE: i32 = 8192;
pub const SLAB_LARGE_BLOCK_SIZE: i32 = 8388608;
pub const EXEC_FLAG_EXPLAIN_ONLY: i32 = 1;
pub const EXEC_FLAG_REWIND: i32 = 2;
pub const EXEC_FLAG_BACKWARD: i32 = 4;
pub const EXEC_FLAG_MARK: i32 = 8;
pub const EXEC_FLAG_SKIP_TRIGGERS: i32 = 16;
pub const EXEC_FLAG_WITH_NO_DATA: i32 = 32;
pub const TZ_STRLEN_MAX: i32 = 255;
pub const InvalidPid: i32 = -1;
pub const USE_POSTGRES_DATES: i32 = 0;
pub const USE_ISO_DATES: i32 = 1;
pub const USE_SQL_DATES: i32 = 2;
pub const USE_GERMAN_DATES: i32 = 3;
pub const USE_XSD_DATES: i32 = 4;
pub const DATEORDER_YMD: i32 = 0;
pub const DATEORDER_DMY: i32 = 1;
pub const DATEORDER_MDY: i32 = 2;
pub const INTSTYLE_POSTGRES: i32 = 0;
pub const INTSTYLE_POSTGRES_VERBOSE: i32 = 1;
pub const INTSTYLE_SQL_STANDARD: i32 = 2;
pub const INTSTYLE_ISO_8601: i32 = 3;
pub const MAXTZLEN: i32 = 10;
pub const SECURITY_LOCAL_USERID_CHANGE: i32 = 1;
pub const SECURITY_RESTRICTED_OPERATION: i32 = 2;
pub const SECURITY_NOFORCE_RLS: i32 = 4;
pub const SOL_LOCAL: i32 = 0;
pub const LOCAL_PEERCRED: i32 = 1;
pub const LOCAL_PEERPID: i32 = 2;
pub const LOCAL_PEEREPID: i32 = 3;
pub const LOCAL_PEERUUID: i32 = 4;
pub const LOCAL_PEEREUUID: i32 = 5;
pub const SM_DATABASE: i32 = 64;
pub const SM_USER: i32 = 32;
pub const SM_DATABASE_USER: i32 = 97;
pub const SM_OPTIONS: i32 = 64;
pub const SM_UNUSED: i32 = 64;
pub const SM_TTY: i32 = 64;
pub const MAX_STARTUP_PACKET_LENGTH: i32 = 10000;
pub const AUTH_REQ_OK: i32 = 0;
pub const AUTH_REQ_KRB4: i32 = 1;
pub const AUTH_REQ_KRB5: i32 = 2;
pub const AUTH_REQ_PASSWORD: i32 = 3;
pub const AUTH_REQ_CRYPT: i32 = 4;
pub const AUTH_REQ_MD5: i32 = 5;
pub const AUTH_REQ_SCM_CREDS: i32 = 6;
pub const AUTH_REQ_GSS: i32 = 7;
pub const AUTH_REQ_GSS_CONT: i32 = 8;
pub const AUTH_REQ_SSPI: i32 = 9;
pub const AUTH_REQ_SASL: i32 = 10;
pub const AUTH_REQ_SASL_CONT: i32 = 11;
pub const AUTH_REQ_SASL_FIN: i32 = 12;
pub const MIN_XFN_CHARS: i32 = 16;
pub const MAX_XFN_CHARS: i32 = 40;
pub const VALID_XFN_CHARS: &'static [u8; 40usize] = b"0123456789ABCDEF.history.backup.partial\0";
pub const CATALOG_VERSION_NO: i32 = 201909212;
pub const OIDCHARS: i32 = 10;
pub const FORKNAMECHARS: i32 = 4;
pub const InvalidBackendId: i32 = -1;
pub const XLR_INFO_MASK: i32 = 15;
pub const XLR_RMGR_INFO_MASK: i32 = 240;
pub const XLR_SPECIAL_REL_UPDATE: i32 = 1;
pub const XLR_CHECK_CONSISTENCY: i32 = 2;
pub const BKPIMAGE_HAS_HOLE: i32 = 1;
pub const BKPIMAGE_IS_COMPRESSED: i32 = 2;
pub const BKPIMAGE_APPLY: i32 = 4;
pub const BKPBLOCK_FORK_MASK: i32 = 15;
pub const BKPBLOCK_FLAG_MASK: i32 = 240;
pub const BKPBLOCK_HAS_IMAGE: i32 = 16;
pub const BKPBLOCK_HAS_DATA: i32 = 32;
pub const BKPBLOCK_WILL_INIT: i32 = 64;
pub const BKPBLOCK_SAME_REL: i32 = 128;
pub const XLR_MAX_BLOCK_ID: i32 = 32;
pub const XLR_BLOCK_ID_DATA_SHORT: i32 = 255;
pub const XLR_BLOCK_ID_DATA_LONG: i32 = 254;
pub const XLR_BLOCK_ID_ORIGIN: i32 = 253;
pub const TRANSACTION_STATUS_IN_PROGRESS: i32 = 0;
pub const TRANSACTION_STATUS_COMMITTED: i32 = 1;
pub const TRANSACTION_STATUS_ABORTED: i32 = 2;
pub const TRANSACTION_STATUS_SUB_COMMITTED: i32 = 3;
pub const CLOG_ZEROPAGE: i32 = 0;
pub const CLOG_TRUNCATE: i32 = 16;
pub const WL_LATCH_SET: i32 = 1;
pub const WL_SOCKET_READABLE: i32 = 2;
pub const WL_SOCKET_WRITEABLE: i32 = 4;
pub const WL_TIMEOUT: i32 = 8;
pub const WL_POSTMASTER_DEATH: i32 = 16;
pub const WL_EXIT_ON_PM_DEATH: i32 = 32;
pub const WL_SOCKET_CONNECTED: i32 = 4;
pub const WL_SOCKET_MASK: i32 = 6;
pub const NoLock: i32 = 0;
pub const AccessShareLock: i32 = 1;
pub const RowShareLock: i32 = 2;
pub const RowExclusiveLock: i32 = 3;
pub const ShareUpdateExclusiveLock: i32 = 4;
pub const ShareLock: i32 = 5;
pub const ShareRowExclusiveLock: i32 = 6;
pub const ExclusiveLock: i32 = 7;
pub const AccessExclusiveLock: i32 = 8;
pub const MaxLockMode: i32 = 8;
pub const LWLOCK_PADDED_SIZE: i32 = 128;
pub const NUM_INDIVIDUAL_LWLOCKS: i32 = 45;
pub const NUM_BUFFER_PARTITIONS: i32 = 128;
pub const LOG2_NUM_LOCK_PARTITIONS: i32 = 4;
pub const NUM_LOCK_PARTITIONS: i32 = 16;
pub const LOG2_NUM_PREDICATELOCK_PARTITIONS: i32 = 4;
pub const NUM_PREDICATELOCK_PARTITIONS: i32 = 16;
pub const BUFFER_MAPPING_LWLOCK_OFFSET: i32 = 45;
pub const LOCK_MANAGER_LWLOCK_OFFSET: i32 = 173;
pub const PREDICATELOCK_MANAGER_LWLOCK_OFFSET: i32 = 189;
pub const NUM_FIXED_LWLOCKS: i32 = 205;
pub const SHMEM_INDEX_KEYSIZE: i32 = 48;
pub const SHMEM_INDEX_SIZE: i32 = 64;
pub const InvalidLocalTransactionId: i32 = 0;
pub const MAX_LOCKMODES: i32 = 10;
pub const DEFAULT_LOCKMETHOD: i32 = 1;
pub const USER_LOCKMETHOD: i32 = 2;
pub const PGPROC_MAX_CACHED_SUBXIDS: i32 = 64;
pub const PROC_IS_AUTOVACUUM: i32 = 1;
pub const PROC_IN_VACUUM: i32 = 2;
pub const PROC_IN_ANALYZE: i32 = 4;
pub const PROC_VACUUM_FOR_WRAPAROUND: i32 = 8;
pub const PROC_IN_LOGICAL_DECODING: i32 = 16;
pub const PROC_RESERVED: i32 = 32;
pub const PROC_VACUUM_STATE_MASK: i32 = 14;
pub const FP_LOCK_SLOTS_PER_BACKEND: i32 = 16;
pub const INVALID_PGPROCNO: i32 = 2147483647;
pub const NUM_AUXILIARY_PROCS: i32 = 4;
pub const PGSTAT_STAT_PERMANENT_DIRECTORY: &'static [u8; 8usize] = b"pg_stat\0";
pub const PGSTAT_STAT_PERMANENT_FILENAME: &'static [u8; 20usize] = b"pg_stat/global.stat\0";
pub const PGSTAT_STAT_PERMANENT_TMPFILE: &'static [u8; 19usize] = b"pg_stat/global.tmp\0";
pub const PG_STAT_TMP_DIR: &'static [u8; 12usize] = b"pg_stat_tmp\0";
pub const PGSTAT_MAX_MSG_SIZE: i32 = 1000;
pub const PGSTAT_FILE_FORMAT_ID: i32 = 27638941;
pub const PG_WAIT_LWLOCK: i32 = 16777216;
pub const PG_WAIT_LOCK: i32 = 50331648;
pub const PG_WAIT_BUFFER_PIN: i32 = 67108864;
pub const PG_WAIT_ACTIVITY: i32 = 83886080;
pub const PG_WAIT_CLIENT: i32 = 100663296;
pub const PG_WAIT_EXTENSION: i32 = 117440512;
pub const PG_WAIT_IPC: i32 = 134217728;
pub const PG_WAIT_TIMEOUT: i32 = 150994944;
pub const PG_WAIT_IO: i32 = 167772160;
pub const PGSTAT_NUM_PROGRESS_PARAM: i32 = 20;
pub const SK_ISNULL: i32 = 1;
pub const SK_UNARY: i32 = 2;
pub const SK_ROW_HEADER: i32 = 4;
pub const SK_ROW_MEMBER: i32 = 8;
pub const SK_ROW_END: i32 = 16;
pub const SK_SEARCHARRAY: i32 = 32;
pub const SK_SEARCHNULL: i32 = 64;
pub const SK_SEARCHNOTNULL: i32 = 128;
pub const SK_ORDER_BY: i32 = 256;
pub const EOH_HEADER_MAGIC: i32 = -1;
pub const EA_MAGIC: i32 = 689375833;
pub const MAX_KILOBYTES: i32 = 2147483647;
pub const PG_AUTOCONF_FILENAME: &'static [u8; 21usize] = b"postgresql.auto.conf\0";
pub const GUC_QUALIFIER_SEPARATOR: u8 = 46u8;
pub const GUC_LIST_INPUT: i32 = 1;
pub const GUC_LIST_QUOTE: i32 = 2;
pub const GUC_NO_SHOW_ALL: i32 = 4;
pub const GUC_NO_RESET_ALL: i32 = 8;
pub const GUC_REPORT: i32 = 16;
pub const GUC_NOT_IN_SAMPLE: i32 = 32;
pub const GUC_DISALLOW_IN_FILE: i32 = 64;
pub const GUC_CUSTOM_PLACEHOLDER: i32 = 128;
pub const GUC_SUPERUSER_ONLY: i32 = 256;
pub const GUC_IS_NAME: i32 = 512;
pub const GUC_NOT_WHILE_SEC_REST: i32 = 1024;
pub const GUC_DISALLOW_IN_AUTO_FILE: i32 = 2048;
pub const GUC_UNIT_KB: i32 = 4096;
pub const GUC_UNIT_BLOCKS: i32 = 8192;
pub const GUC_UNIT_XBLOCKS: i32 = 12288;
pub const GUC_UNIT_MB: i32 = 16384;
pub const GUC_UNIT_BYTE: i32 = 32768;
pub const GUC_UNIT_MEMORY: i32 = 61440;
pub const GUC_UNIT_MS: i32 = 65536;
pub const GUC_UNIT_S: i32 = 131072;
pub const GUC_UNIT_MIN: i32 = 196608;
pub const GUC_UNIT_TIME: i32 = 983040;
pub const GUC_EXPLAIN: i32 = 1048576;
pub const GUC_UNIT: i32 = 1044480;
pub const XLR_NORMAL_MAX_BLOCK_ID: i32 = 4;
pub const XLR_NORMAL_RDATAS: i32 = 20;
pub const REGBUF_FORCE_IMAGE: i32 = 1;
pub const REGBUF_NO_IMAGE: i32 = 2;
pub const REGBUF_WILL_INIT: i32 = 6;
pub const REGBUF_STANDARD: i32 = 8;
pub const REGBUF_KEEP_DATA: i32 = 16;
pub const SYNC_METHOD_FSYNC: i32 = 0;
pub const SYNC_METHOD_FDATASYNC: i32 = 1;
pub const SYNC_METHOD_OPEN: i32 = 2;
pub const SYNC_METHOD_FSYNC_WRITETHROUGH: i32 = 3;
pub const SYNC_METHOD_OPEN_DSYNC: i32 = 4;
pub const CHECKPOINT_IS_SHUTDOWN: i32 = 1;
pub const CHECKPOINT_END_OF_RECOVERY: i32 = 2;
pub const CHECKPOINT_IMMEDIATE: i32 = 4;
pub const CHECKPOINT_FORCE: i32 = 8;
pub const CHECKPOINT_FLUSH_ALL: i32 = 16;
pub const CHECKPOINT_WAIT: i32 = 32;
pub const CHECKPOINT_REQUESTED: i32 = 64;
pub const CHECKPOINT_CAUSE_XLOG: i32 = 128;
pub const CHECKPOINT_CAUSE_TIME: i32 = 256;
pub const XLOG_INCLUDE_ORIGIN: i32 = 1;
pub const XLOG_MARK_UNIMPORTANT: i32 = 2;
pub const RECOVERY_SIGNAL_FILE: &'static [u8; 16usize] = b"recovery.signal\0";
pub const STANDBY_SIGNAL_FILE: &'static [u8; 15usize] = b"standby.signal\0";
pub const BACKUP_LABEL_FILE: &'static [u8; 13usize] = b"backup_label\0";
pub const BACKUP_LABEL_OLD: &'static [u8; 17usize] = b"backup_label.old\0";
pub const TABLESPACE_MAP: &'static [u8; 15usize] = b"tablespace_map\0";
pub const TABLESPACE_MAP_OLD: &'static [u8; 19usize] = b"tablespace_map.old\0";
pub const PROMOTE_SIGNAL_FILE: &'static [u8; 8usize] = b"promote\0";
pub const FALLBACK_PROMOTE_SIGNAL_FILE: &'static [u8; 17usize] = b"fallback_promote\0";
pub const RelationRelationId: i32 = 1259;
pub const RelationRelation_Rowtype_Id: i32 = 83;
pub const Anum_pg_class_oid: i32 = 1;
pub const Anum_pg_class_relname: i32 = 2;
pub const Anum_pg_class_relnamespace: i32 = 3;
pub const Anum_pg_class_reltype: i32 = 4;
pub const Anum_pg_class_reloftype: i32 = 5;
pub const Anum_pg_class_relowner: i32 = 6;
pub const Anum_pg_class_relam: i32 = 7;
pub const Anum_pg_class_relfilenode: i32 = 8;
pub const Anum_pg_class_reltablespace: i32 = 9;
pub const Anum_pg_class_relpages: i32 = 10;
pub const Anum_pg_class_reltuples: i32 = 11;
pub const Anum_pg_class_relallvisible: i32 = 12;
pub const Anum_pg_class_reltoastrelid: i32 = 13;
pub const Anum_pg_class_relhasindex: i32 = 14;
pub const Anum_pg_class_relisshared: i32 = 15;
pub const Anum_pg_class_relpersistence: i32 = 16;
pub const Anum_pg_class_relkind: i32 = 17;
pub const Anum_pg_class_relnatts: i32 = 18;
pub const Anum_pg_class_relchecks: i32 = 19;
pub const Anum_pg_class_relhasrules: i32 = 20;
pub const Anum_pg_class_relhastriggers: i32 = 21;
pub const Anum_pg_class_relhassubclass: i32 = 22;
pub const Anum_pg_class_relrowsecurity: i32 = 23;
pub const Anum_pg_class_relforcerowsecurity: i32 = 24;
pub const Anum_pg_class_relispopulated: i32 = 25;
pub const Anum_pg_class_relreplident: i32 = 26;
pub const Anum_pg_class_relispartition: i32 = 27;
pub const Anum_pg_class_relrewrite: i32 = 28;
pub const Anum_pg_class_relfrozenxid: i32 = 29;
pub const Anum_pg_class_relminmxid: i32 = 30;
pub const Anum_pg_class_relacl: i32 = 31;
pub const Anum_pg_class_reloptions: i32 = 32;
pub const Anum_pg_class_relpartbound: i32 = 33;
pub const Natts_pg_class: i32 = 33;
pub const RELKIND_RELATION: u8 = 114u8;
pub const RELKIND_INDEX: u8 = 105u8;
pub const RELKIND_SEQUENCE: u8 = 83u8;
pub const RELKIND_TOASTVALUE: u8 = 116u8;
pub const RELKIND_VIEW: u8 = 118u8;
pub const RELKIND_MATVIEW: u8 = 109u8;
pub const RELKIND_COMPOSITE_TYPE: u8 = 99u8;
pub const RELKIND_FOREIGN_TABLE: u8 = 102u8;
pub const RELKIND_PARTITIONED_TABLE: u8 = 112u8;
pub const RELKIND_PARTITIONED_INDEX: u8 = 73u8;
pub const RELPERSISTENCE_PERMANENT: u8 = 112u8;
pub const RELPERSISTENCE_UNLOGGED: u8 = 117u8;
pub const RELPERSISTENCE_TEMP: u8 = 116u8;
pub const REPLICA_IDENTITY_DEFAULT: u8 = 100u8;
pub const REPLICA_IDENTITY_NOTHING: u8 = 110u8;
pub const REPLICA_IDENTITY_FULL: u8 = 102u8;
pub const REPLICA_IDENTITY_INDEX: u8 = 105u8;
pub const IndexRelationId: i32 = 2610;
pub const Anum_pg_index_indexrelid: i32 = 1;
pub const Anum_pg_index_indrelid: i32 = 2;
pub const Anum_pg_index_indnatts: i32 = 3;
pub const Anum_pg_index_indnkeyatts: i32 = 4;
pub const Anum_pg_index_indisunique: i32 = 5;
pub const Anum_pg_index_indisprimary: i32 = 6;
pub const Anum_pg_index_indisexclusion: i32 = 7;
pub const Anum_pg_index_indimmediate: i32 = 8;
pub const Anum_pg_index_indisclustered: i32 = 9;
pub const Anum_pg_index_indisvalid: i32 = 10;
pub const Anum_pg_index_indcheckxmin: i32 = 11;
pub const Anum_pg_index_indisready: i32 = 12;
pub const Anum_pg_index_indislive: i32 = 13;
pub const Anum_pg_index_indisreplident: i32 = 14;
pub const Anum_pg_index_indkey: i32 = 15;
pub const Anum_pg_index_indcollation: i32 = 16;
pub const Anum_pg_index_indclass: i32 = 17;
pub const Anum_pg_index_indoption: i32 = 18;
pub const Anum_pg_index_indexprs: i32 = 19;
pub const Anum_pg_index_indpred: i32 = 20;
pub const Natts_pg_index: i32 = 20;
pub const INDOPTION_DESC: i32 = 1;
pub const INDOPTION_NULLS_FIRST: i32 = 2;
pub const PublicationRelationId: i32 = 6104;
pub const Anum_pg_publication_oid: i32 = 1;
pub const Anum_pg_publication_pubname: i32 = 2;
pub const Anum_pg_publication_pubowner: i32 = 3;
pub const Anum_pg_publication_puballtables: i32 = 4;
pub const Anum_pg_publication_pubinsert: i32 = 5;
pub const Anum_pg_publication_pubupdate: i32 = 6;
pub const Anum_pg_publication_pubdelete: i32 = 7;
pub const Anum_pg_publication_pubtruncate: i32 = 8;
pub const Natts_pg_publication: i32 = 8;
pub const ACL_ID_PUBLIC: i32 = 0;
pub const ACL_MODECHG_ADD: i32 = 1;
pub const ACL_MODECHG_DEL: i32 = 2;
pub const ACL_MODECHG_EQL: i32 = 3;
pub const ACL_INSERT_CHR: u8 = 97u8;
pub const ACL_SELECT_CHR: u8 = 114u8;
pub const ACL_UPDATE_CHR: u8 = 119u8;
pub const ACL_DELETE_CHR: u8 = 100u8;
pub const ACL_TRUNCATE_CHR: u8 = 68u8;
pub const ACL_REFERENCES_CHR: u8 = 120u8;
pub const ACL_TRIGGER_CHR: u8 = 116u8;
pub const ACL_EXECUTE_CHR: u8 = 88u8;
pub const ACL_USAGE_CHR: u8 = 85u8;
pub const ACL_CREATE_CHR: u8 = 67u8;
pub const ACL_CREATE_TEMP_CHR: u8 = 84u8;
pub const ACL_CONNECT_CHR: u8 = 99u8;
pub const ACL_ALL_RIGHTS_STR: &'static [u8; 13usize] = b"arwdDxtXUCTc\0";
pub const ACL_ALL_RIGHTS_COLUMN: i32 = 39;
pub const ACL_ALL_RIGHTS_RELATION: i32 = 127;
pub const ACL_ALL_RIGHTS_SEQUENCE: i32 = 262;
pub const ACL_ALL_RIGHTS_DATABASE: i32 = 3584;
pub const ACL_ALL_RIGHTS_FDW: i32 = 256;
pub const ACL_ALL_RIGHTS_FOREIGN_SERVER: i32 = 256;
pub const ACL_ALL_RIGHTS_FUNCTION: i32 = 128;
pub const ACL_ALL_RIGHTS_LANGUAGE: i32 = 256;
pub const ACL_ALL_RIGHTS_LARGEOBJECT: i32 = 6;
pub const ACL_ALL_RIGHTS_SCHEMA: i32 = 768;
pub const ACL_ALL_RIGHTS_TABLESPACE: i32 = 512;
pub const ACL_ALL_RIGHTS_TYPE: i32 = 256;
pub const HEAP_MIN_FILLFACTOR: i32 = 10;
pub const HEAP_DEFAULT_FILLFACTOR: i32 = 100;
pub const DEFAULT_TABLE_ACCESS_METHOD: &'static [u8; 5usize] = b"heap\0";
pub const TABLE_INSERT_SKIP_WAL: i32 = 1;
pub const TABLE_INSERT_SKIP_FSM: i32 = 2;
pub const TABLE_INSERT_FROZEN: i32 = 4;
pub const TABLE_INSERT_NO_LOGICAL: i32 = 8;
pub const TUPLE_LOCK_FLAG_LOCK_UPDATE_IN_PROGRESS: i32 = 1;
pub const TUPLE_LOCK_FLAG_FIND_LAST_VERSION: i32 = 2;
pub const SHAREDINVALCATALOG_ID: i32 = -1;
pub const SHAREDINVALRELCACHE_ID: i32 = -2;
pub const SHAREDINVALSMGR_ID: i32 = -3;
pub const SHAREDINVALRELMAP_ID: i32 = -4;
pub const SHAREDINVALSNAPSHOT_ID: i32 = -5;
pub const INTERVAL_FULL_RANGE: i32 = 32767;
pub const INTERVAL_RANGE_MASK: i32 = 32767;
pub const INTERVAL_FULL_PRECISION: i32 = 65535;
pub const INTERVAL_PRECISION_MASK: i32 = 65535;
pub const DAGO: &'static [u8; 4usize] = b"ago\0";
pub const DCURRENT: &'static [u8; 8usize] = b"current\0";
pub const EPOCH: &'static [u8; 6usize] = b"epoch\0";
pub const INVALID: &'static [u8; 8usize] = b"invalid\0";
pub const EARLY: &'static [u8; 10usize] = b"-infinity\0";
pub const LATE: &'static [u8; 9usize] = b"infinity\0";
pub const NOW: &'static [u8; 4usize] = b"now\0";
pub const TODAY: &'static [u8; 6usize] = b"today\0";
pub const TOMORROW: &'static [u8; 9usize] = b"tomorrow\0";
pub const YESTERDAY: &'static [u8; 10usize] = b"yesterday\0";
pub const ZULU: &'static [u8; 5usize] = b"zulu\0";
pub const DMICROSEC: &'static [u8; 8usize] = b"usecond\0";
pub const DMILLISEC: &'static [u8; 8usize] = b"msecond\0";
pub const DSECOND: &'static [u8; 7usize] = b"second\0";
pub const DMINUTE: &'static [u8; 7usize] = b"minute\0";
pub const DHOUR: &'static [u8; 5usize] = b"hour\0";
pub const DDAY: &'static [u8; 4usize] = b"day\0";
pub const DWEEK: &'static [u8; 5usize] = b"week\0";
pub const DMONTH: &'static [u8; 6usize] = b"month\0";
pub const DQUARTER: &'static [u8; 8usize] = b"quarter\0";
pub const DYEAR: &'static [u8; 5usize] = b"year\0";
pub const DDECADE: &'static [u8; 7usize] = b"decade\0";
pub const DCENTURY: &'static [u8; 8usize] = b"century\0";
pub const DMILLENNIUM: &'static [u8; 11usize] = b"millennium\0";
pub const DA_D: &'static [u8; 3usize] = b"ad\0";
pub const DB_C: &'static [u8; 3usize] = b"bc\0";
pub const DTIMEZONE: &'static [u8; 9usize] = b"timezone\0";
pub const AM: i32 = 0;
pub const PM: i32 = 1;
pub const HR24: i32 = 2;
pub const AD: i32 = 0;
pub const BC: i32 = 1;
pub const RESERV: i32 = 0;
pub const MONTH: i32 = 1;
pub const YEAR: i32 = 2;
pub const DAY: i32 = 3;
pub const JULIAN: i32 = 4;
pub const TZ: i32 = 5;
pub const DTZ: i32 = 6;
pub const DYNTZ: i32 = 7;
pub const IGNORE_DTF: i32 = 8;
pub const AMPM: i32 = 9;
pub const HOUR: i32 = 10;
pub const MINUTE: i32 = 11;
pub const SECOND: i32 = 12;
pub const MILLISECOND: i32 = 13;
pub const MICROSECOND: i32 = 14;
pub const DOY: i32 = 15;
pub const DOW: i32 = 16;
pub const UNITS: i32 = 17;
pub const ADBC: i32 = 18;
pub const AGO: i32 = 19;
pub const ABS_BEFORE: i32 = 20;
pub const ABS_AFTER: i32 = 21;
pub const ISODATE: i32 = 22;
pub const ISOTIME: i32 = 23;
pub const WEEK: i32 = 24;
pub const DECADE: i32 = 25;
pub const CENTURY: i32 = 26;
pub const MILLENNIUM: i32 = 27;
pub const DTZMOD: i32 = 28;
pub const UNKNOWN_FIELD: i32 = 31;
pub const DTK_NUMBER: i32 = 0;
pub const DTK_STRING: i32 = 1;
pub const DTK_DATE: i32 = 2;
pub const DTK_TIME: i32 = 3;
pub const DTK_TZ: i32 = 4;
pub const DTK_AGO: i32 = 5;
pub const DTK_SPECIAL: i32 = 6;
pub const DTK_EARLY: i32 = 9;
pub const DTK_LATE: i32 = 10;
pub const DTK_EPOCH: i32 = 11;
pub const DTK_NOW: i32 = 12;
pub const DTK_YESTERDAY: i32 = 13;
pub const DTK_TODAY: i32 = 14;
pub const DTK_TOMORROW: i32 = 15;
pub const DTK_ZULU: i32 = 16;
pub const DTK_DELTA: i32 = 17;
pub const DTK_SECOND: i32 = 18;
pub const DTK_MINUTE: i32 = 19;
pub const DTK_HOUR: i32 = 20;
pub const DTK_DAY: i32 = 21;
pub const DTK_WEEK: i32 = 22;
pub const DTK_MONTH: i32 = 23;
pub const DTK_QUARTER: i32 = 24;
pub const DTK_YEAR: i32 = 25;
pub const DTK_DECADE: i32 = 26;
pub const DTK_CENTURY: i32 = 27;
pub const DTK_MILLENNIUM: i32 = 28;
pub const DTK_MILLISEC: i32 = 29;
pub const DTK_MICROSEC: i32 = 30;
pub const DTK_JULIAN: i32 = 31;
pub const DTK_DOW: i32 = 32;
pub const DTK_DOY: i32 = 33;
pub const DTK_TZ_HOUR: i32 = 34;
pub const DTK_TZ_MINUTE: i32 = 35;
pub const DTK_ISOYEAR: i32 = 36;
pub const DTK_ISODOW: i32 = 37;
pub const MAXDATELEN: i32 = 128;
pub const MAXDATEFIELDS: i32 = 25;
pub const TOKMAXLEN: i32 = 10;
pub const DTERR_BAD_FORMAT: i32 = -1;
pub const DTERR_FIELD_OVERFLOW: i32 = -2;
pub const DTERR_MD_FIELD_OVERFLOW: i32 = -3;
pub const DTERR_INTERVAL_OVERFLOW: i32 = -4;
pub const DTERR_TZDISP_OVERFLOW: i32 = -5;
pub const GIDSIZE: i32 = 200;
pub const XACT_READ_UNCOMMITTED: i32 = 0;
pub const XACT_READ_COMMITTED: i32 = 1;
pub const XACT_REPEATABLE_READ: i32 = 2;
pub const XACT_SERIALIZABLE: i32 = 3;
pub const XACT_FLAGS_ACCESSEDTEMPNAMESPACE: i32 = 1;
pub const XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK: i32 = 2;
pub const XLOG_XACT_COMMIT: i32 = 0;
pub const XLOG_XACT_PREPARE: i32 = 16;
pub const XLOG_XACT_ABORT: i32 = 32;
pub const XLOG_XACT_COMMIT_PREPARED: i32 = 48;
pub const XLOG_XACT_ABORT_PREPARED: i32 = 64;
pub const XLOG_XACT_ASSIGNMENT: i32 = 80;
pub const XLOG_XACT_OPMASK: i32 = 112;
pub const XLOG_XACT_HAS_INFO: i32 = 128;
pub const XACT_XINFO_HAS_DBINFO: i32 = 1;
pub const XACT_XINFO_HAS_SUBXACTS: i32 = 2;
pub const XACT_XINFO_HAS_RELFILENODES: i32 = 4;
pub const XACT_XINFO_HAS_INVALS: i32 = 8;
pub const XACT_XINFO_HAS_TWOPHASE: i32 = 16;
pub const XACT_XINFO_HAS_ORIGIN: i32 = 32;
pub const XACT_XINFO_HAS_AE_LOCKS: i32 = 64;
pub const XACT_XINFO_HAS_GID: i32 = 128;
pub const XACT_COMPLETION_APPLY_FEEDBACK: i32 = 536870912;
pub const XACT_COMPLETION_UPDATE_RELCACHE_FILE: i32 = 1073741824;
pub const XACT_COMPLETION_FORCE_SYNC_COMMIT: i64 = 2147483648;
pub const DEFAULT_INDEX_TYPE: &'static [u8; 6usize] = b"btree\0";
pub const INDEX_CREATE_IS_PRIMARY: i32 = 1;
pub const INDEX_CREATE_ADD_CONSTRAINT: i32 = 2;
pub const INDEX_CREATE_SKIP_BUILD: i32 = 4;
pub const INDEX_CREATE_CONCURRENT: i32 = 8;
pub const INDEX_CREATE_IF_NOT_EXISTS: i32 = 16;
pub const INDEX_CREATE_PARTITIONED: i32 = 32;
pub const INDEX_CREATE_INVALID: i32 = 64;
pub const INDEX_CONSTR_CREATE_MARK_AS_PRIMARY: i32 = 1;
pub const INDEX_CONSTR_CREATE_DEFERRABLE: i32 = 2;
pub const INDEX_CONSTR_CREATE_INIT_DEFERRED: i32 = 4;
pub const INDEX_CONSTR_CREATE_UPDATE_INDEX: i32 = 8;
pub const INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS: i32 = 16;
pub const REINDEX_REL_PROCESS_TOAST: i32 = 1;
pub const REINDEX_REL_SUPPRESS_INDEX_USE: i32 = 2;
pub const REINDEX_REL_CHECK_CONSTRAINTS: i32 = 4;
pub const REINDEX_REL_FORCE_INDEXES_UNLOGGED: i32 = 8;
pub const REINDEX_REL_FORCE_INDEXES_PERMANENT: i32 = 16;
pub const EnumRelationId: i32 = 3501;
pub const Anum_pg_enum_oid: i32 = 1;
pub const Anum_pg_enum_enumtypid: i32 = 2;
pub const Anum_pg_enum_enumsortorder: i32 = 3;
pub const Anum_pg_enum_enumlabel: i32 = 4;
pub const Natts_pg_enum: i32 = 4;
pub const ProcedureRelationId: i32 = 1255;
pub const ProcedureRelation_Rowtype_Id: i32 = 81;
pub const Anum_pg_proc_oid: i32 = 1;
pub const Anum_pg_proc_proname: i32 = 2;
pub const Anum_pg_proc_pronamespace: i32 = 3;
pub const Anum_pg_proc_proowner: i32 = 4;
pub const Anum_pg_proc_prolang: i32 = 5;
pub const Anum_pg_proc_procost: i32 = 6;
pub const Anum_pg_proc_prorows: i32 = 7;
pub const Anum_pg_proc_provariadic: i32 = 8;
pub const Anum_pg_proc_prosupport: i32 = 9;
pub const Anum_pg_proc_prokind: i32 = 10;
pub const Anum_pg_proc_prosecdef: i32 = 11;
pub const Anum_pg_proc_proleakproof: i32 = 12;
pub const Anum_pg_proc_proisstrict: i32 = 13;
pub const Anum_pg_proc_proretset: i32 = 14;
pub const Anum_pg_proc_provolatile: i32 = 15;
pub const Anum_pg_proc_proparallel: i32 = 16;
pub const Anum_pg_proc_pronargs: i32 = 17;
pub const Anum_pg_proc_pronargdefaults: i32 = 18;
pub const Anum_pg_proc_prorettype: i32 = 19;
pub const Anum_pg_proc_proargtypes: i32 = 20;
pub const Anum_pg_proc_proallargtypes: i32 = 21;
pub const Anum_pg_proc_proargmodes: i32 = 22;
pub const Anum_pg_proc_proargnames: i32 = 23;
pub const Anum_pg_proc_proargdefaults: i32 = 24;
pub const Anum_pg_proc_protrftypes: i32 = 25;
pub const Anum_pg_proc_prosrc: i32 = 26;
pub const Anum_pg_proc_probin: i32 = 27;
pub const Anum_pg_proc_proconfig: i32 = 28;
pub const Anum_pg_proc_proacl: i32 = 29;
pub const Natts_pg_proc: i32 = 29;
pub const PROKIND_FUNCTION: u8 = 102u8;
pub const PROKIND_AGGREGATE: u8 = 97u8;
pub const PROKIND_WINDOW: u8 = 119u8;
pub const PROKIND_PROCEDURE: u8 = 112u8;
pub const PROVOLATILE_IMMUTABLE: u8 = 105u8;
pub const PROVOLATILE_STABLE: u8 = 115u8;
pub const PROVOLATILE_VOLATILE: u8 = 118u8;
pub const PROPARALLEL_SAFE: u8 = 115u8;
pub const PROPARALLEL_RESTRICTED: u8 = 114u8;
pub const PROPARALLEL_UNSAFE: u8 = 117u8;
pub const PROARGMODE_IN: u8 = 105u8;
pub const PROARGMODE_OUT: u8 = 111u8;
pub const PROARGMODE_INOUT: u8 = 98u8;
pub const PROARGMODE_VARIADIC: u8 = 118u8;
pub const PROARGMODE_TABLE: u8 = 116u8;
pub const HEAP_TABLE_AM_HANDLER_OID: i32 = 3;
pub const TypeRelationId: i32 = 1247;
pub const TypeRelation_Rowtype_Id: i32 = 71;
pub const Anum_pg_type_oid: i32 = 1;
pub const Anum_pg_type_typname: i32 = 2;
pub const Anum_pg_type_typnamespace: i32 = 3;
pub const Anum_pg_type_typowner: i32 = 4;
pub const Anum_pg_type_typlen: i32 = 5;
pub const Anum_pg_type_typbyval: i32 = 6;
pub const Anum_pg_type_typtype: i32 = 7;
pub const Anum_pg_type_typcategory: i32 = 8;
pub const Anum_pg_type_typispreferred: i32 = 9;
pub const Anum_pg_type_typisdefined: i32 = 10;
pub const Anum_pg_type_typdelim: i32 = 11;
pub const Anum_pg_type_typrelid: i32 = 12;
pub const Anum_pg_type_typelem: i32 = 13;
pub const Anum_pg_type_typarray: i32 = 14;
pub const Anum_pg_type_typinput: i32 = 15;
pub const Anum_pg_type_typoutput: i32 = 16;
pub const Anum_pg_type_typreceive: i32 = 17;
pub const Anum_pg_type_typsend: i32 = 18;
pub const Anum_pg_type_typmodin: i32 = 19;
pub const Anum_pg_type_typmodout: i32 = 20;
pub const Anum_pg_type_typanalyze: i32 = 21;
pub const Anum_pg_type_typalign: i32 = 22;
pub const Anum_pg_type_typstorage: i32 = 23;
pub const Anum_pg_type_typnotnull: i32 = 24;
pub const Anum_pg_type_typbasetype: i32 = 25;
pub const Anum_pg_type_typtypmod: i32 = 26;
pub const Anum_pg_type_typndims: i32 = 27;
pub const Anum_pg_type_typcollation: i32 = 28;
pub const Anum_pg_type_typdefaultbin: i32 = 29;
pub const Anum_pg_type_typdefault: i32 = 30;
pub const Anum_pg_type_typacl: i32 = 31;
pub const Natts_pg_type: i32 = 31;
pub const TYPTYPE_BASE: u8 = 98u8;
pub const TYPTYPE_COMPOSITE: u8 = 99u8;
pub const TYPTYPE_DOMAIN: u8 = 100u8;
pub const TYPTYPE_ENUM: u8 = 101u8;
pub const TYPTYPE_PSEUDO: u8 = 112u8;
pub const TYPTYPE_RANGE: u8 = 114u8;
pub const TYPCATEGORY_INVALID: u8 = 0u8;
pub const TYPCATEGORY_ARRAY: u8 = 65u8;
pub const TYPCATEGORY_BOOLEAN: u8 = 66u8;
pub const TYPCATEGORY_COMPOSITE: u8 = 67u8;
pub const TYPCATEGORY_DATETIME: u8 = 68u8;
pub const TYPCATEGORY_ENUM: u8 = 69u8;
pub const TYPCATEGORY_GEOMETRIC: u8 = 71u8;
pub const TYPCATEGORY_NETWORK: u8 = 73u8;
pub const TYPCATEGORY_NUMERIC: u8 = 78u8;
pub const TYPCATEGORY_PSEUDOTYPE: u8 = 80u8;
pub const TYPCATEGORY_RANGE: u8 = 82u8;
pub const TYPCATEGORY_STRING: u8 = 83u8;
pub const TYPCATEGORY_TIMESPAN: u8 = 84u8;
pub const TYPCATEGORY_USER: u8 = 85u8;
pub const TYPCATEGORY_BITSTRING: u8 = 86u8;
pub const TYPCATEGORY_UNKNOWN: u8 = 88u8;
pub const BOOLOID: i32 = 16;
pub const BYTEAOID: i32 = 17;
pub const CHAROID: i32 = 18;
pub const NAMEOID: i32 = 19;
pub const INT8OID: i32 = 20;
pub const INT2OID: i32 = 21;
pub const INT2VECTOROID: i32 = 22;
pub const INT4OID: i32 = 23;
pub const REGPROCOID: i32 = 24;
pub const TEXTOID: i32 = 25;
pub const OIDOID: i32 = 26;
pub const TIDOID: i32 = 27;
pub const XIDOID: i32 = 28;
pub const CIDOID: i32 = 29;
pub const OIDVECTOROID: i32 = 30;
pub const JSONOID: i32 = 114;
pub const XMLOID: i32 = 142;
pub const PGNODETREEOID: i32 = 194;
pub const PGNDISTINCTOID: i32 = 3361;
pub const PGDEPENDENCIESOID: i32 = 3402;
pub const PGMCVLISTOID: i32 = 5017;
pub const PGDDLCOMMANDOID: i32 = 32;
pub const POINTOID: i32 = 600;
pub const LSEGOID: i32 = 601;
pub const PATHOID: i32 = 602;
pub const BOXOID: i32 = 603;
pub const POLYGONOID: i32 = 604;
pub const LINEOID: i32 = 628;
pub const FLOAT4OID: i32 = 700;
pub const FLOAT8OID: i32 = 701;
pub const UNKNOWNOID: i32 = 705;
pub const CIRCLEOID: i32 = 718;
pub const CASHOID: i32 = 790;
pub const MACADDROID: i32 = 829;
pub const INETOID: i32 = 869;
pub const CIDROID: i32 = 650;
pub const MACADDR8OID: i32 = 774;
pub const ACLITEMOID: i32 = 1033;
pub const BPCHAROID: i32 = 1042;
pub const VARCHAROID: i32 = 1043;
pub const DATEOID: i32 = 1082;
pub const TIMEOID: i32 = 1083;
pub const TIMESTAMPOID: i32 = 1114;
pub const TIMESTAMPTZOID: i32 = 1184;
pub const INTERVALOID: i32 = 1186;
pub const TIMETZOID: i32 = 1266;
pub const BITOID: i32 = 1560;
pub const VARBITOID: i32 = 1562;
pub const NUMERICOID: i32 = 1700;
pub const REFCURSOROID: i32 = 1790;
pub const REGPROCEDUREOID: i32 = 2202;
pub const REGOPEROID: i32 = 2203;
pub const REGOPERATOROID: i32 = 2204;
pub const REGCLASSOID: i32 = 2205;
pub const REGTYPEOID: i32 = 2206;
pub const REGROLEOID: i32 = 4096;
pub const REGNAMESPACEOID: i32 = 4089;
pub const UUIDOID: i32 = 2950;
pub const LSNOID: i32 = 3220;
pub const TSVECTOROID: i32 = 3614;
pub const GTSVECTOROID: i32 = 3642;
pub const TSQUERYOID: i32 = 3615;
pub const REGCONFIGOID: i32 = 3734;
pub const REGDICTIONARYOID: i32 = 3769;
pub const JSONBOID: i32 = 3802;
pub const JSONPATHOID: i32 = 4072;
pub const TXID_SNAPSHOTOID: i32 = 2970;
pub const INT4RANGEOID: i32 = 3904;
pub const NUMRANGEOID: i32 = 3906;
pub const TSRANGEOID: i32 = 3908;
pub const TSTZRANGEOID: i32 = 3910;
pub const DATERANGEOID: i32 = 3912;
pub const INT8RANGEOID: i32 = 3926;
pub const RECORDOID: i32 = 2249;
pub const RECORDARRAYOID: i32 = 2287;
pub const CSTRINGOID: i32 = 2275;
pub const ANYOID: i32 = 2276;
pub const ANYARRAYOID: i32 = 2277;
pub const VOIDOID: i32 = 2278;
pub const TRIGGEROID: i32 = 2279;
pub const EVTTRIGGEROID: i32 = 3838;
pub const LANGUAGE_HANDLEROID: i32 = 2280;
pub const INTERNALOID: i32 = 2281;
pub const OPAQUEOID: i32 = 2282;
pub const ANYELEMENTOID: i32 = 2283;
pub const ANYNONARRAYOID: i32 = 2776;
pub const ANYENUMOID: i32 = 3500;
pub const FDW_HANDLEROID: i32 = 3115;
pub const INDEX_AM_HANDLEROID: i32 = 325;
pub const TSM_HANDLEROID: i32 = 3310;
pub const TABLE_AM_HANDLEROID: i32 = 269;
pub const ANYRANGEOID: i32 = 3831;
pub const BOOLARRAYOID: i32 = 1000;
pub const BYTEAARRAYOID: i32 = 1001;
pub const CHARARRAYOID: i32 = 1002;
pub const NAMEARRAYOID: i32 = 1003;
pub const INT8ARRAYOID: i32 = 1016;
pub const INT2ARRAYOID: i32 = 1005;
pub const INT2VECTORARRAYOID: i32 = 1006;
pub const INT4ARRAYOID: i32 = 1007;
pub const REGPROCARRAYOID: i32 = 1008;
pub const TEXTARRAYOID: i32 = 1009;
pub const OIDARRAYOID: i32 = 1028;
pub const TIDARRAYOID: i32 = 1010;
pub const XIDARRAYOID: i32 = 1011;
pub const CIDARRAYOID: i32 = 1012;
pub const OIDVECTORARRAYOID: i32 = 1013;
pub const JSONARRAYOID: i32 = 199;
pub const XMLARRAYOID: i32 = 143;
pub const POINTARRAYOID: i32 = 1017;
pub const LSEGARRAYOID: i32 = 1018;
pub const PATHARRAYOID: i32 = 1019;
pub const BOXARRAYOID: i32 = 1020;
pub const POLYGONARRAYOID: i32 = 1027;
pub const LINEARRAYOID: i32 = 629;
pub const FLOAT4ARRAYOID: i32 = 1021;
pub const FLOAT8ARRAYOID: i32 = 1022;
pub const CIRCLEARRAYOID: i32 = 719;
pub const MONEYARRAYOID: i32 = 791;
pub const MACADDRARRAYOID: i32 = 1040;
pub const INETARRAYOID: i32 = 1041;
pub const CIDRARRAYOID: i32 = 651;
pub const MACADDR8ARRAYOID: i32 = 775;
pub const ACLITEMARRAYOID: i32 = 1034;
pub const BPCHARARRAYOID: i32 = 1014;
pub const VARCHARARRAYOID: i32 = 1015;
pub const DATEARRAYOID: i32 = 1182;
pub const TIMEARRAYOID: i32 = 1183;
pub const TIMESTAMPARRAYOID: i32 = 1115;
pub const TIMESTAMPTZARRAYOID: i32 = 1185;
pub const INTERVALARRAYOID: i32 = 1187;
pub const TIMETZARRAYOID: i32 = 1270;
pub const BITARRAYOID: i32 = 1561;
pub const VARBITARRAYOID: i32 = 1563;
pub const NUMERICARRAYOID: i32 = 1231;
pub const REFCURSORARRAYOID: i32 = 2201;
pub const REGPROCEDUREARRAYOID: i32 = 2207;
pub const REGOPERARRAYOID: i32 = 2208;
pub const REGOPERATORARRAYOID: i32 = 2209;
pub const REGCLASSARRAYOID: i32 = 2210;
pub const REGTYPEARRAYOID: i32 = 2211;
pub const REGROLEARRAYOID: i32 = 4097;
pub const REGNAMESPACEARRAYOID: i32 = 4090;
pub const UUIDARRAYOID: i32 = 2951;
pub const PG_LSNARRAYOID: i32 = 3221;
pub const TSVECTORARRAYOID: i32 = 3643;
pub const GTSVECTORARRAYOID: i32 = 3644;
pub const TSQUERYARRAYOID: i32 = 3645;
pub const REGCONFIGARRAYOID: i32 = 3735;
pub const REGDICTIONARYARRAYOID: i32 = 3770;
pub const JSONBARRAYOID: i32 = 3807;
pub const JSONPATHARRAYOID: i32 = 4073;
pub const TXID_SNAPSHOTARRAYOID: i32 = 2949;
pub const INT4RANGEARRAYOID: i32 = 3905;
pub const NUMRANGEARRAYOID: i32 = 3907;
pub const TSRANGEARRAYOID: i32 = 3909;
pub const TSTZRANGEARRAYOID: i32 = 3911;
pub const DATERANGEARRAYOID: i32 = 3913;
pub const INT8RANGEARRAYOID: i32 = 3927;
pub const CSTRINGARRAYOID: i32 = 1263;
pub const PERFORM_DELETION_INTERNAL: i32 = 1;
pub const PERFORM_DELETION_CONCURRENTLY: i32 = 2;
pub const PERFORM_DELETION_QUIETLY: i32 = 4;
pub const PERFORM_DELETION_SKIP_ORIGINAL: i32 = 8;
pub const PERFORM_DELETION_SKIP_EXTENSIONS: i32 = 16;
pub const PERFORM_DELETION_CONCURRENT_LOCK: i32 = 32;
pub const EventTriggerRelationId: i32 = 3466;
pub const Anum_pg_event_trigger_oid: i32 = 1;
pub const Anum_pg_event_trigger_evtname: i32 = 2;
pub const Anum_pg_event_trigger_evtevent: i32 = 3;
pub const Anum_pg_event_trigger_evtowner: i32 = 4;
pub const Anum_pg_event_trigger_evtfoid: i32 = 5;
pub const Anum_pg_event_trigger_evtenabled: i32 = 6;
pub const Anum_pg_event_trigger_evttags: i32 = 7;
pub const Natts_pg_event_trigger: i32 = 7;
pub const AT_REWRITE_ALTER_PERSISTENCE: i32 = 1;
pub const AT_REWRITE_DEFAULT_VAL: i32 = 2;
pub const AT_REWRITE_COLUMN_REWRITE: i32 = 4;
pub const TriggerRelationId: i32 = 2620;
pub const Anum_pg_trigger_oid: i32 = 1;
pub const Anum_pg_trigger_tgrelid: i32 = 2;
pub const Anum_pg_trigger_tgname: i32 = 3;
pub const Anum_pg_trigger_tgfoid: i32 = 4;
pub const Anum_pg_trigger_tgtype: i32 = 5;
pub const Anum_pg_trigger_tgenabled: i32 = 6;
pub const Anum_pg_trigger_tgisinternal: i32 = 7;
pub const Anum_pg_trigger_tgconstrrelid: i32 = 8;
pub const Anum_pg_trigger_tgconstrindid: i32 = 9;
pub const Anum_pg_trigger_tgconstraint: i32 = 10;
pub const Anum_pg_trigger_tgdeferrable: i32 = 11;
pub const Anum_pg_trigger_tginitdeferred: i32 = 12;
pub const Anum_pg_trigger_tgnargs: i32 = 13;
pub const Anum_pg_trigger_tgattr: i32 = 14;
pub const Anum_pg_trigger_tgargs: i32 = 15;
pub const Anum_pg_trigger_tgqual: i32 = 16;
pub const Anum_pg_trigger_tgoldtable: i32 = 17;
pub const Anum_pg_trigger_tgnewtable: i32 = 18;
pub const Natts_pg_trigger: i32 = 18;
pub const TRIGGER_TYPE_ROW: i32 = 1;
pub const TRIGGER_TYPE_BEFORE: i32 = 2;
pub const TRIGGER_TYPE_INSERT: i32 = 4;
pub const TRIGGER_TYPE_DELETE: i32 = 8;
pub const TRIGGER_TYPE_UPDATE: i32 = 16;
pub const TRIGGER_TYPE_TRUNCATE: i32 = 32;
pub const TRIGGER_TYPE_INSTEAD: i32 = 64;
pub const TRIGGER_TYPE_LEVEL_MASK: i32 = 1;
pub const TRIGGER_TYPE_STATEMENT: i32 = 0;
pub const TRIGGER_TYPE_TIMING_MASK: i32 = 66;
pub const TRIGGER_TYPE_AFTER: i32 = 0;
pub const TRIGGER_TYPE_EVENT_MASK: i32 = 60;
pub const TRIGGER_EVENT_INSERT: i32 = 0;
pub const TRIGGER_EVENT_DELETE: i32 = 1;
pub const TRIGGER_EVENT_UPDATE: i32 = 2;
pub const TRIGGER_EVENT_TRUNCATE: i32 = 3;
pub const TRIGGER_EVENT_OPMASK: i32 = 3;
pub const TRIGGER_EVENT_ROW: i32 = 4;
pub const TRIGGER_EVENT_BEFORE: i32 = 8;
pub const TRIGGER_EVENT_AFTER: i32 = 0;
pub const TRIGGER_EVENT_INSTEAD: i32 = 16;
pub const TRIGGER_EVENT_TIMINGMASK: i32 = 24;
pub const AFTER_TRIGGER_DEFERRABLE: i32 = 32;
pub const AFTER_TRIGGER_INITDEFERRED: i32 = 64;
pub const SESSION_REPLICATION_ROLE_ORIGIN: i32 = 0;
pub const SESSION_REPLICATION_ROLE_REPLICA: i32 = 1;
pub const SESSION_REPLICATION_ROLE_LOCAL: i32 = 2;
pub const TRIGGER_FIRES_ON_ORIGIN: u8 = 79u8;
pub const TRIGGER_FIRES_ALWAYS: u8 = 65u8;
pub const TRIGGER_FIRES_ON_REPLICA: u8 = 82u8;
pub const TRIGGER_DISABLED: u8 = 68u8;
pub const RI_TRIGGER_PK: i32 = 1;
pub const RI_TRIGGER_FK: i32 = 2;
pub const RI_TRIGGER_NONE: i32 = 0;
pub const CACHEDPLANSOURCE_MAGIC: i32 = 195726186;
pub const CACHEDPLAN_MAGIC: i32 = 953717834;
pub const CACHEDEXPR_MAGIC: i32 = 838275847;
pub const SPI_ERROR_CONNECT: i32 = -1;
pub const SPI_ERROR_COPY: i32 = -2;
pub const SPI_ERROR_OPUNKNOWN: i32 = -3;
pub const SPI_ERROR_UNCONNECTED: i32 = -4;
pub const SPI_ERROR_CURSOR: i32 = -5;
pub const SPI_ERROR_ARGUMENT: i32 = -6;
pub const SPI_ERROR_PARAM: i32 = -7;
pub const SPI_ERROR_TRANSACTION: i32 = -8;
pub const SPI_ERROR_NOATTRIBUTE: i32 = -9;
pub const SPI_ERROR_NOOUTFUNC: i32 = -10;
pub const SPI_ERROR_TYPUNKNOWN: i32 = -11;
pub const SPI_ERROR_REL_DUPLICATE: i32 = -12;
pub const SPI_ERROR_REL_NOT_FOUND: i32 = -13;
pub const SPI_OK_CONNECT: i32 = 1;
pub const SPI_OK_FINISH: i32 = 2;
pub const SPI_OK_FETCH: i32 = 3;
pub const SPI_OK_UTILITY: i32 = 4;
pub const SPI_OK_SELECT: i32 = 5;
pub const SPI_OK_SELINTO: i32 = 6;
pub const SPI_OK_INSERT: i32 = 7;
pub const SPI_OK_DELETE: i32 = 8;
pub const SPI_OK_UPDATE: i32 = 9;
pub const SPI_OK_CURSOR: i32 = 10;
pub const SPI_OK_INSERT_RETURNING: i32 = 11;
pub const SPI_OK_DELETE_RETURNING: i32 = 12;
pub const SPI_OK_UPDATE_RETURNING: i32 = 13;
pub const SPI_OK_REWRITTEN: i32 = 14;
pub const SPI_OK_REL_REGISTER: i32 = 15;
pub const SPI_OK_REL_UNREGISTER: i32 = 16;
pub const SPI_OK_TD_REGISTER: i32 = 17;
pub const SPI_OPT_NONATOMIC: i32 = 1;
pub const BGWORKER_SHMEM_ACCESS: i32 = 1;
pub const BGWORKER_BACKEND_DATABASE_CONNECTION: i32 = 2;
pub const BGWORKER_CLASS_PARALLEL: i32 = 16;
pub const BGW_DEFAULT_RESTART_INTERVAL: i32 = 60;
pub const BGW_NEVER_RESTART: i32 = -1;
pub const BGW_MAXLEN: i32 = 96;
pub const BGW_EXTRALEN: i32 = 128;
pub const BGWORKER_BYPASS_ALLOWCONN: i32 = 1;
pub const HAVE_PLANNERINFO_TYPEDEF: i32 = 1;
pub const HAVE_INDEXOPTINFO_TYPEDEF: i32 = 1;
pub const HAVE_SPECIALJOININFO_TYPEDEF: i32 = 1;
pub const GROUPING_CAN_USE_SORT: i32 = 1;
pub const GROUPING_CAN_USE_HASH: i32 = 2;
pub const GROUPING_CAN_PARTIAL_AGG: i32 = 4;
pub const FSV_MISSING_OK: i32 = 1;
pub const FDW_MISSING_OK: i32 = 1;
pub const EXTNODENAME_MAX_LEN: i32 = 64;
pub const CUSTOMPATH_SUPPORT_BACKWARD_SCAN: i32 = 1;
pub const CUSTOMPATH_SUPPORT_MARK_RESTORE: i32 = 2;
pub const QTW_IGNORE_RT_SUBQUERIES: i32 = 1;
pub const QTW_IGNORE_CTE_SUBQUERIES: i32 = 2;
pub const QTW_IGNORE_RC_SUBQUERIES: i32 = 3;
pub const QTW_IGNORE_JOINALIASES: i32 = 4;
pub const QTW_IGNORE_RANGE_TABLE: i32 = 8;
pub const QTW_EXAMINE_RTES_BEFORE: i32 = 16;
pub const QTW_EXAMINE_RTES_AFTER: i32 = 32;
pub const QTW_DONT_COPY_QUERY: i32 = 64;
pub const QTW_EXAMINE_SORTGROUP: i32 = 128;
pub const DEFAULT_SEQ_PAGE_COST: f64 = 1.0;
pub const DEFAULT_RANDOM_PAGE_COST: f64 = 4.0;
pub const DEFAULT_CPU_TUPLE_COST: f64 = 0.01;
pub const DEFAULT_CPU_INDEX_TUPLE_COST: f64 = 0.005;
pub const DEFAULT_CPU_OPERATOR_COST: f64 = 0.0025;
pub const DEFAULT_PARALLEL_TUPLE_COST: f64 = 0.1;
pub const DEFAULT_PARALLEL_SETUP_COST: f64 = 1000.0;
pub const DEFAULT_EFFECTIVE_CACHE_SIZE: i32 = 524288;
pub const PVC_INCLUDE_AGGREGATES: i32 = 1;
pub const PVC_RECURSE_AGGREGATES: i32 = 2;
pub const PVC_INCLUDE_WINDOWFUNCS: i32 = 4;
pub const PVC_RECURSE_WINDOWFUNCS: i32 = 8;
pub const PVC_INCLUDE_PLACEHOLDERS: i32 = 16;
pub const PVC_RECURSE_PLACEHOLDERS: i32 = 32;
pub const XLOG_STANDBY_LOCK: i32 = 0;
pub const XLOG_RUNNING_XACTS: i32 = 16;
pub const XLOG_INVALIDATIONS: i32 = 32;
pub const PROCARRAY_VACUUM_FLAG: i32 = 2;
pub const PROCARRAY_ANALYZE_FLAG: i32 = 4;
pub const PROCARRAY_LOGICAL_DECODING_FLAG: i32 = 16;
pub const PROCARRAY_SLOTS_XMIN: i32 = 32;
pub const PROCARRAY_PROC_FLAGS_MASK: i32 = 22;
pub const PROCARRAY_FLAGS_DEFAULT: i32 = 16;
pub const PROCARRAY_FLAGS_VACUUM: i32 = 18;
pub const PROCARRAY_FLAGS_ANALYZE: i32 = 20;
pub const PROCARRAY_FLAGS_VACUUM_ANALYZE: i32 = 22;
pub const STACK_DEPTH_SLOP: i32 = 524288;
pub const FORMAT_TYPE_TYPEMOD_GIVEN: i32 = 1;
pub const FORMAT_TYPE_ALLOW_INVALID: i32 = 2;
pub const FORMAT_TYPE_FORCE_QUALIFY: i32 = 4;
pub const MAX_TIME_PRECISION: i32 = 6;
pub const NUMERIC_MAX_PRECISION: i32 = 1000;
pub const NUMERIC_MAX_DISPLAY_SCALE: i32 = 1000;
pub const NUMERIC_MIN_DISPLAY_SCALE: i32 = 0;
pub const NUMERIC_MAX_RESULT_SCALE: i32 = 2000;
pub const NUMERIC_MIN_SIG_DIGITS: i32 = 16;
pub const JsonbContainsStrategyNumber: i32 = 7;
pub const JsonbExistsStrategyNumber: i32 = 9;
pub const JsonbExistsAnyStrategyNumber: i32 = 10;
pub const JsonbExistsAllStrategyNumber: i32 = 11;
pub const JsonbJsonpathExistsStrategyNumber: i32 = 15;
pub const JsonbJsonpathPredicateStrategyNumber: i32 = 16;
pub const JGINFLAG_KEY: i32 = 1;
pub const JGINFLAG_NULL: i32 = 2;
pub const JGINFLAG_BOOL: i32 = 3;
pub const JGINFLAG_NUM: i32 = 4;
pub const JGINFLAG_STR: i32 = 5;
pub const JGINFLAG_HASHED: i32 = 16;
pub const JGIN_MAXLENGTH: i32 = 125;
pub const JENTRY_OFFLENMASK: i32 = 268435455;
pub const JENTRY_TYPEMASK: i32 = 1879048192;
pub const JENTRY_HAS_OFF: i64 = 2147483648;
pub const JENTRY_ISSTRING: i32 = 0;
pub const JENTRY_ISNUMERIC: i32 = 268435456;
pub const JENTRY_ISBOOL_FALSE: i32 = 536870912;
pub const JENTRY_ISBOOL_TRUE: i32 = 805306368;
pub const JENTRY_ISNULL: i32 = 1073741824;
pub const JENTRY_ISCONTAINER: i32 = 1342177280;
pub const JB_OFFSET_STRIDE: i32 = 32;
pub const JB_CMASK: i32 = 268435455;
pub const JB_FSCALAR: i32 = 268435456;
pub const JB_FOBJECT: i32 = 536870912;
pub const JB_FARRAY: i32 = 1073741824;
pub const ATTSTATSSLOT_VALUES: i32 = 1;
pub const ATTSTATSSLOT_NUMBERS: i32 = 2;
pub const DEFAULT_EQ_SEL: f64 = 0.005;
pub const DEFAULT_INEQ_SEL: f64 = 0.3333333333333333;
pub const DEFAULT_RANGE_INEQ_SEL: f64 = 0.005;
pub const DEFAULT_MATCH_SEL: f64 = 0.005;
pub const DEFAULT_NUM_DISTINCT: i32 = 200;
pub const DEFAULT_UNK_SEL: f64 = 0.005;
pub const DEFAULT_NOT_UNK_SEL: f64 = 0.995;
pub const OLD_SNAPSHOT_PADDING_ENTRIES: i32 = 10;
pub const TYPECACHE_EQ_OPR: i32 = 1;
pub const TYPECACHE_LT_OPR: i32 = 2;
pub const TYPECACHE_GT_OPR: i32 = 4;
pub const TYPECACHE_CMP_PROC: i32 = 8;
pub const TYPECACHE_HASH_PROC: i32 = 16;
pub const TYPECACHE_EQ_OPR_FINFO: i32 = 32;
pub const TYPECACHE_CMP_PROC_FINFO: i32 = 64;
pub const TYPECACHE_HASH_PROC_FINFO: i32 = 128;
pub const TYPECACHE_TUPDESC: i32 = 256;
pub const TYPECACHE_BTREE_OPFAMILY: i32 = 512;
pub const TYPECACHE_HASH_OPFAMILY: i32 = 1024;
pub const TYPECACHE_RANGE_INFO: i32 = 2048;
pub const TYPECACHE_DOMAIN_BASE_INFO: i32 = 4096;
pub const TYPECACHE_DOMAIN_CONSTR_INFO: i32 = 8192;
pub const TYPECACHE_HASH_EXTENDED_PROC: i32 = 16384;
pub const TYPECACHE_HASH_EXTENDED_PROC_FINFO: i32 = 32768;
pub type Oid = ::std::os::raw::c_uint;
pub type pg_int64 = ::std::os::raw::c_long;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: PgPtr<::std::os::raw::c_void>)>,
    pub __arg: PgPtr<::std::os::raw::c_void>,
    pub __next: PgPtr<__darwin_pthread_handler_rec>,
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[repr(C)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[repr(C)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[repr(C)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: PgPtr<__darwin_pthread_handler_rec>,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = PgPtr<_opaque_pthread_t>;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type va_list = __darwin_va_list;
#[pg_guard]
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: ::std::os::raw::c_int,
        arg4: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn renamex_np(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: ::std::os::raw::c_int,
        arg4: PgPtr<::std::os::raw::c_char>,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
pub struct __sbuf {
    pub _base: PgPtr<::std::os::raw::c_uchar>,
    pub _size: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct __sFILE {
    pub _p: PgPtr<::std::os::raw::c_uchar>,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: PgPtr<::std::os::raw::c_void>,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: PgPtr<::std::os::raw::c_void>) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: PgPtr<::std::os::raw::c_void>,
            arg2: PgPtr<::std::os::raw::c_char>,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: PgPtr<::std::os::raw::c_void>,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: PgPtr<::std::os::raw::c_void>,
            arg2: PgPtr<::std::os::raw::c_char>,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: PgPtr<__sFILEX>,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
pub type FILE = __sFILE;
#[pg_guard]
extern "C" {
    pub static mut __stdinp: PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub static mut __stdoutp: PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub static mut __stderrp: PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub fn clearerr(arg1: PgPtr<FILE>);
}
#[pg_guard]
extern "C" {
    pub fn fclose(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn feof(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ferror(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn fflush(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn fgetc(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn fgetpos(arg1: PgPtr<FILE>, arg2: PgPtr<fpos_t>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn fgets(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: ::std::os::raw::c_int,
        arg3: PgPtr<FILE>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn fopen(
        __filename: PgPtr<::std::os::raw::c_char>,
        __mode: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub fn fprintf(
        arg1: PgPtr<FILE>,
        arg2: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn fputs(arg1: PgPtr<::std::os::raw::c_char>, arg2: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn fread(
        __ptr: PgPtr<::std::os::raw::c_void>,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: PgPtr<FILE>,
    ) -> ::std::os::raw::c_ulong;
}
#[pg_guard]
extern "C" {
    pub fn freopen(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: PgPtr<FILE>,
    ) -> PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub fn fscanf(
        arg1: PgPtr<FILE>,
        arg2: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn fseek(
        arg1: PgPtr<FILE>,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn fsetpos(arg1: PgPtr<FILE>, arg2: PgPtr<fpos_t>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ftell(arg1: PgPtr<FILE>) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn fwrite(
        __ptr: PgPtr<::std::os::raw::c_void>,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: PgPtr<FILE>,
    ) -> ::std::os::raw::c_ulong;
}
#[pg_guard]
extern "C" {
    pub fn getc(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn gets(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn perror(arg1: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn printf(arg1: PgPtr<::std::os::raw::c_char>, ...) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn puts(arg1: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn remove(arg1: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn rename(
        __old: PgPtr<::std::os::raw::c_char>,
        __new: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn rewind(arg1: PgPtr<FILE>);
}
#[pg_guard]
extern "C" {
    pub fn scanf(arg1: PgPtr<::std::os::raw::c_char>, ...) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn setbuf(arg1: PgPtr<FILE>, arg2: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn setvbuf(
        arg1: PgPtr<FILE>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sprintf(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sscanf(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn tmpfile() -> PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub fn tmpnam(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn vfprintf(
        arg1: PgPtr<FILE>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn vprintf(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn vsprintf(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ctermid(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: PgPtr<::std::os::raw::c_char>) -> PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub fn fileno(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pclose(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn popen(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub fn __srget(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn __svfscanf(
        arg1: PgPtr<FILE>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn flockfile(arg1: PgPtr<FILE>);
}
#[pg_guard]
extern "C" {
    pub fn ftrylockfile(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn funlockfile(arg1: PgPtr<FILE>);
}
#[pg_guard]
extern "C" {
    pub fn getc_unlocked(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getw(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn tempnam(
        __dir: PgPtr<::std::os::raw::c_char>,
        __prefix: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
pub type off_t = __darwin_off_t;
#[pg_guard]
extern "C" {
    pub fn fseeko(
        __stream: PgPtr<FILE>,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ftello(__stream: PgPtr<FILE>) -> off_t;
}
#[pg_guard]
extern "C" {
    pub fn snprintf(
        __str: PgPtr<::std::os::raw::c_char>,
        __size: ::std::os::raw::c_ulong,
        __format: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn vfscanf(
        __stream: PgPtr<FILE>,
        __format: PgPtr<::std::os::raw::c_char>,
        arg1: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn vscanf(
        __format: PgPtr<::std::os::raw::c_char>,
        arg1: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn vsnprintf(
        __str: PgPtr<::std::os::raw::c_char>,
        __size: ::std::os::raw::c_ulong,
        __format: PgPtr<::std::os::raw::c_char>,
        arg1: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn vsscanf(
        __str: PgPtr<::std::os::raw::c_char>,
        __format: PgPtr<::std::os::raw::c_char>,
        arg1: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getdelim(
        __linep: PgPtr<PgPtr<::std::os::raw::c_char>>,
        __linecapp: PgPtr<usize>,
        __delimiter: ::std::os::raw::c_int,
        __stream: PgPtr<FILE>,
    ) -> isize;
}
#[pg_guard]
extern "C" {
    pub fn getline(
        __linep: PgPtr<PgPtr<::std::os::raw::c_char>>,
        __linecapp: PgPtr<usize>,
        __stream: PgPtr<FILE>,
    ) -> isize;
}
#[pg_guard]
extern "C" {
    pub fn fmemopen(
        __buf: PgPtr<::std::os::raw::c_void>,
        __size: usize,
        __mode: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub fn open_memstream(
        __bufp: PgPtr<PgPtr<::std::os::raw::c_char>>,
        __sizep: PgPtr<usize>,
    ) -> PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
#[pg_guard]
extern "C" {
    pub fn asprintf(
        arg1: PgPtr<PgPtr<::std::os::raw::c_char>>,
        arg2: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ctermid_r(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn fgetln(arg1: PgPtr<FILE>, arg2: PgPtr<usize>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn fmtcheck(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn fpurge(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn setbuffer(
        arg1: PgPtr<FILE>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn setlinebuf(arg1: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn vasprintf(
        arg1: PgPtr<PgPtr<::std::os::raw::c_char>>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn zopen(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: ::std::os::raw::c_int,
    ) -> PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub fn funopen(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: PgPtr<::std::os::raw::c_void>,
                arg2: PgPtr<::std::os::raw::c_char>,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: PgPtr<::std::os::raw::c_void>,
                arg2: PgPtr<::std::os::raw::c_char>,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: PgPtr<::std::os::raw::c_void>,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: PgPtr<::std::os::raw::c_void>) -> ::std::os::raw::c_int,
        >,
    ) -> PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub fn __sprintf_chk(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn __snprintf_chk(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn __vsprintf_chk(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: PgPtr<::std::os::raw::c_char>,
        arg5: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: PgPtr<::std::os::raw::c_char>,
        arg6: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum idtype_t {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2,
}
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[repr(C)]
#[repr(align(2))]
pub struct __darwin_fp_control {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __pc: ::std::os::raw::c_ushort,
        __rc: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let __pc: u16 = unsafe { ::std::mem::transmute(__pc) };
            __pc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let __rc: u16 = unsafe { ::std::mem::transmute(__rc) };
            __rc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[repr(align(2))]
pub struct __darwin_fp_status {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __stkflt: ::std::os::raw::c_ushort,
        __errsumm: ::std::os::raw::c_ushort,
        __c0: ::std::os::raw::c_ushort,
        __c1: ::std::os::raw::c_ushort,
        __c2: ::std::os::raw::c_ushort,
        __tos: ::std::os::raw::c_ushort,
        __c3: ::std::os::raw::c_ushort,
        __busy: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let __stkflt: u16 = unsafe { ::std::mem::transmute(__stkflt) };
            __stkflt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __errsumm: u16 = unsafe { ::std::mem::transmute(__errsumm) };
            __errsumm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let __c0: u16 = unsafe { ::std::mem::transmute(__c0) };
            __c0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let __c1: u16 = unsafe { ::std::mem::transmute(__c1) };
            __c1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let __c2: u16 = unsafe { ::std::mem::transmute(__c2) };
            __c2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let __tos: u16 = unsafe { ::std::mem::transmute(__tos) };
            __tos as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let __c3: u16 = unsafe { ::std::mem::transmute(__c3) };
            __c3 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let __busy: u16 = unsafe { ::std::mem::transmute(__busy) };
            __busy as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[repr(C)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[repr(C)]
pub struct __darwin_ymm_reg {
    pub __ymm_reg: [::std::os::raw::c_char; 32usize],
}
#[repr(C)]
pub struct __darwin_zmm_reg {
    pub __zmm_reg: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
pub struct __darwin_opmask_reg {
    pub __opmask_reg: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[repr(C)]
pub struct __darwin_i386_avx512_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
}
#[repr(C)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[repr(C)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[repr(C)]
pub struct __x86_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[repr(C)]
pub struct __darwin_x86_thread_full_state64 {
    pub __ss64: __darwin_x86_thread_state64,
    pub __ds: __uint64_t,
    pub __es: __uint64_t,
    pub __ss: __uint64_t,
    pub __gsbase: __uint64_t,
}
#[repr(C)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[repr(C)]
pub struct __darwin_x86_avx512_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
    pub __fpu_zmmh8: __darwin_ymm_reg,
    pub __fpu_zmmh9: __darwin_ymm_reg,
    pub __fpu_zmmh10: __darwin_ymm_reg,
    pub __fpu_zmmh11: __darwin_ymm_reg,
    pub __fpu_zmmh12: __darwin_ymm_reg,
    pub __fpu_zmmh13: __darwin_ymm_reg,
    pub __fpu_zmmh14: __darwin_ymm_reg,
    pub __fpu_zmmh15: __darwin_ymm_reg,
    pub __fpu_zmm16: __darwin_zmm_reg,
    pub __fpu_zmm17: __darwin_zmm_reg,
    pub __fpu_zmm18: __darwin_zmm_reg,
    pub __fpu_zmm19: __darwin_zmm_reg,
    pub __fpu_zmm20: __darwin_zmm_reg,
    pub __fpu_zmm21: __darwin_zmm_reg,
    pub __fpu_zmm22: __darwin_zmm_reg,
    pub __fpu_zmm23: __darwin_zmm_reg,
    pub __fpu_zmm24: __darwin_zmm_reg,
    pub __fpu_zmm25: __darwin_zmm_reg,
    pub __fpu_zmm26: __darwin_zmm_reg,
    pub __fpu_zmm27: __darwin_zmm_reg,
    pub __fpu_zmm28: __darwin_zmm_reg,
    pub __fpu_zmm29: __darwin_zmm_reg,
    pub __fpu_zmm30: __darwin_zmm_reg,
    pub __fpu_zmm31: __darwin_zmm_reg,
}
#[repr(C)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[repr(C)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[repr(C)]
pub struct __darwin_x86_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[repr(C)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[repr(C)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[repr(C)]
pub struct __darwin_mcontext_avx512_32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx512_state,
}
#[repr(C)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[repr(C)]
pub struct __darwin_mcontext64_full {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_full_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[repr(C)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[repr(C)]
pub struct __darwin_mcontext_avx64_full {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_full_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[repr(C)]
pub struct __darwin_mcontext_avx512_64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[repr(C)]
pub struct __darwin_mcontext_avx512_64_full {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_full_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
pub type mcontext_t = PgPtr<__darwin_mcontext64>;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
pub struct __darwin_sigaltstack {
    pub ss_sp: PgPtr<::std::os::raw::c_void>,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: PgPtr<__darwin_ucontext>,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: PgPtr<__darwin_mcontext64>,
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
pub struct sigval {
    pub sival_int: __BindgenUnionField<::std::os::raw::c_int>,
    pub sival_ptr: __BindgenUnionField<PgPtr<::std::os::raw::c_void>>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: PgPtr<pthread_attr_t>,
}
#[repr(C)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: PgPtr<::std::os::raw::c_void>,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
pub type siginfo_t = __siginfo;
#[repr(C)]
pub struct __sigaction_u {
    pub __sa_handler: __BindgenUnionField<
        ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    >,
    pub __sa_sigaction: __BindgenUnionField<
        ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: PgPtr<__siginfo>,
                arg3: PgPtr<::std::os::raw::c_void>,
            ),
        >,
    >,
    pub bindgen_union_field: u64,
}
#[repr(C)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: PgPtr<::std::os::raw::c_void>,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: PgPtr<siginfo_t>,
            arg5: PgPtr<::std::os::raw::c_void>,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct sigstack {
    pub ss_sp: PgPtr<::std::os::raw::c_char>,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[pg_guard]
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
pub type rlim_t = __uint64_t;
#[repr(C)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
pub type rusage_info_t = PgPtr<::std::os::raw::c_void>;
#[repr(C)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[repr(C)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[repr(C)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[repr(C)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[repr(C)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
pub type rusage_info_current = rusage_info_v4;
#[repr(C)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[repr(C)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[pg_guard]
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: PgPtr<rlimit>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: PgPtr<rusage>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: PgPtr<rlimit>) -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct wait {
    pub w_status: __BindgenUnionField<::std::os::raw::c_int>,
    pub w_T: __BindgenUnionField<wait__bindgen_ty_1>,
    pub w_S: __BindgenUnionField<wait__bindgen_ty_2>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[pg_guard]
extern "C" {
    pub fn wait(arg1: PgPtr<::std::os::raw::c_int>) -> pid_t;
}
#[pg_guard]
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: PgPtr<::std::os::raw::c_int>,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
#[pg_guard]
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: PgPtr<siginfo_t>,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn wait3(
        arg1: PgPtr<::std::os::raw::c_int>,
        arg2: ::std::os::raw::c_int,
        arg3: PgPtr<rusage>,
    ) -> pid_t;
}
#[pg_guard]
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: PgPtr<::std::os::raw::c_int>,
        arg3: ::std::os::raw::c_int,
        arg4: PgPtr<rusage>,
    ) -> pid_t;
}
#[pg_guard]
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> PgPtr<::std::os::raw::c_void>;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[pg_guard]
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn free(arg1: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn realloc(
        __ptr: PgPtr<::std::os::raw::c_void>,
        __size: ::std::os::raw::c_ulong,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn valloc(arg1: usize) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn posix_memalign(
        __memptr: PgPtr<PgPtr<::std::os::raw::c_void>>,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn abort();
}
#[pg_guard]
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn atof(arg1: PgPtr<::std::os::raw::c_char>) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn atoi(arg1: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn atol(arg1: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn atoll(arg1: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_longlong;
}
#[pg_guard]
extern "C" {
    pub fn bsearch(
        __key: PgPtr<::std::os::raw::c_void>,
        __base: PgPtr<::std::os::raw::c_void>,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: PgPtr<::std::os::raw::c_void>,
                arg2: PgPtr<::std::os::raw::c_void>,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
#[pg_guard]
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn getenv(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
#[pg_guard]
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
#[pg_guard]
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
#[pg_guard]
extern "C" {
    pub fn mblen(__s: PgPtr<::std::os::raw::c_char>, __n: usize) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn mbstowcs(
        arg1: PgPtr<wchar_t>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: usize,
    ) -> usize;
}
#[pg_guard]
extern "C" {
    pub fn mbtowc(
        arg1: PgPtr<wchar_t>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn qsort(
        __base: PgPtr<::std::os::raw::c_void>,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: PgPtr<::std::os::raw::c_void>,
                arg2: PgPtr<::std::os::raw::c_void>,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
#[pg_guard]
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
#[pg_guard]
extern "C" {
    pub fn strtod(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn strtof(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn strtol(
        __str: PgPtr<::std::os::raw::c_char>,
        __endptr: PgPtr<PgPtr<::std::os::raw::c_char>>,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn strtold(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn strtoll(
        __str: PgPtr<::std::os::raw::c_char>,
        __endptr: PgPtr<PgPtr<::std::os::raw::c_char>>,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
#[pg_guard]
extern "C" {
    pub fn strtoul(
        __str: PgPtr<::std::os::raw::c_char>,
        __endptr: PgPtr<PgPtr<::std::os::raw::c_char>>,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
#[pg_guard]
extern "C" {
    pub fn strtoull(
        __str: PgPtr<::std::os::raw::c_char>,
        __endptr: PgPtr<PgPtr<::std::os::raw::c_char>>,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
#[pg_guard]
extern "C" {
    pub fn system(arg1: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn wcstombs(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<wchar_t>,
        arg3: usize,
    ) -> usize;
}
#[pg_guard]
extern "C" {
    pub fn wctomb(arg1: PgPtr<::std::os::raw::c_char>, arg2: wchar_t) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn a64l(arg1: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn drand48() -> f64;
}
#[pg_guard]
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: PgPtr<::std::os::raw::c_int>,
        arg4: PgPtr<::std::os::raw::c_int>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn erand48(arg1: PgPtr<::std::os::raw::c_ushort>) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: PgPtr<::std::os::raw::c_int>,
        arg4: PgPtr<::std::os::raw::c_int>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn getsubopt(
        arg1: PgPtr<PgPtr<::std::os::raw::c_char>>,
        arg2: PgPtr<PgPtr<::std::os::raw::c_char>>,
        arg3: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: usize,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn jrand48(arg1: PgPtr<::std::os::raw::c_ushort>) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn lcong48(arg1: PgPtr<::std::os::raw::c_ushort>);
}
#[pg_guard]
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn mktemp(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn mkstemp(arg1: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn nrand48(arg1: PgPtr<::std::os::raw::c_ushort>) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: PgPtr<::std::os::raw::c_char>,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn putenv(arg1: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn rand_r(arg1: PgPtr<::std::os::raw::c_uint>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn seed48(arg1: PgPtr<::std::os::raw::c_ushort>) -> PgPtr<::std::os::raw::c_ushort>;
}
#[pg_guard]
extern "C" {
    pub fn setenv(
        __name: PgPtr<::std::os::raw::c_char>,
        __value: PgPtr<::std::os::raw::c_char>,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn setkey(arg1: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn setstate(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
#[pg_guard]
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
#[pg_guard]
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn unsetenv(arg1: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
#[pg_guard]
extern "C" {
    pub fn arc4random() -> u32;
}
#[pg_guard]
extern "C" {
    pub fn arc4random_addrandom(arg1: PgPtr<::std::os::raw::c_uchar>, arg2: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn arc4random_buf(__buf: PgPtr<::std::os::raw::c_void>, __nbytes: usize);
}
#[pg_guard]
extern "C" {
    pub fn arc4random_stir();
}
#[pg_guard]
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
#[pg_guard]
extern "C" {
    pub fn atexit_b(arg1: PgPtr<::std::os::raw::c_void>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bsearch_b(
        __key: PgPtr<::std::os::raw::c_void>,
        __base: PgPtr<::std::os::raw::c_void>,
        __nel: usize,
        __width: usize,
        __compar: PgPtr<::std::os::raw::c_void>,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn cgetcap(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn cgetent(
        arg1: PgPtr<PgPtr<::std::os::raw::c_char>>,
        arg2: PgPtr<PgPtr<::std::os::raw::c_char>>,
        arg3: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn cgetfirst(
        arg1: PgPtr<PgPtr<::std::os::raw::c_char>>,
        arg2: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn cgetmatch(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn cgetnext(
        arg1: PgPtr<PgPtr<::std::os::raw::c_char>>,
        arg2: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn cgetnum(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: PgPtr<::std::os::raw::c_long>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn cgetset(arg1: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn cgetstr(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn cgetustr(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_daemon$1050"]
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: PgPtr<::std::os::raw::c_char>,
        len: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn getbsize(
        arg1: PgPtr<::std::os::raw::c_int>,
        arg2: PgPtr<::std::os::raw::c_long>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn getloadavg(arg1: PgPtr<f64>, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getprogname() -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn setprogname(arg1: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn heapsort(
        __base: PgPtr<::std::os::raw::c_void>,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: PgPtr<::std::os::raw::c_void>,
                arg2: PgPtr<::std::os::raw::c_void>,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn heapsort_b(
        __base: PgPtr<::std::os::raw::c_void>,
        __nel: usize,
        __width: usize,
        __compar: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn mergesort(
        __base: PgPtr<::std::os::raw::c_void>,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: PgPtr<::std::os::raw::c_void>,
                arg2: PgPtr<::std::os::raw::c_void>,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn mergesort_b(
        __base: PgPtr<::std::os::raw::c_void>,
        __nel: usize,
        __width: usize,
        __compar: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn psort(
        __base: PgPtr<::std::os::raw::c_void>,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: PgPtr<::std::os::raw::c_void>,
                arg2: PgPtr<::std::os::raw::c_void>,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
#[pg_guard]
extern "C" {
    pub fn psort_b(
        __base: PgPtr<::std::os::raw::c_void>,
        __nel: usize,
        __width: usize,
        __compar: PgPtr<::std::os::raw::c_void>,
    );
}
#[pg_guard]
extern "C" {
    pub fn psort_r(
        __base: PgPtr<::std::os::raw::c_void>,
        __nel: usize,
        __width: usize,
        arg1: PgPtr<::std::os::raw::c_void>,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: PgPtr<::std::os::raw::c_void>,
                arg2: PgPtr<::std::os::raw::c_void>,
                arg3: PgPtr<::std::os::raw::c_void>,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
#[pg_guard]
extern "C" {
    pub fn qsort_b(
        __base: PgPtr<::std::os::raw::c_void>,
        __nel: usize,
        __width: usize,
        __compar: PgPtr<::std::os::raw::c_void>,
    );
}
#[pg_guard]
extern "C" {
    pub fn qsort_r(
        __base: PgPtr<::std::os::raw::c_void>,
        __nel: usize,
        __width: usize,
        arg1: PgPtr<::std::os::raw::c_void>,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: PgPtr<::std::os::raw::c_void>,
                arg2: PgPtr<::std::os::raw::c_void>,
                arg3: PgPtr<::std::os::raw::c_void>,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
#[pg_guard]
extern "C" {
    pub fn radixsort(
        __base: PgPtr<PgPtr<::std::os::raw::c_uchar>>,
        __nel: ::std::os::raw::c_int,
        __table: PgPtr<::std::os::raw::c_uchar>,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn rpmatch(arg1: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sradixsort(
        __base: PgPtr<PgPtr<::std::os::raw::c_uchar>>,
        __nel: ::std::os::raw::c_int,
        __table: PgPtr<::std::os::raw::c_uchar>,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sranddev();
}
#[pg_guard]
extern "C" {
    pub fn srandomdev();
}
#[pg_guard]
extern "C" {
    pub fn reallocf(
        __ptr: PgPtr<::std::os::raw::c_void>,
        __size: usize,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn strtoq(
        __str: PgPtr<::std::os::raw::c_char>,
        __endptr: PgPtr<PgPtr<::std::os::raw::c_char>>,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
#[pg_guard]
extern "C" {
    pub fn strtouq(
        __str: PgPtr<::std::os::raw::c_char>,
        __endptr: PgPtr<PgPtr<::std::os::raw::c_char>>,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
#[pg_guard]
extern "C" {
    pub static mut suboptarg: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn memchr(
        __s: PgPtr<::std::os::raw::c_void>,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn memcmp(
        __s1: PgPtr<::std::os::raw::c_void>,
        __s2: PgPtr<::std::os::raw::c_void>,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn memcpy(
        __dst: PgPtr<::std::os::raw::c_void>,
        __src: PgPtr<::std::os::raw::c_void>,
        __n: ::std::os::raw::c_ulong,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn memmove(
        __dst: PgPtr<::std::os::raw::c_void>,
        __src: PgPtr<::std::os::raw::c_void>,
        __len: ::std::os::raw::c_ulong,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn memset(
        __b: PgPtr<::std::os::raw::c_void>,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn strcat(
        __s1: PgPtr<::std::os::raw::c_char>,
        __s2: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strchr(
        __s: PgPtr<::std::os::raw::c_char>,
        __c: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strcmp(
        __s1: PgPtr<::std::os::raw::c_char>,
        __s2: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn strcoll(
        __s1: PgPtr<::std::os::raw::c_char>,
        __s2: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn strcpy(
        __dst: PgPtr<::std::os::raw::c_char>,
        __src: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strcspn(
        __s: PgPtr<::std::os::raw::c_char>,
        __charset: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_ulong;
}
#[pg_guard]
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strlen(__s: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_ulong;
}
#[pg_guard]
extern "C" {
    pub fn strncat(
        __s1: PgPtr<::std::os::raw::c_char>,
        __s2: PgPtr<::std::os::raw::c_char>,
        __n: ::std::os::raw::c_ulong,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strncmp(
        __s1: PgPtr<::std::os::raw::c_char>,
        __s2: PgPtr<::std::os::raw::c_char>,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn strncpy(
        __dst: PgPtr<::std::os::raw::c_char>,
        __src: PgPtr<::std::os::raw::c_char>,
        __n: ::std::os::raw::c_ulong,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strpbrk(
        __s: PgPtr<::std::os::raw::c_char>,
        __charset: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strrchr(
        __s: PgPtr<::std::os::raw::c_char>,
        __c: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strspn(
        __s: PgPtr<::std::os::raw::c_char>,
        __charset: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_ulong;
}
#[pg_guard]
extern "C" {
    pub fn strstr(
        __big: PgPtr<::std::os::raw::c_char>,
        __little: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strtok(
        __str: PgPtr<::std::os::raw::c_char>,
        __sep: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strxfrm(
        __s1: PgPtr<::std::os::raw::c_char>,
        __s2: PgPtr<::std::os::raw::c_char>,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[pg_guard]
extern "C" {
    pub fn strtok_r(
        __str: PgPtr<::std::os::raw::c_char>,
        __sep: PgPtr<::std::os::raw::c_char>,
        __lasts: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: PgPtr<::std::os::raw::c_char>,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn strdup(__s1: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn memccpy(
        __dst: PgPtr<::std::os::raw::c_void>,
        __src: PgPtr<::std::os::raw::c_void>,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn stpcpy(
        __dst: PgPtr<::std::os::raw::c_char>,
        __src: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn stpncpy(
        __dst: PgPtr<::std::os::raw::c_char>,
        __src: PgPtr<::std::os::raw::c_char>,
        __n: ::std::os::raw::c_ulong,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strndup(
        __s1: PgPtr<::std::os::raw::c_char>,
        __n: ::std::os::raw::c_ulong,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strnlen(__s1: PgPtr<::std::os::raw::c_char>, __n: usize) -> usize;
}
#[pg_guard]
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> PgPtr<::std::os::raw::c_char>;
}
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[pg_guard]
extern "C" {
    pub fn memset_s(
        __s: PgPtr<::std::os::raw::c_void>,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
#[pg_guard]
extern "C" {
    pub fn memmem(
        __big: PgPtr<::std::os::raw::c_void>,
        __big_len: usize,
        __little: PgPtr<::std::os::raw::c_void>,
        __little_len: usize,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn memset_pattern4(
        __b: PgPtr<::std::os::raw::c_void>,
        __pattern4: PgPtr<::std::os::raw::c_void>,
        __len: usize,
    );
}
#[pg_guard]
extern "C" {
    pub fn memset_pattern8(
        __b: PgPtr<::std::os::raw::c_void>,
        __pattern8: PgPtr<::std::os::raw::c_void>,
        __len: usize,
    );
}
#[pg_guard]
extern "C" {
    pub fn memset_pattern16(
        __b: PgPtr<::std::os::raw::c_void>,
        __pattern16: PgPtr<::std::os::raw::c_void>,
        __len: usize,
    );
}
#[pg_guard]
extern "C" {
    pub fn strcasestr(
        __big: PgPtr<::std::os::raw::c_char>,
        __little: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strnstr(
        __big: PgPtr<::std::os::raw::c_char>,
        __little: PgPtr<::std::os::raw::c_char>,
        __len: usize,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strlcat(
        __dst: PgPtr<::std::os::raw::c_char>,
        __source: PgPtr<::std::os::raw::c_char>,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[pg_guard]
extern "C" {
    pub fn strlcpy(
        __dst: PgPtr<::std::os::raw::c_char>,
        __source: PgPtr<::std::os::raw::c_char>,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[pg_guard]
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn strsep(
        __stringp: PgPtr<PgPtr<::std::os::raw::c_char>>,
        __delim: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn swab(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: PgPtr<::std::os::raw::c_void>,
        arg3: isize,
    );
}
#[pg_guard]
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: PgPtr<::std::os::raw::c_void>,
        __b2: PgPtr<::std::os::raw::c_void>,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bcmp(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: PgPtr<::std::os::raw::c_void>,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bcopy(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: PgPtr<::std::os::raw::c_void>,
        arg3: usize,
    );
}
#[pg_guard]
extern "C" {
    pub fn bzero(arg1: PgPtr<::std::os::raw::c_void>, arg2: ::std::os::raw::c_ulong);
}
#[pg_guard]
extern "C" {
    pub fn index(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn rindex(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn strcasecmp(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn strncasecmp(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
pub type max_align_t = u128;
pub type __gnuc_va_list = __builtin_va_list;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = PgPtr<quad_t>;
pub type caddr_t = PgPtr<::std::os::raw::c_char>;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = PgPtr<_opaque_pthread_t>;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
#[pg_guard]
extern "C" {
    pub fn __error() -> PgPtr<::std::os::raw::c_int>;
}
#[repr(C)]
pub struct lconv {
    pub decimal_point: PgPtr<::std::os::raw::c_char>,
    pub thousands_sep: PgPtr<::std::os::raw::c_char>,
    pub grouping: PgPtr<::std::os::raw::c_char>,
    pub int_curr_symbol: PgPtr<::std::os::raw::c_char>,
    pub currency_symbol: PgPtr<::std::os::raw::c_char>,
    pub mon_decimal_point: PgPtr<::std::os::raw::c_char>,
    pub mon_thousands_sep: PgPtr<::std::os::raw::c_char>,
    pub mon_grouping: PgPtr<::std::os::raw::c_char>,
    pub positive_sign: PgPtr<::std::os::raw::c_char>,
    pub negative_sign: PgPtr<::std::os::raw::c_char>,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[pg_guard]
extern "C" {
    pub fn localeconv() -> PgPtr<lconv>;
}
#[pg_guard]
extern "C" {
    pub fn setlocale(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
pub type Pointer = PgPtr<::std::os::raw::c_char>;
pub type int8 = ::std::os::raw::c_schar;
pub type int16 = ::std::os::raw::c_short;
pub type int32 = ::std::os::raw::c_int;
pub type uint8 = ::std::os::raw::c_uchar;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::std::os::raw::c_long;
pub type uint64 = ::std::os::raw::c_ulong;
pub type int128 = i128;
pub type uint128 = u128;
pub type Size = usize;
pub type Index = ::std::os::raw::c_uint;
pub type Offset = ::std::os::raw::c_int;
pub type float4 = f32;
pub type float8 = f64;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type TransactionId = uint32;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactId = TransactionId;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
pub struct IntArray {
    pub indx: [::std::os::raw::c_int; 6usize],
}
#[repr(C)]
pub struct varlena {
    pub vl_len_: [::std::os::raw::c_char; 4usize],
    pub vl_dat: __IncompleteArrayField<::std::os::raw::c_char>,
}
pub type bytea = varlena;
pub type text = varlena;
pub type BpChar = varlena;
pub type VarChar = varlena;
#[repr(C)]
pub struct int2vector {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: __IncompleteArrayField<int16>,
}
#[repr(C)]
pub struct oidvector {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: __IncompleteArrayField<Oid>,
}
#[repr(C)]
pub struct nameData {
    pub data: [::std::os::raw::c_char; 64usize],
}
pub type NameData = nameData;
pub type Name = PgPtr<NameData>;
#[pg_guard]
extern "C" {
    pub fn ExceptionalCondition(
        conditionName: PgPtr<::std::os::raw::c_char>,
        errorType: PgPtr<::std::os::raw::c_char>,
        fileName: PgPtr<::std::os::raw::c_char>,
        lineNumber: ::std::os::raw::c_int,
    );
}
#[repr(C)]
pub struct PGAlignedBlock {
    pub data: __BindgenUnionField<[::std::os::raw::c_char; 8192usize]>,
    pub force_align_d: __BindgenUnionField<f64>,
    pub force_align_i64: __BindgenUnionField<int64>,
    pub bindgen_union_field: [u64; 1024usize],
}
#[repr(C)]
pub struct PGAlignedXLogBlock {
    pub data: __BindgenUnionField<[::std::os::raw::c_char; 8192usize]>,
    pub force_align_d: __BindgenUnionField<f64>,
    pub force_align_i64: __BindgenUnionField<int64>,
    pub bindgen_union_field: [u64; 1024usize],
}
#[pg_guard]
extern "C" {
    pub fn fdatasync(fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wint_t = __darwin_wint_t;
#[repr(C)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: PgPtr<__uint32_t>,
}
#[repr(C)]
pub struct _RuneRange {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: PgPtr<_RuneEntry>,
}
#[repr(C)]
pub struct _RuneCharClass {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
#[repr(C)]
pub struct _RuneLocale {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: PgPtr<::std::os::raw::c_char>,
            arg2: __darwin_size_t,
            arg3: PgPtr<PgPtr<::std::os::raw::c_char>>,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: __darwin_rune_t,
            arg2: PgPtr<::std::os::raw::c_char>,
            arg3: __darwin_size_t,
            arg4: PgPtr<PgPtr<::std::os::raw::c_char>>,
        ) -> ::std::os::raw::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: PgPtr<::std::os::raw::c_void>,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: PgPtr<_RuneCharClass>,
}
#[pg_guard]
extern "C" {
    pub static mut _DefaultRuneLocale: _RuneLocale;
}
#[pg_guard]
extern "C" {
    pub static mut _CurrentRuneLocale: PgPtr<_RuneLocale>;
}
#[pg_guard]
extern "C" {
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
}
#[pg_guard]
extern "C" {
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
#[pg_guard]
extern "C" {
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
#[pg_guard]
extern "C" {
    pub fn __maskrune(
        arg1: __darwin_ct_rune_t,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
#[pg_guard]
extern "C" {
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
pub type socklen_t = __darwin_socklen_t;
pub type sa_family_t = __uint8_t;
#[repr(C)]
pub struct iovec {
    pub iov_base: PgPtr<::std::os::raw::c_void>,
    pub iov_len: usize,
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: PgPtr<sockaddr>,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: PgPtr<sockaddr>,
    pub sae_dstaddrlen: socklen_t,
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[repr(C)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[repr(C)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[repr(C)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[repr(C)]
pub struct msghdr {
    pub msg_name: PgPtr<::std::os::raw::c_void>,
    pub msg_namelen: socklen_t,
    pub msg_iov: PgPtr<iovec>,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: PgPtr<::std::os::raw::c_void>,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct sf_hdtr {
    pub headers: PgPtr<iovec>,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: PgPtr<iovec>,
    pub trl_cnt: ::std::os::raw::c_int,
}
#[pg_guard]
extern "C" {
    pub fn accept(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<sockaddr>,
        arg3: PgPtr<socklen_t>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bind(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<sockaddr>,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn connect(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<sockaddr>,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<sockaddr>,
        arg3: PgPtr<socklen_t>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<sockaddr>,
        arg3: PgPtr<socklen_t>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: PgPtr<::std::os::raw::c_void>,
        arg5: PgPtr<socklen_t>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn listen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn recv(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<::std::os::raw::c_void>,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
#[pg_guard]
extern "C" {
    pub fn recvfrom(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<::std::os::raw::c_void>,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: PgPtr<sockaddr>,
        arg6: PgPtr<socklen_t>,
    ) -> isize;
}
#[pg_guard]
extern "C" {
    pub fn recvmsg(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<msghdr>,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
#[pg_guard]
extern "C" {
    pub fn send(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<::std::os::raw::c_void>,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
#[pg_guard]
extern "C" {
    pub fn sendmsg(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<msghdr>,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
#[pg_guard]
extern "C" {
    pub fn sendto(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<::std::os::raw::c_void>,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: PgPtr<sockaddr>,
        arg6: socklen_t,
    ) -> isize;
}
#[pg_guard]
extern "C" {
    pub fn setsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: PgPtr<::std::os::raw::c_void>,
        arg5: socklen_t,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn socket(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn socketpair(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sendfile(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
        arg4: PgPtr<off_t>,
        arg5: PgPtr<sf_hdtr>,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pfctlinput(arg1: ::std::os::raw::c_int, arg2: PgPtr<sockaddr>);
}
#[pg_guard]
extern "C" {
    pub fn connectx(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<sa_endpoints_t>,
        arg3: sae_associd_t,
        arg4: ::std::os::raw::c_uint,
        arg5: PgPtr<iovec>,
        arg6: ::std::os::raw::c_uint,
        arg7: PgPtr<usize>,
        arg8: PgPtr<sae_connid_t>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn disconnectx(
        arg1: ::std::os::raw::c_int,
        arg2: sae_associd_t,
        arg3: sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
pub struct sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[repr(C)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C, packed(4))]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[repr(C, packed(4))]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[repr(C, packed(4))]
pub struct __msfilterreq {
    pub msfr_ifindex: u32,
    pub msfr_fmode: u32,
    pub msfr_nsrcs: u32,
    pub __msfr_align: u32,
    pub msfr_group: sockaddr_storage,
    pub msfr_srcs: PgPtr<sockaddr_storage>,
}
#[pg_guard]
extern "C" {
    pub fn setipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: u32,
        arg5: u32,
        arg6: PgPtr<in_addr>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: PgPtr<u32>,
        arg5: PgPtr<u32>,
        arg6: PgPtr<in_addr>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn setsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: PgPtr<sockaddr>,
        arg4: socklen_t,
        arg5: u32,
        arg6: u32,
        arg7: PgPtr<sockaddr_storage>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: PgPtr<sockaddr>,
        arg4: socklen_t,
        arg5: PgPtr<u32>,
        arg6: PgPtr<u32>,
        arg7: PgPtr<sockaddr_storage>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[repr(C)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
pub struct in6_addr__bindgen_ty_1 {
    pub __u6_addr8: __BindgenUnionField<[__uint8_t; 16usize]>,
    pub __u6_addr16: __BindgenUnionField<[__uint16_t; 8usize]>,
    pub __u6_addr32: __BindgenUnionField<[__uint32_t; 4usize]>,
    pub bindgen_union_field: [u32; 4usize],
}
pub type in6_addr_t = in6_addr;
#[repr(C)]
pub struct sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __uint32_t,
}
#[pg_guard]
extern "C" {
    pub static in6addr_any: in6_addr;
}
#[pg_guard]
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[pg_guard]
extern "C" {
    pub static in6addr_nodelocal_allnodes: in6_addr;
}
#[pg_guard]
extern "C" {
    pub static in6addr_linklocal_allnodes: in6_addr;
}
#[pg_guard]
extern "C" {
    pub static in6addr_linklocal_allrouters: in6_addr;
}
#[pg_guard]
extern "C" {
    pub static in6addr_linklocal_allv2routers: in6_addr;
}
#[repr(C)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[repr(C)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[repr(C)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[pg_guard]
extern "C" {
    pub fn inet6_option_space(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_option_init(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: PgPtr<PgPtr<cmsghdr>>,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_option_append(
        arg1: PgPtr<cmsghdr>,
        arg2: PgPtr<__uint8_t>,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_option_alloc(
        arg1: PgPtr<cmsghdr>,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> PgPtr<__uint8_t>;
}
#[pg_guard]
extern "C" {
    pub fn inet6_option_next(
        arg1: PgPtr<cmsghdr>,
        arg2: PgPtr<PgPtr<__uint8_t>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_option_find(
        arg1: PgPtr<cmsghdr>,
        arg2: PgPtr<PgPtr<__uint8_t>>,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rthdr_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> usize;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rthdr_init(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: ::std::os::raw::c_int,
    ) -> PgPtr<cmsghdr>;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rthdr_add(
        arg1: PgPtr<cmsghdr>,
        arg2: PgPtr<in6_addr>,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rthdr_lasthop(
        arg1: PgPtr<cmsghdr>,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rthdr_segments(arg1: PgPtr<cmsghdr>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rthdr_getaddr(
        arg1: PgPtr<cmsghdr>,
        arg2: ::std::os::raw::c_int,
    ) -> PgPtr<in6_addr>;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rthdr_getflags(
        arg1: PgPtr<cmsghdr>,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_opt_init(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: socklen_t,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_opt_append(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: socklen_t,
        arg6: __uint8_t,
        arg7: PgPtr<PgPtr<::std::os::raw::c_void>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_opt_finish(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_opt_set_val(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: ::std::os::raw::c_int,
        arg3: PgPtr<::std::os::raw::c_void>,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_opt_next(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: PgPtr<__uint8_t>,
        arg5: PgPtr<socklen_t>,
        arg6: PgPtr<PgPtr<::std::os::raw::c_void>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_opt_find(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: PgPtr<socklen_t>,
        arg6: PgPtr<PgPtr<::std::os::raw::c_void>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_opt_get_val(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: ::std::os::raw::c_int,
        arg3: PgPtr<::std::os::raw::c_void>,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rth_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> socklen_t;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rth_init(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rth_add(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: PgPtr<in6_addr>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rth_reverse(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rth_segments(arg1: PgPtr<::std::os::raw::c_void>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet6_rth_getaddr(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: ::std::os::raw::c_int,
    ) -> PgPtr<in6_addr>;
}
#[pg_guard]
extern "C" {
    pub fn bindresvport(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<sockaddr_in>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bindresvport_sa(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<sockaddr>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut h_errno: ::std::os::raw::c_int;
}
#[repr(C)]
pub struct hostent {
    pub h_name: PgPtr<::std::os::raw::c_char>,
    pub h_aliases: PgPtr<PgPtr<::std::os::raw::c_char>>,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: PgPtr<PgPtr<::std::os::raw::c_char>>,
}
#[repr(C)]
pub struct netent {
    pub n_name: PgPtr<::std::os::raw::c_char>,
    pub n_aliases: PgPtr<PgPtr<::std::os::raw::c_char>>,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[repr(C)]
pub struct servent {
    pub s_name: PgPtr<::std::os::raw::c_char>,
    pub s_aliases: PgPtr<PgPtr<::std::os::raw::c_char>>,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct protoent {
    pub p_name: PgPtr<::std::os::raw::c_char>,
    pub p_aliases: PgPtr<PgPtr<::std::os::raw::c_char>>,
    pub p_proto: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: PgPtr<::std::os::raw::c_char>,
    pub ai_addr: PgPtr<sockaddr>,
    pub ai_next: PgPtr<addrinfo>,
}
#[repr(C)]
pub struct rpcent {
    pub r_name: PgPtr<::std::os::raw::c_char>,
    pub r_aliases: PgPtr<PgPtr<::std::os::raw::c_char>>,
    pub r_number: ::std::os::raw::c_int,
}
#[pg_guard]
extern "C" {
    pub fn endhostent();
}
#[pg_guard]
extern "C" {
    pub fn endnetent();
}
#[pg_guard]
extern "C" {
    pub fn endprotoent();
}
#[pg_guard]
extern "C" {
    pub fn endservent();
}
#[pg_guard]
extern "C" {
    pub fn freeaddrinfo(arg1: PgPtr<addrinfo>);
}
#[pg_guard]
extern "C" {
    pub fn gai_strerror(arg1: ::std::os::raw::c_int) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn getaddrinfo(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: PgPtr<addrinfo>,
        arg4: PgPtr<PgPtr<addrinfo>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn gethostbyaddr(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> PgPtr<hostent>;
}
#[pg_guard]
extern "C" {
    pub fn gethostbyname(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<hostent>;
}
#[pg_guard]
extern "C" {
    pub fn gethostent() -> PgPtr<hostent>;
}
#[pg_guard]
extern "C" {
    pub fn getnameinfo(
        arg1: PgPtr<sockaddr>,
        arg2: socklen_t,
        arg3: PgPtr<::std::os::raw::c_char>,
        arg4: socklen_t,
        arg5: PgPtr<::std::os::raw::c_char>,
        arg6: socklen_t,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getnetbyaddr(arg1: u32, arg2: ::std::os::raw::c_int) -> PgPtr<netent>;
}
#[pg_guard]
extern "C" {
    pub fn getnetbyname(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<netent>;
}
#[pg_guard]
extern "C" {
    pub fn getnetent() -> PgPtr<netent>;
}
#[pg_guard]
extern "C" {
    pub fn getprotobyname(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<protoent>;
}
#[pg_guard]
extern "C" {
    pub fn getprotobynumber(arg1: ::std::os::raw::c_int) -> PgPtr<protoent>;
}
#[pg_guard]
extern "C" {
    pub fn getprotoent() -> PgPtr<protoent>;
}
#[pg_guard]
extern "C" {
    pub fn getservbyname(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<servent>;
}
#[pg_guard]
extern "C" {
    pub fn getservbyport(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<servent>;
}
#[pg_guard]
extern "C" {
    pub fn getservent() -> PgPtr<servent>;
}
#[pg_guard]
extern "C" {
    pub fn sethostent(arg1: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn setnetent(arg1: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn setprotoent(arg1: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn setservent(arg1: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn freehostent(arg1: PgPtr<hostent>);
}
#[pg_guard]
extern "C" {
    pub fn gethostbyname2(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: ::std::os::raw::c_int,
    ) -> PgPtr<hostent>;
}
#[pg_guard]
extern "C" {
    pub fn getipnodebyaddr(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: PgPtr<::std::os::raw::c_int>,
    ) -> PgPtr<hostent>;
}
#[pg_guard]
extern "C" {
    pub fn getipnodebyname(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: PgPtr<::std::os::raw::c_int>,
    ) -> PgPtr<hostent>;
}
#[pg_guard]
extern "C" {
    pub fn getrpcbyname(name: PgPtr<::std::os::raw::c_char>) -> PgPtr<rpcent>;
}
#[pg_guard]
extern "C" {
    pub fn getrpcbynumber(number: ::std::os::raw::c_int) -> PgPtr<rpcent>;
}
#[pg_guard]
extern "C" {
    pub fn getrpcent() -> PgPtr<rpcent>;
}
#[pg_guard]
extern "C" {
    pub fn setrpcent(stayopen: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn endrpcent();
}
#[pg_guard]
extern "C" {
    pub fn herror(arg1: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn hstrerror(arg1: ::std::os::raw::c_int) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn innetgr(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: PgPtr<::std::os::raw::c_char>,
        arg4: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getnetgrent(
        arg1: PgPtr<PgPtr<::std::os::raw::c_char>>,
        arg2: PgPtr<PgPtr<::std::os::raw::c_char>>,
        arg3: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn endnetgrent();
}
#[pg_guard]
extern "C" {
    pub fn setnetgrent(arg1: PgPtr<::std::os::raw::c_char>);
}
#[repr(C)]
pub struct passwd {
    pub pw_name: PgPtr<::std::os::raw::c_char>,
    pub pw_passwd: PgPtr<::std::os::raw::c_char>,
    pub pw_uid: uid_t,
    pub pw_gid: gid_t,
    pub pw_change: __darwin_time_t,
    pub pw_class: PgPtr<::std::os::raw::c_char>,
    pub pw_gecos: PgPtr<::std::os::raw::c_char>,
    pub pw_dir: PgPtr<::std::os::raw::c_char>,
    pub pw_shell: PgPtr<::std::os::raw::c_char>,
    pub pw_expire: __darwin_time_t,
}
#[pg_guard]
extern "C" {
    pub fn getpwuid(arg1: uid_t) -> PgPtr<passwd>;
}
#[pg_guard]
extern "C" {
    pub fn getpwnam(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<passwd>;
}
#[pg_guard]
extern "C" {
    pub fn getpwuid_r(
        arg1: uid_t,
        arg2: PgPtr<passwd>,
        arg3: PgPtr<::std::os::raw::c_char>,
        arg4: usize,
        arg5: PgPtr<PgPtr<passwd>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getpwnam_r(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<passwd>,
        arg3: PgPtr<::std::os::raw::c_char>,
        arg4: usize,
        arg5: PgPtr<PgPtr<passwd>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getpwent() -> PgPtr<passwd>;
}
#[pg_guard]
extern "C" {
    pub fn setpwent();
}
#[pg_guard]
extern "C" {
    pub fn endpwent();
}
pub type uuid_t = __darwin_uuid_t;
pub type uuid_string_t = __darwin_uuid_string_t;
#[pg_guard]
extern "C" {
    pub static UUID_NULL: uuid_t;
}
#[pg_guard]
extern "C" {
    pub fn uuid_clear(uu: PgPtr<::std::os::raw::c_uchar>);
}
#[pg_guard]
extern "C" {
    pub fn uuid_compare(
        uu1: PgPtr<::std::os::raw::c_uchar>,
        uu2: PgPtr<::std::os::raw::c_uchar>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn uuid_copy(dst: PgPtr<::std::os::raw::c_uchar>, src: PgPtr<::std::os::raw::c_uchar>);
}
#[pg_guard]
extern "C" {
    pub fn uuid_generate(out: PgPtr<::std::os::raw::c_uchar>);
}
#[pg_guard]
extern "C" {
    pub fn uuid_generate_random(out: PgPtr<::std::os::raw::c_uchar>);
}
#[pg_guard]
extern "C" {
    pub fn uuid_generate_time(out: PgPtr<::std::os::raw::c_uchar>);
}
#[pg_guard]
extern "C" {
    pub fn uuid_generate_early_random(out: PgPtr<::std::os::raw::c_uchar>);
}
#[pg_guard]
extern "C" {
    pub fn uuid_is_null(uu: PgPtr<::std::os::raw::c_uchar>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn uuid_parse(
        in_: PgPtr<::std::os::raw::c_char>,
        uu: PgPtr<::std::os::raw::c_uchar>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn uuid_unparse(uu: PgPtr<::std::os::raw::c_uchar>, out: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn uuid_unparse_lower(
        uu: PgPtr<::std::os::raw::c_uchar>,
        out: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn uuid_unparse_upper(
        uu: PgPtr<::std::os::raw::c_uchar>,
        out: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn setpassent(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn user_from_uid(arg1: uid_t, arg2: ::std::os::raw::c_int)
        -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn getpwuuid(arg1: PgPtr<::std::os::raw::c_uchar>) -> PgPtr<passwd>;
}
#[pg_guard]
extern "C" {
    pub fn getpwuuid_r(
        arg1: PgPtr<::std::os::raw::c_uchar>,
        arg2: PgPtr<passwd>,
        arg3: PgPtr<::std::os::raw::c_char>,
        arg4: usize,
        arg5: PgPtr<PgPtr<passwd>>,
    ) -> ::std::os::raw::c_int;
}
pub type pgsocket = ::std::os::raw::c_int;
#[pg_guard]
extern "C" {
    pub fn pg_set_noblock(sock: pgsocket) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_set_block(sock: pgsocket) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn has_drive_prefix(filename: PgPtr<::std::os::raw::c_char>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn first_dir_separator(
        filename: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn last_dir_separator(
        filename: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn first_path_var_separator(
        pathlist: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn join_path_components(
        ret_path: PgPtr<::std::os::raw::c_char>,
        head: PgPtr<::std::os::raw::c_char>,
        tail: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn canonicalize_path(path: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn make_native_path(path: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn cleanup_path(path: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn path_contains_parent_reference(path: PgPtr<::std::os::raw::c_char>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn path_is_relative_and_below_cwd(path: PgPtr<::std::os::raw::c_char>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn path_is_prefix_of_path(
        path1: PgPtr<::std::os::raw::c_char>,
        path2: PgPtr<::std::os::raw::c_char>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn make_absolute_path(path: PgPtr<::std::os::raw::c_char>)
        -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn get_progname(argv0: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn get_share_path(
        my_exec_path: PgPtr<::std::os::raw::c_char>,
        ret_path: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_etc_path(
        my_exec_path: PgPtr<::std::os::raw::c_char>,
        ret_path: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_include_path(
        my_exec_path: PgPtr<::std::os::raw::c_char>,
        ret_path: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_pkginclude_path(
        my_exec_path: PgPtr<::std::os::raw::c_char>,
        ret_path: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_includeserver_path(
        my_exec_path: PgPtr<::std::os::raw::c_char>,
        ret_path: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_lib_path(
        my_exec_path: PgPtr<::std::os::raw::c_char>,
        ret_path: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_pkglib_path(
        my_exec_path: PgPtr<::std::os::raw::c_char>,
        ret_path: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_locale_path(
        my_exec_path: PgPtr<::std::os::raw::c_char>,
        ret_path: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_doc_path(
        my_exec_path: PgPtr<::std::os::raw::c_char>,
        ret_path: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_html_path(
        my_exec_path: PgPtr<::std::os::raw::c_char>,
        ret_path: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_man_path(
        my_exec_path: PgPtr<::std::os::raw::c_char>,
        ret_path: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_home_path(ret_path: PgPtr<::std::os::raw::c_char>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_parent_directory(path: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn pgfnames(path: PgPtr<::std::os::raw::c_char>) -> PgPtr<PgPtr<::std::os::raw::c_char>>;
}
#[pg_guard]
extern "C" {
    pub fn pgfnames_cleanup(filenames: PgPtr<PgPtr<::std::os::raw::c_char>>);
}
#[pg_guard]
extern "C" {
    pub fn set_pglocale_pgservice(
        argv0: PgPtr<::std::os::raw::c_char>,
        app: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn find_my_exec(
        argv0: PgPtr<::std::os::raw::c_char>,
        retpath: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn find_other_exec(
        argv0: PgPtr<::std::os::raw::c_char>,
        target: PgPtr<::std::os::raw::c_char>,
        versionstr: PgPtr<::std::os::raw::c_char>,
        retpath: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_usleep(microsec: ::std::os::raw::c_long);
}
#[pg_guard]
extern "C" {
    pub fn pg_strcasecmp(
        s1: PgPtr<::std::os::raw::c_char>,
        s2: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_strncasecmp(
        s1: PgPtr<::std::os::raw::c_char>,
        s2: PgPtr<::std::os::raw::c_char>,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
#[pg_guard]
extern "C" {
    pub fn pg_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
#[pg_guard]
extern "C" {
    pub fn pg_ascii_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
#[pg_guard]
extern "C" {
    pub fn pg_ascii_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
#[pg_guard]
extern "C" {
    pub fn pg_vsnprintf(
        str_: PgPtr<::std::os::raw::c_char>,
        count: usize,
        fmt: PgPtr<::std::os::raw::c_char>,
        args: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_snprintf(
        str_: PgPtr<::std::os::raw::c_char>,
        count: usize,
        fmt: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_vsprintf(
        str_: PgPtr<::std::os::raw::c_char>,
        fmt: PgPtr<::std::os::raw::c_char>,
        args: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_sprintf(
        str_: PgPtr<::std::os::raw::c_char>,
        fmt: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_vfprintf(
        stream: PgPtr<FILE>,
        fmt: PgPtr<::std::os::raw::c_char>,
        args: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_fprintf(
        stream: PgPtr<FILE>,
        fmt: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_vprintf(
        fmt: PgPtr<::std::os::raw::c_char>,
        args: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_printf(fmt: PgPtr<::std::os::raw::c_char>, ...) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_strfromd(
        str_: PgPtr<::std::os::raw::c_char>,
        count: usize,
        precision: ::std::os::raw::c_int,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_strerror(errnum: ::std::os::raw::c_int) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pg_strerror_r(
        errnum: ::std::os::raw::c_int,
        buf: PgPtr<::std::os::raw::c_char>,
        buflen: usize,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pg_strsignal(signum: ::std::os::raw::c_int) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn simple_prompt(
        prompt: PgPtr<::std::os::raw::c_char>,
        destination: PgPtr<::std::os::raw::c_char>,
        destlen: usize,
        echo: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn pclose_check(stream: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn rmtree(path: PgPtr<::std::os::raw::c_char>, rmtopdir: bool) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_erand48(xseed: PgPtr<::std::os::raw::c_ushort>) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn pg_lrand48() -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn pg_jrand48(xseed: PgPtr<::std::os::raw::c_ushort>) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn pg_srand48(seed: ::std::os::raw::c_long);
}
pub type float_t = f32;
pub type double_t = f64;
#[pg_guard]
extern "C" {
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn __fpclassifyl(arg1: u128) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn acosl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn asinl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn atanl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn atan2l(arg1: u128, arg2: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn cosl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn sinl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn tanl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn acoshl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn asinhl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn atanhl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn coshl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn sinhl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn tanhl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn expl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn exp2l(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn expm1l(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn logl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn log10l(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn log2l(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn log1pl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn logbl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn modff(arg1: f32, arg2: PgPtr<f32>) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn modf(arg1: f64, arg2: PgPtr<f64>) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn modfl(arg1: u128, arg2: PgPtr<u128>) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn ldexpl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn frexpf(arg1: f32, arg2: PgPtr<::std::os::raw::c_int>) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn frexp(arg1: f64, arg2: PgPtr<::std::os::raw::c_int>) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn frexpl(arg1: u128, arg2: PgPtr<::std::os::raw::c_int>) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ilogbl(arg1: u128) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn scalbnl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn scalblnl(arg1: u128, arg2: ::std::os::raw::c_long) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn fabsl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn cbrtl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn hypotl(arg1: u128, arg2: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn powl(arg1: u128, arg2: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn sqrtl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn ceill(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn floorl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn nearbyintl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn rintl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn lrintl(arg1: u128) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn roundl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn lroundl(arg1: u128) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
#[pg_guard]
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
#[pg_guard]
extern "C" {
    pub fn llrintl(arg1: u128) -> ::std::os::raw::c_longlong;
}
#[pg_guard]
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
#[pg_guard]
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
#[pg_guard]
extern "C" {
    pub fn llroundl(arg1: u128) -> ::std::os::raw::c_longlong;
}
#[pg_guard]
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn truncl(arg1: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn fmodl(arg1: u128, arg2: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn remainderl(arg1: u128, arg2: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: PgPtr<::std::os::raw::c_int>) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: PgPtr<::std::os::raw::c_int>) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn remquol(arg1: u128, arg2: u128, arg3: PgPtr<::std::os::raw::c_int>) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn copysignl(arg1: u128, arg2: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn nanf(arg1: PgPtr<::std::os::raw::c_char>) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn nan(arg1: PgPtr<::std::os::raw::c_char>) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn nanl(arg1: PgPtr<::std::os::raw::c_char>) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn nextafterl(arg1: u128, arg2: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: u128) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: u128) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn nexttowardl(arg1: u128, arg2: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn fdiml(arg1: u128, arg2: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn fmaxl(arg1: u128, arg2: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn fminl(arg1: u128, arg2: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn fmal(arg1: u128, arg2: u128, arg3: u128) -> u128;
}
#[pg_guard]
extern "C" {
    pub fn __inff() -> f32;
}
#[pg_guard]
extern "C" {
    pub fn __inf() -> f64;
}
#[pg_guard]
extern "C" {
    pub fn __infl() -> u128;
}
#[pg_guard]
extern "C" {
    pub fn __nan() -> f32;
}
#[pg_guard]
extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
#[pg_guard]
extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
#[repr(C)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[repr(C)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[pg_guard]
extern "C" {
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
#[pg_guard]
extern "C" {
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
#[pg_guard]
extern "C" {
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
#[pg_guard]
extern "C" {
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
#[pg_guard]
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn rinttol(arg1: f64) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn roundtol(arg1: f64) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn finite(arg1: f64) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn significand(arg1: f64) -> f64;
}
#[repr(C)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[pg_guard]
extern "C" {
    pub fn pqGetpwuid(
        uid: uid_t,
        resultbuf: PgPtr<passwd>,
        buffer: PgPtr<::std::os::raw::c_char>,
        buflen: usize,
        result: PgPtr<PgPtr<passwd>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pqGethostbyname(
        name: PgPtr<::std::os::raw::c_char>,
        resultbuf: PgPtr<hostent>,
        buffer: PgPtr<::std::os::raw::c_char>,
        buflen: usize,
        result: PgPtr<PgPtr<hostent>>,
        herrno: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_qsort(
        base: PgPtr<::std::os::raw::c_void>,
        nel: usize,
        elsize: usize,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: PgPtr<::std::os::raw::c_void>,
                arg2: PgPtr<::std::os::raw::c_void>,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
#[pg_guard]
extern "C" {
    pub fn pg_qsort_strcmp(
        a: PgPtr<::std::os::raw::c_void>,
        b: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int;
}
pub type qsort_arg_comparator = ::std::option::Option<
    unsafe extern "C" fn(
        a: PgPtr<::std::os::raw::c_void>,
        b: PgPtr<::std::os::raw::c_void>,
        arg: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int,
>;
#[pg_guard]
extern "C" {
    pub fn qsort_arg(
        base: PgPtr<::std::os::raw::c_void>,
        nel: usize,
        elsize: usize,
        cmp: qsort_arg_comparator,
        arg: PgPtr<::std::os::raw::c_void>,
    );
}
#[pg_guard]
extern "C" {
    pub fn pg_get_encoding_from_locale(
        ctype: PgPtr<::std::os::raw::c_char>,
        write_message: bool,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet_net_ntop(
        af: ::std::os::raw::c_int,
        src: PgPtr<::std::os::raw::c_void>,
        bits: ::std::os::raw::c_int,
        dst: PgPtr<::std::os::raw::c_char>,
        size: usize,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pg_strong_random(buf: PgPtr<::std::os::raw::c_void>, len: usize) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_check_dir(dir: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_mkdir_p(
        path: PgPtr<::std::os::raw::c_char>,
        omode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type pqsigfunc = ::std::option::Option<unsafe extern "C" fn(signo: ::std::os::raw::c_int)>;
#[pg_guard]
extern "C" {
    pub fn pqsignal(signo: ::std::os::raw::c_int, func: pqsigfunc) -> pqsigfunc;
}
#[pg_guard]
extern "C" {
    pub fn pqsignal_no_restart(signo: ::std::os::raw::c_int, func: pqsigfunc) -> pqsigfunc;
}
#[pg_guard]
extern "C" {
    pub fn escape_single_quotes_ascii(
        src: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn wait_result_to_str(exit_status: ::std::os::raw::c_int) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn wait_result_is_signal(
        exit_status: ::std::os::raw::c_int,
        signum: ::std::os::raw::c_int,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn wait_result_is_any_signal(
        exit_status: ::std::os::raw::c_int,
        include_command_not_found: bool,
    ) -> bool;
}
pub type jmp_buf = [::std::os::raw::c_int; 37usize];
pub type sigjmp_buf = [::std::os::raw::c_int; 38usize];
#[pg_guard]
extern "C" {
    pub fn setjmp(arg1: PgPtr<::std::os::raw::c_int>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn longjmp(arg1: PgPtr<::std::os::raw::c_int>, arg2: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn _setjmp(arg1: PgPtr<::std::os::raw::c_int>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn _longjmp(arg1: PgPtr<::std::os::raw::c_int>, arg2: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn longjmperror();
}
#[pg_guard]
extern "C" {
    pub fn errstart(
        elevel: ::std::os::raw::c_int,
        filename: PgPtr<::std::os::raw::c_char>,
        lineno: ::std::os::raw::c_int,
        funcname: PgPtr<::std::os::raw::c_char>,
        domain: PgPtr<::std::os::raw::c_char>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn errfinish(dummy: ::std::os::raw::c_int, ...);
}
#[pg_guard]
extern "C" {
    pub fn errcode(sqlerrcode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errcode_for_file_access() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errcode_for_socket_access() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errmsg(fmt: PgPtr<::std::os::raw::c_char>, ...) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errmsg_internal(fmt: PgPtr<::std::os::raw::c_char>, ...) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errmsg_plural(
        fmt_singular: PgPtr<::std::os::raw::c_char>,
        fmt_plural: PgPtr<::std::os::raw::c_char>,
        n: ::std::os::raw::c_ulong,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errdetail(fmt: PgPtr<::std::os::raw::c_char>, ...) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errdetail_internal(fmt: PgPtr<::std::os::raw::c_char>, ...) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errdetail_log(fmt: PgPtr<::std::os::raw::c_char>, ...) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errdetail_log_plural(
        fmt_singular: PgPtr<::std::os::raw::c_char>,
        fmt_plural: PgPtr<::std::os::raw::c_char>,
        n: ::std::os::raw::c_ulong,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errdetail_plural(
        fmt_singular: PgPtr<::std::os::raw::c_char>,
        fmt_plural: PgPtr<::std::os::raw::c_char>,
        n: ::std::os::raw::c_ulong,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errhint(fmt: PgPtr<::std::os::raw::c_char>, ...) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn set_errcontext_domain(domain: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errcontext_msg(fmt: PgPtr<::std::os::raw::c_char>, ...) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errhidestmt(hide_stmt: bool) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errhidecontext(hide_ctx: bool) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errfunction(funcname: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errposition(cursorpos: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn internalerrposition(cursorpos: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn internalerrquery(query: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn err_generic_string(
        field: ::std::os::raw::c_int,
        str_: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn geterrcode() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn geterrposition() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getinternalerrposition() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn elog_start(
        filename: PgPtr<::std::os::raw::c_char>,
        lineno: ::std::os::raw::c_int,
        funcname: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn elog_finish(elevel: ::std::os::raw::c_int, fmt: PgPtr<::std::os::raw::c_char>, ...);
}
#[pg_guard]
extern "C" {
    pub fn pre_format_elog_string(
        errnumber: ::std::os::raw::c_int,
        domain: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn format_elog_string(
        fmt: PgPtr<::std::os::raw::c_char>,
        ...
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[repr(C)]
pub struct ErrorContextCallback {
    pub previous: PgPtr<ErrorContextCallback>,
    pub callback: ::std::option::Option<unsafe extern "C" fn(arg: PgPtr<::std::os::raw::c_void>)>,
    pub arg: PgPtr<::std::os::raw::c_void>,
}
#[pg_guard]
extern "C" {
    pub static mut error_context_stack: PgPtr<ErrorContextCallback>;
}
#[pg_guard]
extern "C" {
    pub static mut PG_exception_stack: PgPtr<sigjmp_buf>;
}
#[repr(C)]
pub struct ErrorData {
    pub elevel: ::std::os::raw::c_int,
    pub output_to_server: bool,
    pub output_to_client: bool,
    pub show_funcname: bool,
    pub hide_stmt: bool,
    pub hide_ctx: bool,
    pub filename: PgPtr<::std::os::raw::c_char>,
    pub lineno: ::std::os::raw::c_int,
    pub funcname: PgPtr<::std::os::raw::c_char>,
    pub domain: PgPtr<::std::os::raw::c_char>,
    pub context_domain: PgPtr<::std::os::raw::c_char>,
    pub sqlerrcode: ::std::os::raw::c_int,
    pub message: PgPtr<::std::os::raw::c_char>,
    pub detail: PgPtr<::std::os::raw::c_char>,
    pub detail_log: PgPtr<::std::os::raw::c_char>,
    pub hint: PgPtr<::std::os::raw::c_char>,
    pub context: PgPtr<::std::os::raw::c_char>,
    pub message_id: PgPtr<::std::os::raw::c_char>,
    pub schema_name: PgPtr<::std::os::raw::c_char>,
    pub table_name: PgPtr<::std::os::raw::c_char>,
    pub column_name: PgPtr<::std::os::raw::c_char>,
    pub datatype_name: PgPtr<::std::os::raw::c_char>,
    pub constraint_name: PgPtr<::std::os::raw::c_char>,
    pub cursorpos: ::std::os::raw::c_int,
    pub internalpos: ::std::os::raw::c_int,
    pub internalquery: PgPtr<::std::os::raw::c_char>,
    pub saved_errno: ::std::os::raw::c_int,
    pub assoc_context: PgPtr<MemoryContextData>,
}
#[pg_guard]
extern "C" {
    pub fn EmitErrorReport();
}
#[pg_guard]
extern "C" {
    pub fn CopyErrorData() -> PgPtr<ErrorData>;
}
#[pg_guard]
extern "C" {
    pub fn FreeErrorData(edata: PgPtr<ErrorData>);
}
#[pg_guard]
extern "C" {
    pub fn FlushErrorState();
}
#[pg_guard]
extern "C" {
    pub fn ReThrowError(edata: PgPtr<ErrorData>);
}
#[pg_guard]
extern "C" {
    pub fn ThrowErrorData(edata: PgPtr<ErrorData>);
}
#[pg_guard]
extern "C" {
    pub fn GetErrorContextStack() -> PgPtr<::std::os::raw::c_char>;
}
pub type emit_log_hook_type = ::std::option::Option<unsafe extern "C" fn(edata: PgPtr<ErrorData>)>;
#[pg_guard]
extern "C" {
    pub static mut emit_log_hook: emit_log_hook_type;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum PGErrorVerbosity {
    PGERROR_TERSE = 0,
    PGERROR_DEFAULT = 1,
    PGERROR_VERBOSE = 2,
}
#[pg_guard]
extern "C" {
    pub static mut Log_error_verbosity: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut Log_line_prefix: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut Log_destination: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut Log_destination_string: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut syslog_sequence_numbers: bool;
}
#[pg_guard]
extern "C" {
    pub static mut syslog_split_messages: bool;
}
#[pg_guard]
extern "C" {
    pub fn DebugFileOpen();
}
#[pg_guard]
extern "C" {
    pub fn unpack_sql_state(sql_state: ::std::os::raw::c_int) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn in_error_recursion_trouble() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn set_syslog_parameters(
        ident: PgPtr<::std::os::raw::c_char>,
        facility: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn write_stderr(fmt: PgPtr<::std::os::raw::c_char>, ...);
}
pub type MemoryContext = PgPtr<MemoryContextData>;
pub type MemoryContextCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg: PgPtr<::std::os::raw::c_void>)>;
#[repr(C)]
pub struct MemoryContextCallback {
    pub func: MemoryContextCallbackFunction,
    pub arg: PgPtr<::std::os::raw::c_void>,
    pub next: PgPtr<MemoryContextCallback>,
}
#[pg_guard]
extern "C" {
    pub static mut CurrentMemoryContext: PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextAlloc(
        context: PgPtr<MemoryContextData>,
        size: Size,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextAllocZero(
        context: PgPtr<MemoryContextData>,
        size: Size,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextAllocZeroAligned(
        context: PgPtr<MemoryContextData>,
        size: Size,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextAllocExtended(
        context: PgPtr<MemoryContextData>,
        size: Size,
        flags: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn palloc_extended(
        size: Size,
        flags: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextAllocHuge(
        context: PgPtr<MemoryContextData>,
        size: Size,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn repalloc_huge(
        pointer: PgPtr<::std::os::raw::c_void>,
        size: Size,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextRegisterResetCallback(
        context: PgPtr<MemoryContextData>,
        cb: PgPtr<MemoryContextCallback>,
    );
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextStrdup(
        context: PgPtr<MemoryContextData>,
        string: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pstrdup(in_: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pnstrdup(in_: PgPtr<::std::os::raw::c_char>, len: Size)
        -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pchomp(in_: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn psprintf(fmt: PgPtr<::std::os::raw::c_char>, ...) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pvsnprintf(
        buf: PgPtr<::std::os::raw::c_char>,
        len: usize,
        fmt: PgPtr<::std::os::raw::c_char>,
        args: PgPtr<__va_list_tag>,
    ) -> usize;
}
#[repr(C)]
pub struct varatt_external {
    pub va_rawsize: int32,
    pub va_extsize: int32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
#[repr(C)]
pub struct varatt_indirect {
    pub pointer: PgPtr<varlena>,
}
#[repr(C)]
pub struct varatt_expanded {
    pub eohptr: PgPtr<ExpandedObjectHeader>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum vartag_external {
    VARTAG_INDIRECT = 1,
    VARTAG_EXPANDED_RO = 2,
    VARTAG_EXPANDED_RW = 3,
    VARTAG_ONDISK = 18,
}
#[repr(C)]
pub struct varattrib_4b {
    pub va_4byte: __BindgenUnionField<varattrib_4b__bindgen_ty_1>,
    pub va_compressed: __BindgenUnionField<varattrib_4b__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
pub struct varattrib_4b__bindgen_ty_1 {
    pub va_header: uint32,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct varattrib_4b__bindgen_ty_2 {
    pub va_header: uint32,
    pub va_rawsize: uint32,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct varattrib_1b {
    pub va_header: uint8,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct varattrib_1b_e {
    pub va_header: uint8,
    pub va_tag: uint8,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
pub type Datum = usize;
#[repr(C)]
pub struct NullableDatum {
    pub value: Datum,
    pub isnull: bool,
}
pub type fmNodePtr = PgPtr<Node>;
pub type fmAggrefPtr = PgPtr<Aggref>;
pub type fmExprContextCallbackFunction = ::std::option::Option<unsafe extern "C" fn(arg: Datum)>;
pub type fmStringInfo = PgPtr<StringInfoData>;
pub type FunctionCallInfo = PgPtr<FunctionCallInfoBaseData>;
pub type PGFunction =
    ::std::option::Option<unsafe extern "C" fn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum>;
#[repr(C)]
pub struct FmgrInfo {
    pub fn_addr: PGFunction,
    pub fn_oid: Oid,
    pub fn_nargs: ::std::os::raw::c_short,
    pub fn_strict: bool,
    pub fn_retset: bool,
    pub fn_stats: ::std::os::raw::c_uchar,
    pub fn_extra: PgPtr<::std::os::raw::c_void>,
    pub fn_mcxt: PgPtr<MemoryContextData>,
    pub fn_expr: PgPtr<Node>,
}
#[repr(C)]
pub struct FunctionCallInfoBaseData {
    pub flinfo: PgPtr<FmgrInfo>,
    pub context: PgPtr<Node>,
    pub resultinfo: PgPtr<Node>,
    pub fncollation: Oid,
    pub isnull: bool,
    pub nargs: ::std::os::raw::c_short,
    pub args: __IncompleteArrayField<NullableDatum>,
}
#[pg_guard]
extern "C" {
    pub fn fmgr_info(functionId: Oid, finfo: PgPtr<FmgrInfo>);
}
#[pg_guard]
extern "C" {
    pub fn fmgr_info_cxt(functionId: Oid, finfo: PgPtr<FmgrInfo>, mcxt: PgPtr<MemoryContextData>);
}
#[pg_guard]
extern "C" {
    pub fn fmgr_info_copy(
        dstinfo: PgPtr<FmgrInfo>,
        srcinfo: PgPtr<FmgrInfo>,
        destcxt: PgPtr<MemoryContextData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn fmgr_symbol(
        functionId: Oid,
        mod_: PgPtr<PgPtr<::std::os::raw::c_char>>,
        fn_: PgPtr<PgPtr<::std::os::raw::c_char>>,
    );
}
#[pg_guard]
extern "C" {
    pub fn pg_detoast_datum(datum: PgPtr<varlena>) -> PgPtr<varlena>;
}
#[pg_guard]
extern "C" {
    pub fn pg_detoast_datum_copy(datum: PgPtr<varlena>) -> PgPtr<varlena>;
}
#[pg_guard]
extern "C" {
    pub fn pg_detoast_datum_slice(
        datum: PgPtr<varlena>,
        first: int32,
        count: int32,
    ) -> PgPtr<varlena>;
}
#[pg_guard]
extern "C" {
    pub fn pg_detoast_datum_packed(datum: PgPtr<varlena>) -> PgPtr<varlena>;
}
#[repr(C)]
pub struct Pg_finfo_record {
    pub api_version: ::std::os::raw::c_int,
}
pub type PGFInfoFunction = ::std::option::Option<unsafe extern "C" fn() -> PgPtr<Pg_finfo_record>>;
#[repr(C)]
pub struct Pg_magic_struct {
    pub len: ::std::os::raw::c_int,
    pub version: ::std::os::raw::c_int,
    pub funcmaxargs: ::std::os::raw::c_int,
    pub indexmaxkeys: ::std::os::raw::c_int,
    pub namedatalen: ::std::os::raw::c_int,
    pub float4byval: ::std::os::raw::c_int,
    pub float8byval: ::std::os::raw::c_int,
}
pub type PGModuleMagicFunction =
    ::std::option::Option<unsafe extern "C" fn() -> PgPtr<Pg_magic_struct>>;
#[pg_guard]
extern "C" {
    pub fn DirectFunctionCall1Coll(func: PGFunction, collation: Oid, arg1: Datum) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn DirectFunctionCall2Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn DirectFunctionCall3Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn DirectFunctionCall4Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn DirectFunctionCall5Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn DirectFunctionCall6Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn DirectFunctionCall7Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn DirectFunctionCall8Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn DirectFunctionCall9Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
        arg9: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn CallerFInfoFunctionCall1(
        func: PGFunction,
        flinfo: PgPtr<FmgrInfo>,
        collation: Oid,
        arg1: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn CallerFInfoFunctionCall2(
        func: PGFunction,
        flinfo: PgPtr<FmgrInfo>,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn FunctionCall0Coll(flinfo: PgPtr<FmgrInfo>, collation: Oid) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn FunctionCall1Coll(flinfo: PgPtr<FmgrInfo>, collation: Oid, arg1: Datum) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn FunctionCall2Coll(
        flinfo: PgPtr<FmgrInfo>,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn FunctionCall3Coll(
        flinfo: PgPtr<FmgrInfo>,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn FunctionCall4Coll(
        flinfo: PgPtr<FmgrInfo>,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn FunctionCall5Coll(
        flinfo: PgPtr<FmgrInfo>,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn FunctionCall6Coll(
        flinfo: PgPtr<FmgrInfo>,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn FunctionCall7Coll(
        flinfo: PgPtr<FmgrInfo>,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn FunctionCall8Coll(
        flinfo: PgPtr<FmgrInfo>,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn FunctionCall9Coll(
        flinfo: PgPtr<FmgrInfo>,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
        arg9: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OidFunctionCall0Coll(functionId: Oid, collation: Oid) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OidFunctionCall1Coll(functionId: Oid, collation: Oid, arg1: Datum) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OidFunctionCall2Coll(functionId: Oid, collation: Oid, arg1: Datum, arg2: Datum)
        -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OidFunctionCall3Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OidFunctionCall4Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OidFunctionCall5Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OidFunctionCall6Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OidFunctionCall7Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OidFunctionCall8Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OidFunctionCall9Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
        arg9: Datum,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn InputFunctionCall(
        flinfo: PgPtr<FmgrInfo>,
        str_: PgPtr<::std::os::raw::c_char>,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OidInputFunctionCall(
        functionId: Oid,
        str_: PgPtr<::std::os::raw::c_char>,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OutputFunctionCall(flinfo: PgPtr<FmgrInfo>, val: Datum)
        -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn OidOutputFunctionCall(functionId: Oid, val: Datum) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn ReceiveFunctionCall(
        flinfo: PgPtr<FmgrInfo>,
        buf: PgPtr<StringInfoData>,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn OidReceiveFunctionCall(
        functionId: Oid,
        buf: PgPtr<StringInfoData>,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn SendFunctionCall(flinfo: PgPtr<FmgrInfo>, val: Datum) -> PgPtr<bytea>;
}
#[pg_guard]
extern "C" {
    pub fn OidSendFunctionCall(functionId: Oid, val: Datum) -> PgPtr<bytea>;
}
#[pg_guard]
extern "C" {
    pub fn fetch_finfo_record(
        filehandle: PgPtr<::std::os::raw::c_void>,
        funcname: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<Pg_finfo_record>;
}
#[pg_guard]
extern "C" {
    pub fn clear_external_function_hash(filehandle: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn fmgr_internal_function(proname: PgPtr<::std::os::raw::c_char>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_fn_expr_rettype(flinfo: PgPtr<FmgrInfo>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_fn_expr_argtype(flinfo: PgPtr<FmgrInfo>, argnum: ::std::os::raw::c_int) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_call_expr_argtype(expr: PgPtr<Node>, argnum: ::std::os::raw::c_int) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_fn_expr_arg_stable(flinfo: PgPtr<FmgrInfo>, argnum: ::std::os::raw::c_int) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_call_expr_arg_stable(expr: PgPtr<Node>, argnum: ::std::os::raw::c_int) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_fn_expr_variadic(flinfo: PgPtr<FmgrInfo>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn CheckFunctionValidatorAccess(validatorOid: Oid, functionOid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub static mut Dynamic_library_path: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn load_external_function(
        filename: PgPtr<::std::os::raw::c_char>,
        funcname: PgPtr<::std::os::raw::c_char>,
        signalNotFound: bool,
        filehandle: PgPtr<PgPtr<::std::os::raw::c_void>>,
    ) -> PGFunction;
}
#[pg_guard]
extern "C" {
    pub fn lookup_external_function(
        filehandle: PgPtr<::std::os::raw::c_void>,
        funcname: PgPtr<::std::os::raw::c_char>,
    ) -> PGFunction;
}
#[pg_guard]
extern "C" {
    pub fn load_file(filename: PgPtr<::std::os::raw::c_char>, restricted: bool);
}
#[pg_guard]
extern "C" {
    pub fn find_rendezvous_variable(
        varName: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<PgPtr<::std::os::raw::c_void>>;
}
#[pg_guard]
extern "C" {
    pub fn EstimateLibraryStateSpace() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn SerializeLibraryState(maxsize: Size, start_address: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn RestoreLibraryState(start_address: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn AggCheckCallContext(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
        aggcontext: PgPtr<PgPtr<MemoryContextData>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn AggGetAggref(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> PgPtr<Aggref>;
}
#[pg_guard]
extern "C" {
    pub fn AggGetTempMemoryContext(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub fn AggStateIsShared(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn AggRegisterCallback(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
        func: fmExprContextCallbackFunction,
        arg: Datum,
    );
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum FmgrHookEventType {
    FHET_START = 0,
    FHET_END = 1,
    FHET_ABORT = 2,
}
pub type needs_fmgr_hook_type = ::std::option::Option<unsafe extern "C" fn(fn_oid: Oid) -> bool>;
pub type fmgr_hook_type = ::std::option::Option<
    unsafe extern "C" fn(event: FmgrHookEventType, flinfo: PgPtr<FmgrInfo>, arg: PgPtr<Datum>),
>;
#[pg_guard]
extern "C" {
    pub static mut needs_fmgr_hook: needs_fmgr_hook_type;
}
#[pg_guard]
extern "C" {
    pub static mut fmgr_hook: fmgr_hook_type;
}
pub type AttrNumber = int16;
#[repr(C)]
pub struct FormData_pg_attribute {
    pub attrelid: Oid,
    pub attname: NameData,
    pub atttypid: Oid,
    pub attstattarget: int32,
    pub attlen: int16,
    pub attnum: int16,
    pub attndims: int32,
    pub attcacheoff: int32,
    pub atttypmod: int32,
    pub attbyval: bool,
    pub attstorage: ::std::os::raw::c_char,
    pub attalign: ::std::os::raw::c_char,
    pub attnotnull: bool,
    pub atthasdef: bool,
    pub atthasmissing: bool,
    pub attidentity: ::std::os::raw::c_char,
    pub attgenerated: ::std::os::raw::c_char,
    pub attisdropped: bool,
    pub attislocal: bool,
    pub attinhcount: int32,
    pub attcollation: Oid,
}
pub type Form_pg_attribute = PgPtr<FormData_pg_attribute>;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum NodeTag {
    T_Invalid = 0,
    T_IndexInfo = 1,
    T_ExprContext = 2,
    T_ProjectionInfo = 3,
    T_JunkFilter = 4,
    T_OnConflictSetState = 5,
    T_ResultRelInfo = 6,
    T_EState = 7,
    T_TupleTableSlot = 8,
    T_Plan = 9,
    T_Result = 10,
    T_ProjectSet = 11,
    T_ModifyTable = 12,
    T_Append = 13,
    T_MergeAppend = 14,
    T_RecursiveUnion = 15,
    T_BitmapAnd = 16,
    T_BitmapOr = 17,
    T_Scan = 18,
    T_SeqScan = 19,
    T_SampleScan = 20,
    T_IndexScan = 21,
    T_IndexOnlyScan = 22,
    T_BitmapIndexScan = 23,
    T_BitmapHeapScan = 24,
    T_TidScan = 25,
    T_SubqueryScan = 26,
    T_FunctionScan = 27,
    T_ValuesScan = 28,
    T_TableFuncScan = 29,
    T_CteScan = 30,
    T_NamedTuplestoreScan = 31,
    T_WorkTableScan = 32,
    T_ForeignScan = 33,
    T_CustomScan = 34,
    T_Join = 35,
    T_NestLoop = 36,
    T_MergeJoin = 37,
    T_HashJoin = 38,
    T_Material = 39,
    T_Sort = 40,
    T_Group = 41,
    T_Agg = 42,
    T_WindowAgg = 43,
    T_Unique = 44,
    T_Gather = 45,
    T_GatherMerge = 46,
    T_Hash = 47,
    T_SetOp = 48,
    T_LockRows = 49,
    T_Limit = 50,
    T_NestLoopParam = 51,
    T_PlanRowMark = 52,
    T_PartitionPruneInfo = 53,
    T_PartitionedRelPruneInfo = 54,
    T_PartitionPruneStepOp = 55,
    T_PartitionPruneStepCombine = 56,
    T_PlanInvalItem = 57,
    T_PlanState = 58,
    T_ResultState = 59,
    T_ProjectSetState = 60,
    T_ModifyTableState = 61,
    T_AppendState = 62,
    T_MergeAppendState = 63,
    T_RecursiveUnionState = 64,
    T_BitmapAndState = 65,
    T_BitmapOrState = 66,
    T_ScanState = 67,
    T_SeqScanState = 68,
    T_SampleScanState = 69,
    T_IndexScanState = 70,
    T_IndexOnlyScanState = 71,
    T_BitmapIndexScanState = 72,
    T_BitmapHeapScanState = 73,
    T_TidScanState = 74,
    T_SubqueryScanState = 75,
    T_FunctionScanState = 76,
    T_TableFuncScanState = 77,
    T_ValuesScanState = 78,
    T_CteScanState = 79,
    T_NamedTuplestoreScanState = 80,
    T_WorkTableScanState = 81,
    T_ForeignScanState = 82,
    T_CustomScanState = 83,
    T_JoinState = 84,
    T_NestLoopState = 85,
    T_MergeJoinState = 86,
    T_HashJoinState = 87,
    T_MaterialState = 88,
    T_SortState = 89,
    T_GroupState = 90,
    T_AggState = 91,
    T_WindowAggState = 92,
    T_UniqueState = 93,
    T_GatherState = 94,
    T_GatherMergeState = 95,
    T_HashState = 96,
    T_SetOpState = 97,
    T_LockRowsState = 98,
    T_LimitState = 99,
    T_Alias = 100,
    T_RangeVar = 101,
    T_TableFunc = 102,
    T_Expr = 103,
    T_Var = 104,
    T_Const = 105,
    T_Param = 106,
    T_Aggref = 107,
    T_GroupingFunc = 108,
    T_WindowFunc = 109,
    T_SubscriptingRef = 110,
    T_FuncExpr = 111,
    T_NamedArgExpr = 112,
    T_OpExpr = 113,
    T_DistinctExpr = 114,
    T_NullIfExpr = 115,
    T_ScalarArrayOpExpr = 116,
    T_BoolExpr = 117,
    T_SubLink = 118,
    T_SubPlan = 119,
    T_AlternativeSubPlan = 120,
    T_FieldSelect = 121,
    T_FieldStore = 122,
    T_RelabelType = 123,
    T_CoerceViaIO = 124,
    T_ArrayCoerceExpr = 125,
    T_ConvertRowtypeExpr = 126,
    T_CollateExpr = 127,
    T_CaseExpr = 128,
    T_CaseWhen = 129,
    T_CaseTestExpr = 130,
    T_ArrayExpr = 131,
    T_RowExpr = 132,
    T_RowCompareExpr = 133,
    T_CoalesceExpr = 134,
    T_MinMaxExpr = 135,
    T_SQLValueFunction = 136,
    T_XmlExpr = 137,
    T_NullTest = 138,
    T_BooleanTest = 139,
    T_CoerceToDomain = 140,
    T_CoerceToDomainValue = 141,
    T_SetToDefault = 142,
    T_CurrentOfExpr = 143,
    T_NextValueExpr = 144,
    T_InferenceElem = 145,
    T_TargetEntry = 146,
    T_RangeTblRef = 147,
    T_JoinExpr = 148,
    T_FromExpr = 149,
    T_OnConflictExpr = 150,
    T_IntoClause = 151,
    T_ExprState = 152,
    T_AggrefExprState = 153,
    T_WindowFuncExprState = 154,
    T_SetExprState = 155,
    T_SubPlanState = 156,
    T_AlternativeSubPlanState = 157,
    T_DomainConstraintState = 158,
    T_PlannerInfo = 159,
    T_PlannerGlobal = 160,
    T_RelOptInfo = 161,
    T_IndexOptInfo = 162,
    T_ForeignKeyOptInfo = 163,
    T_ParamPathInfo = 164,
    T_Path = 165,
    T_IndexPath = 166,
    T_BitmapHeapPath = 167,
    T_BitmapAndPath = 168,
    T_BitmapOrPath = 169,
    T_TidPath = 170,
    T_SubqueryScanPath = 171,
    T_ForeignPath = 172,
    T_CustomPath = 173,
    T_NestPath = 174,
    T_MergePath = 175,
    T_HashPath = 176,
    T_AppendPath = 177,
    T_MergeAppendPath = 178,
    T_GroupResultPath = 179,
    T_MaterialPath = 180,
    T_UniquePath = 181,
    T_GatherPath = 182,
    T_GatherMergePath = 183,
    T_ProjectionPath = 184,
    T_ProjectSetPath = 185,
    T_SortPath = 186,
    T_GroupPath = 187,
    T_UpperUniquePath = 188,
    T_AggPath = 189,
    T_GroupingSetsPath = 190,
    T_MinMaxAggPath = 191,
    T_WindowAggPath = 192,
    T_SetOpPath = 193,
    T_RecursiveUnionPath = 194,
    T_LockRowsPath = 195,
    T_ModifyTablePath = 196,
    T_LimitPath = 197,
    T_EquivalenceClass = 198,
    T_EquivalenceMember = 199,
    T_PathKey = 200,
    T_PathTarget = 201,
    T_RestrictInfo = 202,
    T_IndexClause = 203,
    T_PlaceHolderVar = 204,
    T_SpecialJoinInfo = 205,
    T_AppendRelInfo = 206,
    T_PlaceHolderInfo = 207,
    T_MinMaxAggInfo = 208,
    T_PlannerParamItem = 209,
    T_RollupData = 210,
    T_GroupingSetData = 211,
    T_StatisticExtInfo = 212,
    T_MemoryContext = 213,
    T_AllocSetContext = 214,
    T_SlabContext = 215,
    T_GenerationContext = 216,
    T_Value = 217,
    T_Integer = 218,
    T_Float = 219,
    T_String = 220,
    T_BitString = 221,
    T_Null = 222,
    T_List = 223,
    T_IntList = 224,
    T_OidList = 225,
    T_ExtensibleNode = 226,
    T_RawStmt = 227,
    T_Query = 228,
    T_PlannedStmt = 229,
    T_InsertStmt = 230,
    T_DeleteStmt = 231,
    T_UpdateStmt = 232,
    T_SelectStmt = 233,
    T_AlterTableStmt = 234,
    T_AlterTableCmd = 235,
    T_AlterDomainStmt = 236,
    T_SetOperationStmt = 237,
    T_GrantStmt = 238,
    T_GrantRoleStmt = 239,
    T_AlterDefaultPrivilegesStmt = 240,
    T_ClosePortalStmt = 241,
    T_ClusterStmt = 242,
    T_CopyStmt = 243,
    T_CreateStmt = 244,
    T_DefineStmt = 245,
    T_DropStmt = 246,
    T_TruncateStmt = 247,
    T_CommentStmt = 248,
    T_FetchStmt = 249,
    T_IndexStmt = 250,
    T_CreateFunctionStmt = 251,
    T_AlterFunctionStmt = 252,
    T_DoStmt = 253,
    T_RenameStmt = 254,
    T_RuleStmt = 255,
    T_NotifyStmt = 256,
    T_ListenStmt = 257,
    T_UnlistenStmt = 258,
    T_TransactionStmt = 259,
    T_ViewStmt = 260,
    T_LoadStmt = 261,
    T_CreateDomainStmt = 262,
    T_CreatedbStmt = 263,
    T_DropdbStmt = 264,
    T_VacuumStmt = 265,
    T_ExplainStmt = 266,
    T_CreateTableAsStmt = 267,
    T_CreateSeqStmt = 268,
    T_AlterSeqStmt = 269,
    T_VariableSetStmt = 270,
    T_VariableShowStmt = 271,
    T_DiscardStmt = 272,
    T_CreateTrigStmt = 273,
    T_CreatePLangStmt = 274,
    T_CreateRoleStmt = 275,
    T_AlterRoleStmt = 276,
    T_DropRoleStmt = 277,
    T_LockStmt = 278,
    T_ConstraintsSetStmt = 279,
    T_ReindexStmt = 280,
    T_CheckPointStmt = 281,
    T_CreateSchemaStmt = 282,
    T_AlterDatabaseStmt = 283,
    T_AlterDatabaseSetStmt = 284,
    T_AlterRoleSetStmt = 285,
    T_CreateConversionStmt = 286,
    T_CreateCastStmt = 287,
    T_CreateOpClassStmt = 288,
    T_CreateOpFamilyStmt = 289,
    T_AlterOpFamilyStmt = 290,
    T_PrepareStmt = 291,
    T_ExecuteStmt = 292,
    T_DeallocateStmt = 293,
    T_DeclareCursorStmt = 294,
    T_CreateTableSpaceStmt = 295,
    T_DropTableSpaceStmt = 296,
    T_AlterObjectDependsStmt = 297,
    T_AlterObjectSchemaStmt = 298,
    T_AlterOwnerStmt = 299,
    T_AlterOperatorStmt = 300,
    T_DropOwnedStmt = 301,
    T_ReassignOwnedStmt = 302,
    T_CompositeTypeStmt = 303,
    T_CreateEnumStmt = 304,
    T_CreateRangeStmt = 305,
    T_AlterEnumStmt = 306,
    T_AlterTSDictionaryStmt = 307,
    T_AlterTSConfigurationStmt = 308,
    T_CreateFdwStmt = 309,
    T_AlterFdwStmt = 310,
    T_CreateForeignServerStmt = 311,
    T_AlterForeignServerStmt = 312,
    T_CreateUserMappingStmt = 313,
    T_AlterUserMappingStmt = 314,
    T_DropUserMappingStmt = 315,
    T_AlterTableSpaceOptionsStmt = 316,
    T_AlterTableMoveAllStmt = 317,
    T_SecLabelStmt = 318,
    T_CreateForeignTableStmt = 319,
    T_ImportForeignSchemaStmt = 320,
    T_CreateExtensionStmt = 321,
    T_AlterExtensionStmt = 322,
    T_AlterExtensionContentsStmt = 323,
    T_CreateEventTrigStmt = 324,
    T_AlterEventTrigStmt = 325,
    T_RefreshMatViewStmt = 326,
    T_ReplicaIdentityStmt = 327,
    T_AlterSystemStmt = 328,
    T_CreatePolicyStmt = 329,
    T_AlterPolicyStmt = 330,
    T_CreateTransformStmt = 331,
    T_CreateAmStmt = 332,
    T_CreatePublicationStmt = 333,
    T_AlterPublicationStmt = 334,
    T_CreateSubscriptionStmt = 335,
    T_AlterSubscriptionStmt = 336,
    T_DropSubscriptionStmt = 337,
    T_CreateStatsStmt = 338,
    T_AlterCollationStmt = 339,
    T_CallStmt = 340,
    T_A_Expr = 341,
    T_ColumnRef = 342,
    T_ParamRef = 343,
    T_A_Const = 344,
    T_FuncCall = 345,
    T_A_Star = 346,
    T_A_Indices = 347,
    T_A_Indirection = 348,
    T_A_ArrayExpr = 349,
    T_ResTarget = 350,
    T_MultiAssignRef = 351,
    T_TypeCast = 352,
    T_CollateClause = 353,
    T_SortBy = 354,
    T_WindowDef = 355,
    T_RangeSubselect = 356,
    T_RangeFunction = 357,
    T_RangeTableSample = 358,
    T_RangeTableFunc = 359,
    T_RangeTableFuncCol = 360,
    T_TypeName = 361,
    T_ColumnDef = 362,
    T_IndexElem = 363,
    T_Constraint = 364,
    T_DefElem = 365,
    T_RangeTblEntry = 366,
    T_RangeTblFunction = 367,
    T_TableSampleClause = 368,
    T_WithCheckOption = 369,
    T_SortGroupClause = 370,
    T_GroupingSet = 371,
    T_WindowClause = 372,
    T_ObjectWithArgs = 373,
    T_AccessPriv = 374,
    T_CreateOpClassItem = 375,
    T_TableLikeClause = 376,
    T_FunctionParameter = 377,
    T_LockingClause = 378,
    T_RowMarkClause = 379,
    T_XmlSerialize = 380,
    T_WithClause = 381,
    T_InferClause = 382,
    T_OnConflictClause = 383,
    T_CommonTableExpr = 384,
    T_RoleSpec = 385,
    T_TriggerTransition = 386,
    T_PartitionElem = 387,
    T_PartitionSpec = 388,
    T_PartitionBoundSpec = 389,
    T_PartitionRangeDatum = 390,
    T_PartitionCmd = 391,
    T_VacuumRelation = 392,
    T_IdentifySystemCmd = 393,
    T_BaseBackupCmd = 394,
    T_CreateReplicationSlotCmd = 395,
    T_DropReplicationSlotCmd = 396,
    T_StartReplicationCmd = 397,
    T_TimeLineHistoryCmd = 398,
    T_SQLCmd = 399,
    T_TriggerData = 400,
    T_EventTriggerData = 401,
    T_ReturnSetInfo = 402,
    T_WindowObjectData = 403,
    T_TIDBitmap = 404,
    T_InlineCodeBlock = 405,
    T_FdwRoutine = 406,
    T_IndexAmRoutine = 407,
    T_TableAmRoutine = 408,
    T_TsmRoutine = 409,
    T_ForeignKeyCacheInfo = 410,
    T_CallContext = 411,
    T_SupportRequestSimplify = 412,
    T_SupportRequestSelectivity = 413,
    T_SupportRequestCost = 414,
    T_SupportRequestRows = 415,
    T_SupportRequestIndexCondition = 416,
}
#[repr(C)]
pub struct Node {
    pub type_: NodeTag,
}
#[pg_guard]
extern "C" {
    pub fn outNode(str_: PgPtr<StringInfoData>, obj: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn outToken(str_: PgPtr<StringInfoData>, s: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn outBitmapset(str_: PgPtr<StringInfoData>, bms: PgPtr<Bitmapset>);
}
#[pg_guard]
extern "C" {
    pub fn outDatum(
        str_: PgPtr<StringInfoData>,
        value: usize,
        typlen: ::std::os::raw::c_int,
        typbyval: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn nodeToString(obj: PgPtr<::std::os::raw::c_void>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn bmsToString(bms: PgPtr<Bitmapset>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn stringToNode(str_: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn readBitmapset() -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn readDatum(typbyval: bool) -> usize;
}
#[pg_guard]
extern "C" {
    pub fn readBoolCols(numCols: ::std::os::raw::c_int) -> PgPtr<bool>;
}
#[pg_guard]
extern "C" {
    pub fn readIntCols(numCols: ::std::os::raw::c_int) -> PgPtr<::std::os::raw::c_int>;
}
#[pg_guard]
extern "C" {
    pub fn readOidCols(numCols: ::std::os::raw::c_int) -> PgPtr<Oid>;
}
#[pg_guard]
extern "C" {
    pub fn readAttrNumberCols(numCols: ::std::os::raw::c_int) -> PgPtr<int16>;
}
#[pg_guard]
extern "C" {
    pub fn copyObjectImpl(obj: PgPtr<::std::os::raw::c_void>) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn equal(a: PgPtr<::std::os::raw::c_void>, b: PgPtr<::std::os::raw::c_void>) -> bool;
}
pub type Selectivity = f64;
pub type Cost = f64;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum CmdType {
    CMD_UNKNOWN = 0,
    CMD_SELECT = 1,
    CMD_UPDATE = 2,
    CMD_INSERT = 3,
    CMD_DELETE = 4,
    CMD_UTILITY = 5,
    CMD_NOTHING = 6,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum JoinType {
    JOIN_INNER = 0,
    JOIN_LEFT = 1,
    JOIN_FULL = 2,
    JOIN_RIGHT = 3,
    JOIN_SEMI = 4,
    JOIN_ANTI = 5,
    JOIN_UNIQUE_OUTER = 6,
    JOIN_UNIQUE_INNER = 7,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum AggStrategy {
    AGG_PLAIN = 0,
    AGG_SORTED = 1,
    AGG_HASHED = 2,
    AGG_MIXED = 3,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum AggSplit {
    AGGSPLIT_SIMPLE = 0,
    AGGSPLIT_INITIAL_SERIAL = 6,
    AGGSPLIT_FINAL_DESERIAL = 9,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SetOpCmd {
    SETOPCMD_INTERSECT = 0,
    SETOPCMD_INTERSECT_ALL = 1,
    SETOPCMD_EXCEPT = 2,
    SETOPCMD_EXCEPT_ALL = 3,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SetOpStrategy {
    SETOP_SORTED = 0,
    SETOP_HASHED = 1,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum OnConflictAction {
    ONCONFLICT_NONE = 0,
    ONCONFLICT_NOTHING = 1,
    ONCONFLICT_UPDATE = 2,
}
#[repr(C)]
pub struct List {
    pub type_: NodeTag,
    pub length: ::std::os::raw::c_int,
    pub head: PgPtr<ListCell>,
    pub tail: PgPtr<ListCell>,
}
#[repr(C)]
pub struct ListCell {
    pub data: ListCell__bindgen_ty_1,
    pub next: PgPtr<ListCell>,
}
#[repr(C)]
pub struct ListCell__bindgen_ty_1 {
    pub ptr_value: __BindgenUnionField<PgPtr<::std::os::raw::c_void>>,
    pub int_value: __BindgenUnionField<::std::os::raw::c_int>,
    pub oid_value: __BindgenUnionField<Oid>,
    pub bindgen_union_field: u64,
}
#[pg_guard]
extern "C" {
    pub fn lappend(list: PgPtr<List>, datum: PgPtr<::std::os::raw::c_void>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn lappend_int(list: PgPtr<List>, datum: ::std::os::raw::c_int) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn lappend_oid(list: PgPtr<List>, datum: Oid) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn lappend_cell(
        list: PgPtr<List>,
        prev: PgPtr<ListCell>,
        datum: PgPtr<::std::os::raw::c_void>,
    ) -> PgPtr<ListCell>;
}
#[pg_guard]
extern "C" {
    pub fn lappend_cell_int(
        list: PgPtr<List>,
        prev: PgPtr<ListCell>,
        datum: ::std::os::raw::c_int,
    ) -> PgPtr<ListCell>;
}
#[pg_guard]
extern "C" {
    pub fn lappend_cell_oid(
        list: PgPtr<List>,
        prev: PgPtr<ListCell>,
        datum: Oid,
    ) -> PgPtr<ListCell>;
}
#[pg_guard]
extern "C" {
    pub fn lcons(datum: PgPtr<::std::os::raw::c_void>, list: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn lcons_int(datum: ::std::os::raw::c_int, list: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn lcons_oid(datum: Oid, list: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_concat(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_truncate(list: PgPtr<List>, new_size: ::std::os::raw::c_int) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_nth_cell(list: PgPtr<List>, n: ::std::os::raw::c_int) -> PgPtr<ListCell>;
}
#[pg_guard]
extern "C" {
    pub fn list_nth(list: PgPtr<List>, n: ::std::os::raw::c_int) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn list_nth_int(list: PgPtr<List>, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn list_nth_oid(list: PgPtr<List>, n: ::std::os::raw::c_int) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn list_member(list: PgPtr<List>, datum: PgPtr<::std::os::raw::c_void>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn list_member_ptr(list: PgPtr<List>, datum: PgPtr<::std::os::raw::c_void>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn list_member_int(list: PgPtr<List>, datum: ::std::os::raw::c_int) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn list_member_oid(list: PgPtr<List>, datum: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn list_delete(list: PgPtr<List>, datum: PgPtr<::std::os::raw::c_void>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_delete_ptr(list: PgPtr<List>, datum: PgPtr<::std::os::raw::c_void>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_delete_int(list: PgPtr<List>, datum: ::std::os::raw::c_int) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_delete_oid(list: PgPtr<List>, datum: Oid) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_delete_first(list: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_delete_cell(
        list: PgPtr<List>,
        cell: PgPtr<ListCell>,
        prev: PgPtr<ListCell>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_union(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_union_ptr(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_union_int(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_union_oid(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_intersection(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_intersection_int(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_difference(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_difference_ptr(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_difference_int(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_difference_oid(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_append_unique(
        list: PgPtr<List>,
        datum: PgPtr<::std::os::raw::c_void>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_append_unique_ptr(
        list: PgPtr<List>,
        datum: PgPtr<::std::os::raw::c_void>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_append_unique_int(list: PgPtr<List>, datum: ::std::os::raw::c_int) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_append_unique_oid(list: PgPtr<List>, datum: Oid) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_concat_unique(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_concat_unique_ptr(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_concat_unique_int(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_concat_unique_oid(list1: PgPtr<List>, list2: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_free(list: PgPtr<List>);
}
#[pg_guard]
extern "C" {
    pub fn list_free_deep(list: PgPtr<List>);
}
#[pg_guard]
extern "C" {
    pub fn list_copy(list: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn list_copy_tail(list: PgPtr<List>, nskip: ::std::os::raw::c_int) -> PgPtr<List>;
}
pub type list_qsort_comparator = ::std::option::Option<
    unsafe extern "C" fn(
        a: PgPtr<::std::os::raw::c_void>,
        b: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int,
>;
#[pg_guard]
extern "C" {
    pub fn list_qsort(list: PgPtr<List>, cmp: list_qsort_comparator) -> PgPtr<List>;
}
#[repr(C)]
pub struct AttrDefault {
    pub adnum: AttrNumber,
    pub adbin: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct ConstrCheck {
    pub ccname: PgPtr<::std::os::raw::c_char>,
    pub ccbin: PgPtr<::std::os::raw::c_char>,
    pub ccvalid: bool,
    pub ccnoinherit: bool,
}
#[repr(C)]
pub struct TupleConstr {
    pub defval: PgPtr<AttrDefault>,
    pub check: PgPtr<ConstrCheck>,
    pub missing: PgPtr<AttrMissing>,
    pub num_defval: uint16,
    pub num_check: uint16,
    pub has_not_null: bool,
    pub has_generated_stored: bool,
}
#[repr(C)]
pub struct TupleDescData {
    pub natts: ::std::os::raw::c_int,
    pub tdtypeid: Oid,
    pub tdtypmod: int32,
    pub tdrefcount: ::std::os::raw::c_int,
    pub constr: PgPtr<TupleConstr>,
    pub attrs: __IncompleteArrayField<FormData_pg_attribute>,
}
pub type TupleDesc = PgPtr<TupleDescData>;
#[pg_guard]
extern "C" {
    pub fn CreateTemplateTupleDesc(natts: ::std::os::raw::c_int) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn CreateTupleDesc(
        natts: ::std::os::raw::c_int,
        attrs: PgPtr<PgPtr<FormData_pg_attribute>>,
    ) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn CreateTupleDescCopy(tupdesc: PgPtr<TupleDescData>) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn CreateTupleDescCopyConstr(tupdesc: PgPtr<TupleDescData>) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn TupleDescCopy(dst: PgPtr<TupleDescData>, src: PgPtr<TupleDescData>);
}
#[pg_guard]
extern "C" {
    pub fn TupleDescCopyEntry(
        dst: PgPtr<TupleDescData>,
        dstAttno: AttrNumber,
        src: PgPtr<TupleDescData>,
        srcAttno: AttrNumber,
    );
}
#[pg_guard]
extern "C" {
    pub fn FreeTupleDesc(tupdesc: PgPtr<TupleDescData>);
}
#[pg_guard]
extern "C" {
    pub fn IncrTupleDescRefCount(tupdesc: PgPtr<TupleDescData>);
}
#[pg_guard]
extern "C" {
    pub fn DecrTupleDescRefCount(tupdesc: PgPtr<TupleDescData>);
}
#[pg_guard]
extern "C" {
    pub fn equalTupleDescs(tupdesc1: PgPtr<TupleDescData>, tupdesc2: PgPtr<TupleDescData>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn hashTupleDesc(tupdesc: PgPtr<TupleDescData>) -> uint32;
}
#[pg_guard]
extern "C" {
    pub fn TupleDescInitEntry(
        desc: PgPtr<TupleDescData>,
        attributeNumber: AttrNumber,
        attributeName: PgPtr<::std::os::raw::c_char>,
        oidtypeid: Oid,
        typmod: int32,
        attdim: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn TupleDescInitBuiltinEntry(
        desc: PgPtr<TupleDescData>,
        attributeNumber: AttrNumber,
        attributeName: PgPtr<::std::os::raw::c_char>,
        oidtypeid: Oid,
        typmod: int32,
        attdim: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn TupleDescInitEntryCollation(
        desc: PgPtr<TupleDescData>,
        attributeNumber: AttrNumber,
        collationid: Oid,
    );
}
#[pg_guard]
extern "C" {
    pub fn BuildDescForRelation(schema: PgPtr<List>) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn BuildDescFromLists(
        names: PgPtr<List>,
        types: PgPtr<List>,
        typmods: PgPtr<List>,
        collations: PgPtr<List>,
    ) -> PgPtr<TupleDescData>;
}
pub type BlockNumber = uint32;
#[repr(C)]
pub struct BlockIdData {
    pub bi_hi: uint16,
    pub bi_lo: uint16,
}
pub type BlockId = PgPtr<BlockIdData>;
#[repr(C)]
#[repr(align(4))]
pub struct ItemIdData {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl ItemIdData {
    #[inline]
    pub fn lp_off(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_lp_off(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_lp_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_len(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_lp_len(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lp_off: ::std::os::raw::c_uint,
        lp_flags: ::std::os::raw::c_uint,
        lp_len: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let lp_off: u32 = unsafe { ::std::mem::transmute(lp_off) };
            lp_off as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let lp_flags: u32 = unsafe { ::std::mem::transmute(lp_flags) };
            lp_flags as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let lp_len: u32 = unsafe { ::std::mem::transmute(lp_len) };
            lp_len as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ItemId = PgPtr<ItemIdData>;
pub type ItemOffset = uint16;
pub type ItemLength = uint16;
pub type OffsetNumber = uint16;
#[repr(C, packed(2))]
pub struct ItemPointerData {
    pub ip_blkid: BlockIdData,
    pub ip_posid: OffsetNumber,
}
pub type ItemPointer = PgPtr<ItemPointerData>;
#[pg_guard]
extern "C" {
    pub fn ItemPointerEquals(
        pointer1: PgPtr<ItemPointerData>,
        pointer2: PgPtr<ItemPointerData>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ItemPointerCompare(arg1: PgPtr<ItemPointerData>, arg2: PgPtr<ItemPointerData>) -> int32;
}
pub type HeapTupleHeader = PgPtr<HeapTupleHeaderData>;
pub type MinimalTuple = PgPtr<MinimalTupleData>;
#[repr(C)]
pub struct HeapTupleData {
    pub t_len: uint32,
    pub t_self: ItemPointerData,
    pub t_tableOid: Oid,
    pub t_data: PgPtr<HeapTupleHeaderData>,
}
pub type HeapTuple = PgPtr<HeapTupleData>;
#[pg_guard]
extern "C" {
    pub fn HeapTupleHeaderGetCmin(tup: PgPtr<HeapTupleHeaderData>) -> CommandId;
}
#[pg_guard]
extern "C" {
    pub fn HeapTupleHeaderGetCmax(tup: PgPtr<HeapTupleHeaderData>) -> CommandId;
}
#[pg_guard]
extern "C" {
    pub fn HeapTupleHeaderAdjustCmax(
        tup: PgPtr<HeapTupleHeaderData>,
        cmax: PgPtr<CommandId>,
        iscombo: PgPtr<bool>,
    );
}
#[pg_guard]
extern "C" {
    pub fn HeapTupleGetUpdateXid(tuple: PgPtr<HeapTupleHeaderData>) -> TransactionId;
}
#[repr(C)]
pub struct flock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
}
#[repr(C)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
pub struct flocktimeout {
    pub fl: flock,
    pub timeout: timespec,
}
#[repr(C)]
pub struct radvisory {
    pub ra_offset: off_t,
    pub ra_count: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct fcodeblobs {
    pub f_cd_hash: PgPtr<::std::os::raw::c_void>,
    pub f_hash_size: usize,
    pub f_cd_buffer: PgPtr<::std::os::raw::c_void>,
    pub f_cd_size: usize,
    pub f_out_size: PgPtr<::std::os::raw::c_uint>,
    pub f_arch: ::std::os::raw::c_int,
    pub __padding: ::std::os::raw::c_int,
}
pub type fcodeblobs_t = fcodeblobs;
#[repr(C)]
pub struct fsignatures {
    pub fs_file_start: off_t,
    pub fs_blob_start: PgPtr<::std::os::raw::c_void>,
    pub fs_blob_size: usize,
}
pub type fsignatures_t = fsignatures;
#[repr(C)]
pub struct fchecklv {
    pub lv_file_start: off_t,
    pub lv_error_message_size: usize,
    pub lv_error_message: PgPtr<::std::os::raw::c_void>,
}
pub type fchecklv_t = fchecklv;
#[repr(C)]
pub struct fstore {
    pub fst_flags: ::std::os::raw::c_uint,
    pub fst_posmode: ::std::os::raw::c_int,
    pub fst_offset: off_t,
    pub fst_length: off_t,
    pub fst_bytesalloc: off_t,
}
pub type fstore_t = fstore;
#[repr(C)]
pub struct fpunchhole {
    pub fp_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fp_offset: off_t,
    pub fp_length: off_t,
}
pub type fpunchhole_t = fpunchhole;
#[repr(C)]
pub struct ftrimactivefile {
    pub fta_offset: off_t,
    pub fta_length: off_t,
}
pub type ftrimactivefile_t = ftrimactivefile;
#[repr(C)]
pub struct fspecread {
    pub fsr_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fsr_offset: off_t,
    pub fsr_length: off_t,
}
pub type fspecread_t = fspecread;
#[repr(C)]
pub struct fbootstraptransfer {
    pub fbt_offset: off_t,
    pub fbt_length: usize,
    pub fbt_buffer: PgPtr<::std::os::raw::c_void>,
}
pub type fbootstraptransfer_t = fbootstraptransfer;
#[repr(C, packed(4))]
pub struct log2phys {
    pub l2p_flags: ::std::os::raw::c_uint,
    pub l2p_contigbytes: off_t,
    pub l2p_devoffset: off_t,
}
#[repr(C)]
pub struct _filesec {
    _unused: [u8; 0],
}
pub type filesec_t = PgPtr<_filesec>;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum filesec_property_t {
    FILESEC_OWNER = 1,
    FILESEC_GROUP = 2,
    FILESEC_UUID = 3,
    FILESEC_MODE = 4,
    FILESEC_ACL = 5,
    FILESEC_GRPUUID = 6,
    FILESEC_ACL_RAW = 100,
    FILESEC_ACL_ALLOCSIZE = 101,
}
#[pg_guard]
extern "C" {
    pub fn open(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn openat(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn creat(arg1: PgPtr<::std::os::raw::c_char>, arg2: mode_t) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn fcntl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn openx_np(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: ::std::os::raw::c_int,
        arg3: PgPtr<_filesec>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn open_dprotected_np(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn flock(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn filesec_init() -> PgPtr<_filesec>;
}
#[pg_guard]
extern "C" {
    pub fn filesec_dup(arg1: PgPtr<_filesec>) -> PgPtr<_filesec>;
}
#[pg_guard]
extern "C" {
    pub fn filesec_free(arg1: PgPtr<_filesec>);
}
#[pg_guard]
extern "C" {
    pub fn filesec_get_property(
        arg1: PgPtr<_filesec>,
        arg2: filesec_property_t,
        arg3: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn filesec_query_property(
        arg1: PgPtr<_filesec>,
        arg2: filesec_property_t,
        arg3: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn filesec_set_property(
        arg1: PgPtr<_filesec>,
        arg2: filesec_property_t,
        arg3: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn filesec_unset_property(
        arg1: PgPtr<_filesec>,
        arg2: filesec_property_t,
    ) -> ::std::os::raw::c_int;
}
pub type XLogRecPtr = uint64;
pub type XLogSegNo = uint64;
pub type TimeLineID = uint32;
pub type RepOriginId = uint16;
#[repr(C)]
pub struct FullTransactionId {
    pub value: uint64,
}
#[repr(C)]
pub struct VariableCacheData {
    pub nextOid: Oid,
    pub oidCount: uint32,
    pub nextFullXid: FullTransactionId,
    pub oldestXid: TransactionId,
    pub xidVacLimit: TransactionId,
    pub xidWarnLimit: TransactionId,
    pub xidStopLimit: TransactionId,
    pub xidWrapLimit: TransactionId,
    pub oldestXidDB: Oid,
    pub oldestCommitTsXid: TransactionId,
    pub newestCommitTsXid: TransactionId,
    pub latestCompletedXid: TransactionId,
    pub oldestClogXid: TransactionId,
}
pub type VariableCache = PgPtr<VariableCacheData>;
#[pg_guard]
extern "C" {
    pub fn TransactionStartedDuringRecovery() -> bool;
}
#[pg_guard]
extern "C" {
    pub static mut ShmemVariableCache: PgPtr<VariableCacheData>;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdDidCommit(transactionId: TransactionId) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdDidAbort(transactionId: TransactionId) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdIsKnownCompleted(transactionId: TransactionId) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdAbort(transactionId: TransactionId);
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdCommitTree(
        xid: TransactionId,
        nxids: ::std::os::raw::c_int,
        xids: PgPtr<TransactionId>,
    );
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdAsyncCommitTree(
        xid: TransactionId,
        nxids: ::std::os::raw::c_int,
        xids: PgPtr<TransactionId>,
        lsn: XLogRecPtr,
    );
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdAbortTree(
        xid: TransactionId,
        nxids: ::std::os::raw::c_int,
        xids: PgPtr<TransactionId>,
    );
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdPrecedes(id1: TransactionId, id2: TransactionId) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdPrecedesOrEquals(id1: TransactionId, id2: TransactionId) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdFollows(id1: TransactionId, id2: TransactionId) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdFollowsOrEquals(id1: TransactionId, id2: TransactionId) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdLatest(
        mainxid: TransactionId,
        nxids: ::std::os::raw::c_int,
        xids: PgPtr<TransactionId>,
    ) -> TransactionId;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdGetCommitLSN(xid: TransactionId) -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn GetNewTransactionId(isSubXact: bool) -> FullTransactionId;
}
#[pg_guard]
extern "C" {
    pub fn AdvanceNextFullTransactionIdPastXid(xid: TransactionId);
}
#[pg_guard]
extern "C" {
    pub fn ReadNextFullTransactionId() -> FullTransactionId;
}
#[pg_guard]
extern "C" {
    pub fn SetTransactionIdLimit(oldest_datfrozenxid: TransactionId, oldest_datoid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn AdvanceOldestClogXid(oldest_datfrozenxid: TransactionId);
}
#[pg_guard]
extern "C" {
    pub fn ForceTransactionIdLimitUpdate() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetNewObjectId() -> Oid;
}
pub type Item = PgPtr<::std::os::raw::c_char>;
pub type Page = PgPtr<::std::os::raw::c_char>;
pub type LocationIndex = uint16;
#[repr(C)]
pub struct PageXLogRecPtr {
    pub xlogid: uint32,
    pub xrecoff: uint32,
}
#[repr(C)]
pub struct PageHeaderData {
    pub pd_lsn: PageXLogRecPtr,
    pub pd_checksum: uint16,
    pub pd_flags: uint16,
    pub pd_lower: LocationIndex,
    pub pd_upper: LocationIndex,
    pub pd_special: LocationIndex,
    pub pd_pagesize_version: uint16,
    pub pd_prune_xid: TransactionId,
    pub pd_linp: __IncompleteArrayField<ItemIdData>,
}
pub type PageHeader = PgPtr<PageHeaderData>;
#[pg_guard]
extern "C" {
    pub fn PageInit(page: Page, pageSize: Size, specialSize: Size);
}
#[pg_guard]
extern "C" {
    pub fn PageIsVerified(page: Page, blkno: BlockNumber) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn PageAddItemExtended(
        page: Page,
        item: Item,
        size: Size,
        offsetNumber: OffsetNumber,
        flags: ::std::os::raw::c_int,
    ) -> OffsetNumber;
}
#[pg_guard]
extern "C" {
    pub fn PageGetTempPage(page: Page) -> Page;
}
#[pg_guard]
extern "C" {
    pub fn PageGetTempPageCopy(page: Page) -> Page;
}
#[pg_guard]
extern "C" {
    pub fn PageGetTempPageCopySpecial(page: Page) -> Page;
}
#[pg_guard]
extern "C" {
    pub fn PageRestoreTempPage(tempPage: Page, oldPage: Page);
}
#[pg_guard]
extern "C" {
    pub fn PageRepairFragmentation(page: Page);
}
#[pg_guard]
extern "C" {
    pub fn PageGetFreeSpace(page: Page) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn PageGetFreeSpaceForMultipleTuples(page: Page, ntups: ::std::os::raw::c_int) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn PageGetExactFreeSpace(page: Page) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn PageGetHeapFreeSpace(page: Page) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn PageIndexTupleDelete(page: Page, offset: OffsetNumber);
}
#[pg_guard]
extern "C" {
    pub fn PageIndexMultiDelete(
        page: Page,
        itemnos: PgPtr<OffsetNumber>,
        nitems: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn PageIndexTupleDeleteNoCompact(page: Page, offset: OffsetNumber);
}
#[pg_guard]
extern "C" {
    pub fn PageIndexTupleOverwrite(
        page: Page,
        offnum: OffsetNumber,
        newtup: Item,
        newsize: Size,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn PageSetChecksumCopy(page: Page, blkno: BlockNumber) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn PageSetChecksumInplace(page: Page, blkno: BlockNumber);
}
#[repr(C)]
pub struct HeapTupleFields {
    pub t_xmin: TransactionId,
    pub t_xmax: TransactionId,
    pub t_field3: HeapTupleFields__bindgen_ty_1,
}
#[repr(C)]
pub struct HeapTupleFields__bindgen_ty_1 {
    pub t_cid: __BindgenUnionField<CommandId>,
    pub t_xvac: __BindgenUnionField<TransactionId>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
pub struct DatumTupleFields {
    pub datum_len_: int32,
    pub datum_typmod: int32,
    pub datum_typeid: Oid,
}
#[repr(C)]
pub struct HeapTupleHeaderData {
    pub t_choice: HeapTupleHeaderData__bindgen_ty_1,
    pub t_ctid: ItemPointerData,
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: __IncompleteArrayField<bits8>,
}
#[repr(C)]
pub struct HeapTupleHeaderData__bindgen_ty_1 {
    pub t_heap: __BindgenUnionField<HeapTupleFields>,
    pub t_datum: __BindgenUnionField<DatumTupleFields>,
    pub bindgen_union_field: [u32; 3usize],
}
#[repr(C)]
pub struct MinimalTupleData {
    pub t_len: uint32,
    pub mt_padding: [::std::os::raw::c_char; 6usize],
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: __IncompleteArrayField<bits8>,
}
#[pg_guard]
extern "C" {
    pub fn heap_compute_data_size(
        tupleDesc: PgPtr<TupleDescData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
    ) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn heap_fill_tuple(
        tupleDesc: PgPtr<TupleDescData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
        data: PgPtr<::std::os::raw::c_char>,
        data_size: Size,
        infomask: PgPtr<uint16>,
        bit: PgPtr<bits8>,
    );
}
#[pg_guard]
extern "C" {
    pub fn heap_attisnull(
        tup: PgPtr<HeapTupleData>,
        attnum: ::std::os::raw::c_int,
        tupleDesc: PgPtr<TupleDescData>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn nocachegetattr(
        tup: PgPtr<HeapTupleData>,
        attnum: ::std::os::raw::c_int,
        att: PgPtr<TupleDescData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn heap_getsysattr(
        tup: PgPtr<HeapTupleData>,
        attnum: ::std::os::raw::c_int,
        tupleDesc: PgPtr<TupleDescData>,
        isnull: PgPtr<bool>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn getmissingattr(
        tupleDesc: PgPtr<TupleDescData>,
        attnum: ::std::os::raw::c_int,
        isnull: PgPtr<bool>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn heap_copytuple(tuple: PgPtr<HeapTupleData>) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn heap_copytuple_with_tuple(src: PgPtr<HeapTupleData>, dest: PgPtr<HeapTupleData>);
}
#[pg_guard]
extern "C" {
    pub fn heap_copy_tuple_as_datum(
        tuple: PgPtr<HeapTupleData>,
        tupleDesc: PgPtr<TupleDescData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn heap_form_tuple(
        tupleDescriptor: PgPtr<TupleDescData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn heap_modify_tuple(
        tuple: PgPtr<HeapTupleData>,
        tupleDesc: PgPtr<TupleDescData>,
        replValues: PgPtr<Datum>,
        replIsnull: PgPtr<bool>,
        doReplace: PgPtr<bool>,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn heap_modify_tuple_by_cols(
        tuple: PgPtr<HeapTupleData>,
        tupleDesc: PgPtr<TupleDescData>,
        nCols: ::std::os::raw::c_int,
        replCols: PgPtr<::std::os::raw::c_int>,
        replValues: PgPtr<Datum>,
        replIsnull: PgPtr<bool>,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn heap_deform_tuple(
        tuple: PgPtr<HeapTupleData>,
        tupleDesc: PgPtr<TupleDescData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
    );
}
#[pg_guard]
extern "C" {
    pub fn heap_freetuple(htup: PgPtr<HeapTupleData>);
}
#[pg_guard]
extern "C" {
    pub fn heap_form_minimal_tuple(
        tupleDescriptor: PgPtr<TupleDescData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
    ) -> PgPtr<MinimalTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn heap_free_minimal_tuple(mtup: PgPtr<MinimalTupleData>);
}
#[pg_guard]
extern "C" {
    pub fn heap_copy_minimal_tuple(mtup: PgPtr<MinimalTupleData>) -> PgPtr<MinimalTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn heap_tuple_from_minimal_tuple(mtup: PgPtr<MinimalTupleData>) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn minimal_tuple_from_heap_tuple(htup: PgPtr<HeapTupleData>) -> PgPtr<MinimalTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn heap_expand_tuple(
        sourceTuple: PgPtr<HeapTupleData>,
        tupleDesc: PgPtr<TupleDescData>,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn minimal_expand_tuple(
        sourceTuple: PgPtr<HeapTupleData>,
        tupleDesc: PgPtr<TupleDescData>,
    ) -> PgPtr<MinimalTupleData>;
}
pub type Buffer = ::std::os::raw::c_int;
#[repr(C)]
pub struct BufferAccessStrategyData {
    _unused: [u8; 0],
}
pub type BufferAccessStrategy = PgPtr<BufferAccessStrategyData>;
#[repr(C)]
pub struct TupleTableSlot {
    pub type_: NodeTag,
    pub tts_flags: uint16,
    pub tts_nvalid: AttrNumber,
    pub tts_ops: PgPtr<TupleTableSlotOps>,
    pub tts_tupleDescriptor: PgPtr<TupleDescData>,
    pub tts_values: PgPtr<Datum>,
    pub tts_isnull: PgPtr<bool>,
    pub tts_mcxt: PgPtr<MemoryContextData>,
    pub tts_tid: ItemPointerData,
    pub tts_tableOid: Oid,
}
#[repr(C)]
pub struct TupleTableSlotOps {
    pub base_slot_size: usize,
    pub init: ::std::option::Option<unsafe extern "C" fn(slot: PgPtr<TupleTableSlot>)>,
    pub release: ::std::option::Option<unsafe extern "C" fn(slot: PgPtr<TupleTableSlot>)>,
    pub clear: ::std::option::Option<unsafe extern "C" fn(slot: PgPtr<TupleTableSlot>)>,
    pub getsomeattrs: ::std::option::Option<
        unsafe extern "C" fn(slot: PgPtr<TupleTableSlot>, natts: ::std::os::raw::c_int),
    >,
    pub getsysattr: ::std::option::Option<
        unsafe extern "C" fn(
            slot: PgPtr<TupleTableSlot>,
            attnum: ::std::os::raw::c_int,
            isnull: PgPtr<bool>,
        ) -> Datum,
    >,
    pub materialize: ::std::option::Option<unsafe extern "C" fn(slot: PgPtr<TupleTableSlot>)>,
    pub copyslot: ::std::option::Option<
        unsafe extern "C" fn(dstslot: PgPtr<TupleTableSlot>, srcslot: PgPtr<TupleTableSlot>),
    >,
    pub get_heap_tuple: ::std::option::Option<
        unsafe extern "C" fn(slot: PgPtr<TupleTableSlot>) -> PgPtr<HeapTupleData>,
    >,
    pub get_minimal_tuple: ::std::option::Option<
        unsafe extern "C" fn(slot: PgPtr<TupleTableSlot>) -> PgPtr<MinimalTupleData>,
    >,
    pub copy_heap_tuple: ::std::option::Option<
        unsafe extern "C" fn(slot: PgPtr<TupleTableSlot>) -> PgPtr<HeapTupleData>,
    >,
    pub copy_minimal_tuple: ::std::option::Option<
        unsafe extern "C" fn(slot: PgPtr<TupleTableSlot>) -> PgPtr<MinimalTupleData>,
    >,
}
#[pg_guard]
extern "C" {
    pub static TTSOpsVirtual: TupleTableSlotOps;
}
#[pg_guard]
extern "C" {
    pub static TTSOpsHeapTuple: TupleTableSlotOps;
}
#[pg_guard]
extern "C" {
    pub static TTSOpsMinimalTuple: TupleTableSlotOps;
}
#[pg_guard]
extern "C" {
    pub static TTSOpsBufferHeapTuple: TupleTableSlotOps;
}
#[repr(C)]
pub struct VirtualTupleTableSlot {
    pub base: TupleTableSlot,
    pub data: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct HeapTupleTableSlot {
    pub base: TupleTableSlot,
    pub tuple: PgPtr<HeapTupleData>,
    pub off: uint32,
    pub tupdata: HeapTupleData,
}
#[repr(C)]
pub struct BufferHeapTupleTableSlot {
    pub base: HeapTupleTableSlot,
    pub buffer: Buffer,
}
#[repr(C)]
pub struct MinimalTupleTableSlot {
    pub base: TupleTableSlot,
    pub tuple: PgPtr<HeapTupleData>,
    pub mintuple: PgPtr<MinimalTupleData>,
    pub minhdr: HeapTupleData,
    pub off: uint32,
}
#[pg_guard]
extern "C" {
    pub fn MakeTupleTableSlot(
        tupleDesc: PgPtr<TupleDescData>,
        tts_ops: PgPtr<TupleTableSlotOps>,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecAllocTableSlot(
        tupleTable: PgPtr<PgPtr<List>>,
        desc: PgPtr<TupleDescData>,
        tts_ops: PgPtr<TupleTableSlotOps>,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecResetTupleTable(tupleTable: PgPtr<List>, shouldFree: bool);
}
#[pg_guard]
extern "C" {
    pub fn MakeSingleTupleTableSlot(
        tupdesc: PgPtr<TupleDescData>,
        tts_ops: PgPtr<TupleTableSlotOps>,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecDropSingleTupleTableSlot(slot: PgPtr<TupleTableSlot>);
}
#[pg_guard]
extern "C" {
    pub fn ExecSetSlotDescriptor(slot: PgPtr<TupleTableSlot>, tupdesc: PgPtr<TupleDescData>);
}
#[pg_guard]
extern "C" {
    pub fn ExecStoreHeapTuple(
        tuple: PgPtr<HeapTupleData>,
        slot: PgPtr<TupleTableSlot>,
        shouldFree: bool,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecForceStoreHeapTuple(
        tuple: PgPtr<HeapTupleData>,
        slot: PgPtr<TupleTableSlot>,
        shouldFree: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecStoreBufferHeapTuple(
        tuple: PgPtr<HeapTupleData>,
        slot: PgPtr<TupleTableSlot>,
        buffer: Buffer,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecStorePinnedBufferHeapTuple(
        tuple: PgPtr<HeapTupleData>,
        slot: PgPtr<TupleTableSlot>,
        buffer: Buffer,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecStoreMinimalTuple(
        mtup: PgPtr<MinimalTupleData>,
        slot: PgPtr<TupleTableSlot>,
        shouldFree: bool,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecForceStoreMinimalTuple(
        mtup: PgPtr<MinimalTupleData>,
        slot: PgPtr<TupleTableSlot>,
        shouldFree: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecStoreVirtualTuple(slot: PgPtr<TupleTableSlot>) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecStoreAllNullTuple(slot: PgPtr<TupleTableSlot>) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecStoreHeapTupleDatum(data: Datum, slot: PgPtr<TupleTableSlot>);
}
#[pg_guard]
extern "C" {
    pub fn ExecFetchSlotHeapTuple(
        slot: PgPtr<TupleTableSlot>,
        materialize: bool,
        shouldFree: PgPtr<bool>,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn ExecFetchSlotMinimalTuple(
        slot: PgPtr<TupleTableSlot>,
        shouldFree: PgPtr<bool>,
    ) -> PgPtr<MinimalTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn ExecFetchSlotHeapTupleDatum(slot: PgPtr<TupleTableSlot>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn slot_getmissingattrs(
        slot: PgPtr<TupleTableSlot>,
        startAttNum: ::std::os::raw::c_int,
        lastAttNum: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn slot_getsomeattrs_int(slot: PgPtr<TupleTableSlot>, attnum: ::std::os::raw::c_int);
}
#[repr(C)]
pub struct TupleConversionMap {
    pub indesc: PgPtr<TupleDescData>,
    pub outdesc: PgPtr<TupleDescData>,
    pub attrMap: PgPtr<AttrNumber>,
    pub invalues: PgPtr<Datum>,
    pub inisnull: PgPtr<bool>,
    pub outvalues: PgPtr<Datum>,
    pub outisnull: PgPtr<bool>,
}
#[pg_guard]
extern "C" {
    pub fn convert_tuples_by_position(
        indesc: PgPtr<TupleDescData>,
        outdesc: PgPtr<TupleDescData>,
        msg: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<TupleConversionMap>;
}
#[pg_guard]
extern "C" {
    pub fn convert_tuples_by_name(
        indesc: PgPtr<TupleDescData>,
        outdesc: PgPtr<TupleDescData>,
        msg: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<TupleConversionMap>;
}
#[pg_guard]
extern "C" {
    pub fn convert_tuples_by_name_map(
        indesc: PgPtr<TupleDescData>,
        outdesc: PgPtr<TupleDescData>,
        msg: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<AttrNumber>;
}
#[pg_guard]
extern "C" {
    pub fn convert_tuples_by_name_map_if_req(
        indesc: PgPtr<TupleDescData>,
        outdesc: PgPtr<TupleDescData>,
        msg: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<AttrNumber>;
}
#[pg_guard]
extern "C" {
    pub fn execute_attr_map_tuple(
        tuple: PgPtr<HeapTupleData>,
        map: PgPtr<TupleConversionMap>,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn execute_attr_map_slot(
        attrMap: PgPtr<AttrNumber>,
        in_slot: PgPtr<TupleTableSlot>,
        out_slot: PgPtr<TupleTableSlot>,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn free_conversion_map(map: PgPtr<TupleConversionMap>);
}
#[repr(C)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: PgPtr<::std::os::raw::c_char>,
}
#[pg_guard]
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
#[pg_guard]
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn asctime(arg1: PgPtr<tm>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn clock() -> clock_t;
}
#[pg_guard]
extern "C" {
    pub fn ctime(arg1: PgPtr<time_t>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn getdate(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<tm>;
}
#[pg_guard]
extern "C" {
    pub fn gmtime(arg1: PgPtr<time_t>) -> PgPtr<tm>;
}
#[pg_guard]
extern "C" {
    pub fn localtime(arg1: PgPtr<time_t>) -> PgPtr<tm>;
}
#[pg_guard]
extern "C" {
    pub fn mktime(arg1: PgPtr<tm>) -> time_t;
}
#[pg_guard]
extern "C" {
    pub fn strftime(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: usize,
        arg3: PgPtr<::std::os::raw::c_char>,
        arg4: PgPtr<tm>,
    ) -> usize;
}
#[pg_guard]
extern "C" {
    pub fn strptime(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: PgPtr<tm>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn time(arg1: PgPtr<time_t>) -> time_t;
}
#[pg_guard]
extern "C" {
    pub fn tzset();
}
#[pg_guard]
extern "C" {
    pub fn asctime_r(
        arg1: PgPtr<tm>,
        arg2: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn ctime_r(
        arg1: PgPtr<time_t>,
        arg2: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn gmtime_r(arg1: PgPtr<time_t>, arg2: PgPtr<tm>) -> PgPtr<tm>;
}
#[pg_guard]
extern "C" {
    pub fn localtime_r(arg1: PgPtr<time_t>, arg2: PgPtr<tm>) -> PgPtr<tm>;
}
#[pg_guard]
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
#[pg_guard]
extern "C" {
    pub fn tzsetwall();
}
#[pg_guard]
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
#[pg_guard]
extern "C" {
    pub fn timelocal(arg1: PgPtr<tm>) -> time_t;
}
#[pg_guard]
extern "C" {
    pub fn timegm(arg1: PgPtr<tm>) -> time_t;
}
#[pg_guard]
extern "C" {
    pub fn nanosleep(__rqtp: PgPtr<timespec>, __rmtp: PgPtr<timespec>) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum clockid_t {
    _CLOCK_REALTIME = 0,
    _CLOCK_MONOTONIC = 6,
    _CLOCK_MONOTONIC_RAW = 4,
    _CLOCK_MONOTONIC_RAW_APPROX = 5,
    _CLOCK_UPTIME_RAW = 8,
    _CLOCK_UPTIME_RAW_APPROX = 9,
    _CLOCK_PROCESS_CPUTIME_ID = 12,
    _CLOCK_THREAD_CPUTIME_ID = 16,
}
#[pg_guard]
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: PgPtr<timespec>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: PgPtr<timespec>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
#[pg_guard]
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: PgPtr<timespec>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn timespec_get(ts: PgPtr<timespec>, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type instr_time = timespec;
#[repr(C)]
pub struct BufferUsage {
    pub shared_blks_hit: ::std::os::raw::c_long,
    pub shared_blks_read: ::std::os::raw::c_long,
    pub shared_blks_dirtied: ::std::os::raw::c_long,
    pub shared_blks_written: ::std::os::raw::c_long,
    pub local_blks_hit: ::std::os::raw::c_long,
    pub local_blks_read: ::std::os::raw::c_long,
    pub local_blks_dirtied: ::std::os::raw::c_long,
    pub local_blks_written: ::std::os::raw::c_long,
    pub temp_blks_read: ::std::os::raw::c_long,
    pub temp_blks_written: ::std::os::raw::c_long,
    pub blk_read_time: instr_time,
    pub blk_write_time: instr_time,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum InstrumentOption {
    INSTRUMENT_TIMER = 1,
    INSTRUMENT_BUFFERS = 2,
    INSTRUMENT_ROWS = 4,
    INSTRUMENT_ALL = 2147483647,
}
#[repr(C)]
pub struct Instrumentation {
    pub need_timer: bool,
    pub need_bufusage: bool,
    pub running: bool,
    pub starttime: instr_time,
    pub counter: instr_time,
    pub firsttuple: f64,
    pub tuplecount: f64,
    pub bufusage_start: BufferUsage,
    pub startup: f64,
    pub total: f64,
    pub ntuples: f64,
    pub ntuples2: f64,
    pub nloops: f64,
    pub nfiltered1: f64,
    pub nfiltered2: f64,
    pub bufusage: BufferUsage,
}
#[repr(C)]
pub struct WorkerInstrumentation {
    pub num_workers: ::std::os::raw::c_int,
    pub instrument: __IncompleteArrayField<Instrumentation>,
}
#[pg_guard]
extern "C" {
    pub static mut pgBufferUsage: BufferUsage;
}
#[pg_guard]
extern "C" {
    pub fn InstrAlloc(
        n: ::std::os::raw::c_int,
        instrument_options: ::std::os::raw::c_int,
    ) -> PgPtr<Instrumentation>;
}
#[pg_guard]
extern "C" {
    pub fn InstrInit(instr: PgPtr<Instrumentation>, instrument_options: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn InstrStartNode(instr: PgPtr<Instrumentation>);
}
#[pg_guard]
extern "C" {
    pub fn InstrStopNode(instr: PgPtr<Instrumentation>, nTuples: f64);
}
#[pg_guard]
extern "C" {
    pub fn InstrEndLoop(instr: PgPtr<Instrumentation>);
}
#[pg_guard]
extern "C" {
    pub fn InstrAggNode(dst: PgPtr<Instrumentation>, add: PgPtr<Instrumentation>);
}
#[pg_guard]
extern "C" {
    pub fn InstrStartParallelQuery();
}
#[pg_guard]
extern "C" {
    pub fn InstrEndParallelQuery(result: PgPtr<BufferUsage>);
}
#[pg_guard]
extern "C" {
    pub fn InstrAccumParallelQuery(result: PgPtr<BufferUsage>);
}
#[repr(C)]
pub struct StringInfoData {
    pub data: PgPtr<::std::os::raw::c_char>,
    pub len: ::std::os::raw::c_int,
    pub maxlen: ::std::os::raw::c_int,
    pub cursor: ::std::os::raw::c_int,
}
pub type StringInfo = PgPtr<StringInfoData>;
#[pg_guard]
extern "C" {
    pub fn makeStringInfo() -> PgPtr<StringInfoData>;
}
#[pg_guard]
extern "C" {
    pub fn initStringInfo(str_: PgPtr<StringInfoData>);
}
#[pg_guard]
extern "C" {
    pub fn resetStringInfo(str_: PgPtr<StringInfoData>);
}
#[pg_guard]
extern "C" {
    pub fn appendStringInfo(str_: PgPtr<StringInfoData>, fmt: PgPtr<::std::os::raw::c_char>, ...);
}
#[pg_guard]
extern "C" {
    pub fn appendStringInfoVA(
        str_: PgPtr<StringInfoData>,
        fmt: PgPtr<::std::os::raw::c_char>,
        args: PgPtr<__va_list_tag>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn appendStringInfoString(str_: PgPtr<StringInfoData>, s: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn appendStringInfoChar(str_: PgPtr<StringInfoData>, ch: ::std::os::raw::c_char);
}
#[pg_guard]
extern "C" {
    pub fn appendStringInfoSpaces(str_: PgPtr<StringInfoData>, count: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn appendBinaryStringInfo(
        str_: PgPtr<StringInfoData>,
        data: PgPtr<::std::os::raw::c_char>,
        datalen: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn appendBinaryStringInfoNT(
        str_: PgPtr<StringInfoData>,
        data: PgPtr<::std::os::raw::c_char>,
        datalen: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn enlargeStringInfo(str_: PgPtr<StringInfoData>, needed: ::std::os::raw::c_int);
}
#[repr(C)]
pub struct pairingheap_node {
    pub first_child: PgPtr<pairingheap_node>,
    pub next_sibling: PgPtr<pairingheap_node>,
    pub prev_or_parent: PgPtr<pairingheap_node>,
}
pub type pairingheap_comparator = ::std::option::Option<
    unsafe extern "C" fn(
        a: PgPtr<pairingheap_node>,
        b: PgPtr<pairingheap_node>,
        arg: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
pub struct pairingheap {
    pub ph_compare: pairingheap_comparator,
    pub ph_arg: PgPtr<::std::os::raw::c_void>,
    pub ph_root: PgPtr<pairingheap_node>,
}
#[pg_guard]
extern "C" {
    pub fn pairingheap_allocate(
        compare: pairingheap_comparator,
        arg: PgPtr<::std::os::raw::c_void>,
    ) -> PgPtr<pairingheap>;
}
#[pg_guard]
extern "C" {
    pub fn pairingheap_free(heap: PgPtr<pairingheap>);
}
#[pg_guard]
extern "C" {
    pub fn pairingheap_add(heap: PgPtr<pairingheap>, node: PgPtr<pairingheap_node>);
}
#[pg_guard]
extern "C" {
    pub fn pairingheap_first(heap: PgPtr<pairingheap>) -> PgPtr<pairingheap_node>;
}
#[pg_guard]
extern "C" {
    pub fn pairingheap_remove_first(heap: PgPtr<pairingheap>) -> PgPtr<pairingheap_node>;
}
#[pg_guard]
extern "C" {
    pub fn pairingheap_remove(heap: PgPtr<pairingheap>, node: PgPtr<pairingheap_node>);
}
#[repr(C)]
pub struct ParamExternData {
    pub value: Datum,
    pub isnull: bool,
    pub pflags: uint16,
    pub ptype: Oid,
}
pub type ParamListInfo = PgPtr<ParamListInfoData>;
pub type ParamFetchHook = ::std::option::Option<
    unsafe extern "C" fn(
        params: PgPtr<ParamListInfoData>,
        paramid: ::std::os::raw::c_int,
        speculative: bool,
        workspace: PgPtr<ParamExternData>,
    ) -> PgPtr<ParamExternData>,
>;
pub type ParamCompileHook = ::std::option::Option<
    unsafe extern "C" fn(
        params: PgPtr<ParamListInfoData>,
        param: PgPtr<Param>,
        state: PgPtr<ExprState>,
        resv: PgPtr<Datum>,
        resnull: PgPtr<bool>,
    ),
>;
pub type ParserSetupHook = ::std::option::Option<
    unsafe extern "C" fn(pstate: PgPtr<ParseState>, arg: PgPtr<::std::os::raw::c_void>),
>;
#[repr(C)]
pub struct ParamListInfoData {
    pub paramFetch: ParamFetchHook,
    pub paramFetchArg: PgPtr<::std::os::raw::c_void>,
    pub paramCompile: ParamCompileHook,
    pub paramCompileArg: PgPtr<::std::os::raw::c_void>,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: PgPtr<::std::os::raw::c_void>,
    pub numParams: ::std::os::raw::c_int,
    pub params: __IncompleteArrayField<ParamExternData>,
}
#[repr(C)]
pub struct ParamExecData {
    pub execPlan: PgPtr<::std::os::raw::c_void>,
    pub value: Datum,
    pub isnull: bool,
}
#[pg_guard]
extern "C" {
    pub fn makeParamList(numParams: ::std::os::raw::c_int) -> PgPtr<ParamListInfoData>;
}
#[pg_guard]
extern "C" {
    pub fn copyParamList(from: PgPtr<ParamListInfoData>) -> PgPtr<ParamListInfoData>;
}
#[pg_guard]
extern "C" {
    pub fn EstimateParamListSpace(paramLI: PgPtr<ParamListInfoData>) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn SerializeParamList(
        paramLI: PgPtr<ParamListInfoData>,
        start_address: PgPtr<PgPtr<::std::os::raw::c_char>>,
    );
}
#[pg_guard]
extern "C" {
    pub fn RestoreParamList(
        start_address: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> PgPtr<ParamListInfoData>;
}
#[repr(i32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ScanDirection {
    BackwardScanDirection = -1,
    NoMovementScanDirection = 0,
    ForwardScanDirection = 1,
}
pub type StrategyNumber = uint16;
pub type bitmapword = uint64;
pub type signedbitmapword = int64;
#[repr(C)]
pub struct Bitmapset {
    pub nwords: ::std::os::raw::c_int,
    pub words: __IncompleteArrayField<bitmapword>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum BMS_Comparison {
    BMS_EQUAL = 0,
    BMS_SUBSET1 = 1,
    BMS_SUBSET2 = 2,
    BMS_DIFFERENT = 3,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum BMS_Membership {
    BMS_EMPTY_SET = 0,
    BMS_SINGLETON = 1,
    BMS_MULTIPLE = 2,
}
#[pg_guard]
extern "C" {
    pub fn bms_copy(a: PgPtr<Bitmapset>) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn bms_equal(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn bms_compare(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bms_make_singleton(x: ::std::os::raw::c_int) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn bms_free(a: PgPtr<Bitmapset>);
}
#[pg_guard]
extern "C" {
    pub fn bms_union(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn bms_intersect(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn bms_difference(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn bms_is_subset(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn bms_subset_compare(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> BMS_Comparison;
}
#[pg_guard]
extern "C" {
    pub fn bms_is_member(x: ::std::os::raw::c_int, a: PgPtr<Bitmapset>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn bms_member_index(a: PgPtr<Bitmapset>, x: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bms_overlap(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn bms_overlap_list(a: PgPtr<Bitmapset>, b: PgPtr<List>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn bms_nonempty_difference(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn bms_singleton_member(a: PgPtr<Bitmapset>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bms_get_singleton_member(
        a: PgPtr<Bitmapset>,
        member: PgPtr<::std::os::raw::c_int>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn bms_num_members(a: PgPtr<Bitmapset>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bms_membership(a: PgPtr<Bitmapset>) -> BMS_Membership;
}
#[pg_guard]
extern "C" {
    pub fn bms_is_empty(a: PgPtr<Bitmapset>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn bms_add_member(a: PgPtr<Bitmapset>, x: ::std::os::raw::c_int) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn bms_del_member(a: PgPtr<Bitmapset>, x: ::std::os::raw::c_int) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn bms_add_members(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn bms_add_range(
        a: PgPtr<Bitmapset>,
        lower: ::std::os::raw::c_int,
        upper: ::std::os::raw::c_int,
    ) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn bms_int_members(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn bms_del_members(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn bms_join(a: PgPtr<Bitmapset>, b: PgPtr<Bitmapset>) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn bms_first_member(a: PgPtr<Bitmapset>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bms_next_member(
        a: PgPtr<Bitmapset>,
        prevbit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bms_prev_member(
        a: PgPtr<Bitmapset>,
        prevbit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bms_hash_value(a: PgPtr<Bitmapset>) -> uint32;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum LockClauseStrength {
    LCS_NONE = 0,
    LCS_FORKEYSHARE = 1,
    LCS_FORSHARE = 2,
    LCS_FORNOKEYUPDATE = 3,
    LCS_FORUPDATE = 4,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum LockWaitPolicy {
    LockWaitBlock = 0,
    LockWaitSkip = 1,
    LockWaitError = 2,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum LockTupleMode {
    LockTupleKeyShare = 0,
    LockTupleShare = 1,
    LockTupleNoKeyExclusive = 2,
    LockTupleExclusive = 3,
}
#[repr(C)]
pub struct Alias {
    pub type_: NodeTag,
    pub aliasname: PgPtr<::std::os::raw::c_char>,
    pub colnames: PgPtr<List>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum OnCommitAction {
    ONCOMMIT_NOOP = 0,
    ONCOMMIT_PRESERVE_ROWS = 1,
    ONCOMMIT_DELETE_ROWS = 2,
    ONCOMMIT_DROP = 3,
}
#[repr(C)]
pub struct RangeVar {
    pub type_: NodeTag,
    pub catalogname: PgPtr<::std::os::raw::c_char>,
    pub schemaname: PgPtr<::std::os::raw::c_char>,
    pub relname: PgPtr<::std::os::raw::c_char>,
    pub inh: bool,
    pub relpersistence: ::std::os::raw::c_char,
    pub alias: PgPtr<Alias>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct TableFunc {
    pub type_: NodeTag,
    pub ns_uris: PgPtr<List>,
    pub ns_names: PgPtr<List>,
    pub docexpr: PgPtr<Node>,
    pub rowexpr: PgPtr<Node>,
    pub colnames: PgPtr<List>,
    pub coltypes: PgPtr<List>,
    pub coltypmods: PgPtr<List>,
    pub colcollations: PgPtr<List>,
    pub colexprs: PgPtr<List>,
    pub coldefexprs: PgPtr<List>,
    pub notnulls: PgPtr<Bitmapset>,
    pub ordinalitycol: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct IntoClause {
    pub type_: NodeTag,
    pub rel: PgPtr<RangeVar>,
    pub colNames: PgPtr<List>,
    pub accessMethod: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
    pub onCommit: OnCommitAction,
    pub tableSpaceName: PgPtr<::std::os::raw::c_char>,
    pub viewQuery: PgPtr<Node>,
    pub skipData: bool,
}
#[repr(C)]
pub struct Expr {
    pub type_: NodeTag,
}
#[repr(C)]
pub struct Var {
    pub xpr: Expr,
    pub varno: Index,
    pub varattno: AttrNumber,
    pub vartype: Oid,
    pub vartypmod: int32,
    pub varcollid: Oid,
    pub varlevelsup: Index,
    pub varnoold: Index,
    pub varoattno: AttrNumber,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct Const {
    pub xpr: Expr,
    pub consttype: Oid,
    pub consttypmod: int32,
    pub constcollid: Oid,
    pub constlen: ::std::os::raw::c_int,
    pub constvalue: Datum,
    pub constisnull: bool,
    pub constbyval: bool,
    pub location: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ParamKind {
    PARAM_EXTERN = 0,
    PARAM_EXEC = 1,
    PARAM_SUBLINK = 2,
    PARAM_MULTIEXPR = 3,
}
#[repr(C)]
pub struct Param {
    pub xpr: Expr,
    pub paramkind: ParamKind,
    pub paramid: ::std::os::raw::c_int,
    pub paramtype: Oid,
    pub paramtypmod: int32,
    pub paramcollid: Oid,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct Aggref {
    pub xpr: Expr,
    pub aggfnoid: Oid,
    pub aggtype: Oid,
    pub aggcollid: Oid,
    pub inputcollid: Oid,
    pub aggtranstype: Oid,
    pub aggargtypes: PgPtr<List>,
    pub aggdirectargs: PgPtr<List>,
    pub args: PgPtr<List>,
    pub aggorder: PgPtr<List>,
    pub aggdistinct: PgPtr<List>,
    pub aggfilter: PgPtr<Expr>,
    pub aggstar: bool,
    pub aggvariadic: bool,
    pub aggkind: ::std::os::raw::c_char,
    pub agglevelsup: Index,
    pub aggsplit: AggSplit,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct GroupingFunc {
    pub xpr: Expr,
    pub args: PgPtr<List>,
    pub refs: PgPtr<List>,
    pub cols: PgPtr<List>,
    pub agglevelsup: Index,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct WindowFunc {
    pub xpr: Expr,
    pub winfnoid: Oid,
    pub wintype: Oid,
    pub wincollid: Oid,
    pub inputcollid: Oid,
    pub args: PgPtr<List>,
    pub aggfilter: PgPtr<Expr>,
    pub winref: Index,
    pub winstar: bool,
    pub winagg: bool,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct SubscriptingRef {
    pub xpr: Expr,
    pub refcontainertype: Oid,
    pub refelemtype: Oid,
    pub reftypmod: int32,
    pub refcollid: Oid,
    pub refupperindexpr: PgPtr<List>,
    pub reflowerindexpr: PgPtr<List>,
    pub refexpr: PgPtr<Expr>,
    pub refassgnexpr: PgPtr<Expr>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum CoercionContext {
    COERCION_IMPLICIT = 0,
    COERCION_ASSIGNMENT = 1,
    COERCION_EXPLICIT = 2,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum CoercionForm {
    COERCE_EXPLICIT_CALL = 0,
    COERCE_EXPLICIT_CAST = 1,
    COERCE_IMPLICIT_CAST = 2,
}
#[repr(C)]
pub struct FuncExpr {
    pub xpr: Expr,
    pub funcid: Oid,
    pub funcresulttype: Oid,
    pub funcretset: bool,
    pub funcvariadic: bool,
    pub funcformat: CoercionForm,
    pub funccollid: Oid,
    pub inputcollid: Oid,
    pub args: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct NamedArgExpr {
    pub xpr: Expr,
    pub arg: PgPtr<Expr>,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub argnumber: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct OpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub opresulttype: Oid,
    pub opretset: bool,
    pub opcollid: Oid,
    pub inputcollid: Oid,
    pub args: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
pub type DistinctExpr = OpExpr;
pub type NullIfExpr = OpExpr;
#[repr(C)]
pub struct ScalarArrayOpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub useOr: bool,
    pub inputcollid: Oid,
    pub args: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum BoolExprType {
    AND_EXPR = 0,
    OR_EXPR = 1,
    NOT_EXPR = 2,
}
#[repr(C)]
pub struct BoolExpr {
    pub xpr: Expr,
    pub boolop: BoolExprType,
    pub args: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SubLinkType {
    EXISTS_SUBLINK = 0,
    ALL_SUBLINK = 1,
    ANY_SUBLINK = 2,
    ROWCOMPARE_SUBLINK = 3,
    EXPR_SUBLINK = 4,
    MULTIEXPR_SUBLINK = 5,
    ARRAY_SUBLINK = 6,
    CTE_SUBLINK = 7,
}
#[repr(C)]
pub struct SubLink {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub subLinkId: ::std::os::raw::c_int,
    pub testexpr: PgPtr<Node>,
    pub operName: PgPtr<List>,
    pub subselect: PgPtr<Node>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct SubPlan {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: PgPtr<Node>,
    pub paramIds: PgPtr<List>,
    pub plan_id: ::std::os::raw::c_int,
    pub plan_name: PgPtr<::std::os::raw::c_char>,
    pub firstColType: Oid,
    pub firstColTypmod: int32,
    pub firstColCollation: Oid,
    pub useHashTable: bool,
    pub unknownEqFalse: bool,
    pub parallel_safe: bool,
    pub setParam: PgPtr<List>,
    pub parParam: PgPtr<List>,
    pub args: PgPtr<List>,
    pub startup_cost: Cost,
    pub per_call_cost: Cost,
}
#[repr(C)]
pub struct AlternativeSubPlan {
    pub xpr: Expr,
    pub subplans: PgPtr<List>,
}
#[repr(C)]
pub struct FieldSelect {
    pub xpr: Expr,
    pub arg: PgPtr<Expr>,
    pub fieldnum: AttrNumber,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
}
#[repr(C)]
pub struct FieldStore {
    pub xpr: Expr,
    pub arg: PgPtr<Expr>,
    pub newvals: PgPtr<List>,
    pub fieldnums: PgPtr<List>,
    pub resulttype: Oid,
}
#[repr(C)]
pub struct RelabelType {
    pub xpr: Expr,
    pub arg: PgPtr<Expr>,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub relabelformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct CoerceViaIO {
    pub xpr: Expr,
    pub arg: PgPtr<Expr>,
    pub resulttype: Oid,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ArrayCoerceExpr {
    pub xpr: Expr,
    pub arg: PgPtr<Expr>,
    pub elemexpr: PgPtr<Expr>,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ConvertRowtypeExpr {
    pub xpr: Expr,
    pub arg: PgPtr<Expr>,
    pub resulttype: Oid,
    pub convertformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct CollateExpr {
    pub xpr: Expr,
    pub arg: PgPtr<Expr>,
    pub collOid: Oid,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct CaseExpr {
    pub xpr: Expr,
    pub casetype: Oid,
    pub casecollid: Oid,
    pub arg: PgPtr<Expr>,
    pub args: PgPtr<List>,
    pub defresult: PgPtr<Expr>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct CaseWhen {
    pub xpr: Expr,
    pub expr: PgPtr<Expr>,
    pub result: PgPtr<Expr>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct CaseTestExpr {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
}
#[repr(C)]
pub struct ArrayExpr {
    pub xpr: Expr,
    pub array_typeid: Oid,
    pub array_collid: Oid,
    pub element_typeid: Oid,
    pub elements: PgPtr<List>,
    pub multidims: bool,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct RowExpr {
    pub xpr: Expr,
    pub args: PgPtr<List>,
    pub row_typeid: Oid,
    pub row_format: CoercionForm,
    pub colnames: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum RowCompareType {
    ROWCOMPARE_LT = 1,
    ROWCOMPARE_LE = 2,
    ROWCOMPARE_EQ = 3,
    ROWCOMPARE_GE = 4,
    ROWCOMPARE_GT = 5,
    ROWCOMPARE_NE = 6,
}
#[repr(C)]
pub struct RowCompareExpr {
    pub xpr: Expr,
    pub rctype: RowCompareType,
    pub opnos: PgPtr<List>,
    pub opfamilies: PgPtr<List>,
    pub inputcollids: PgPtr<List>,
    pub largs: PgPtr<List>,
    pub rargs: PgPtr<List>,
}
#[repr(C)]
pub struct CoalesceExpr {
    pub xpr: Expr,
    pub coalescetype: Oid,
    pub coalescecollid: Oid,
    pub args: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum MinMaxOp {
    IS_GREATEST = 0,
    IS_LEAST = 1,
}
#[repr(C)]
pub struct MinMaxExpr {
    pub xpr: Expr,
    pub minmaxtype: Oid,
    pub minmaxcollid: Oid,
    pub inputcollid: Oid,
    pub op: MinMaxOp,
    pub args: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SQLValueFunctionOp {
    SVFOP_CURRENT_DATE = 0,
    SVFOP_CURRENT_TIME = 1,
    SVFOP_CURRENT_TIME_N = 2,
    SVFOP_CURRENT_TIMESTAMP = 3,
    SVFOP_CURRENT_TIMESTAMP_N = 4,
    SVFOP_LOCALTIME = 5,
    SVFOP_LOCALTIME_N = 6,
    SVFOP_LOCALTIMESTAMP = 7,
    SVFOP_LOCALTIMESTAMP_N = 8,
    SVFOP_CURRENT_ROLE = 9,
    SVFOP_CURRENT_USER = 10,
    SVFOP_USER = 11,
    SVFOP_SESSION_USER = 12,
    SVFOP_CURRENT_CATALOG = 13,
    SVFOP_CURRENT_SCHEMA = 14,
}
#[repr(C)]
pub struct SQLValueFunction {
    pub xpr: Expr,
    pub op: SQLValueFunctionOp,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum XmlExprOp {
    IS_XMLCONCAT = 0,
    IS_XMLELEMENT = 1,
    IS_XMLFOREST = 2,
    IS_XMLPARSE = 3,
    IS_XMLPI = 4,
    IS_XMLROOT = 5,
    IS_XMLSERIALIZE = 6,
    IS_DOCUMENT = 7,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum XmlOptionType {
    XMLOPTION_DOCUMENT = 0,
    XMLOPTION_CONTENT = 1,
}
#[repr(C)]
pub struct XmlExpr {
    pub xpr: Expr,
    pub op: XmlExprOp,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub named_args: PgPtr<List>,
    pub arg_names: PgPtr<List>,
    pub args: PgPtr<List>,
    pub xmloption: XmlOptionType,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum NullTestType {
    IS_NULL = 0,
    IS_NOT_NULL = 1,
}
#[repr(C)]
pub struct NullTest {
    pub xpr: Expr,
    pub arg: PgPtr<Expr>,
    pub nulltesttype: NullTestType,
    pub argisrow: bool,
    pub location: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum BoolTestType {
    IS_TRUE = 0,
    IS_NOT_TRUE = 1,
    IS_FALSE = 2,
    IS_NOT_FALSE = 3,
    IS_UNKNOWN = 4,
    IS_NOT_UNKNOWN = 5,
}
#[repr(C)]
pub struct BooleanTest {
    pub xpr: Expr,
    pub arg: PgPtr<Expr>,
    pub booltesttype: BoolTestType,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct CoerceToDomain {
    pub xpr: Expr,
    pub arg: PgPtr<Expr>,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coercionformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct CoerceToDomainValue {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct SetToDefault {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct CurrentOfExpr {
    pub xpr: Expr,
    pub cvarno: Index,
    pub cursor_name: PgPtr<::std::os::raw::c_char>,
    pub cursor_param: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct NextValueExpr {
    pub xpr: Expr,
    pub seqid: Oid,
    pub typeId: Oid,
}
#[repr(C)]
pub struct InferenceElem {
    pub xpr: Expr,
    pub expr: PgPtr<Node>,
    pub infercollid: Oid,
    pub inferopclass: Oid,
}
#[repr(C)]
pub struct TargetEntry {
    pub xpr: Expr,
    pub expr: PgPtr<Expr>,
    pub resno: AttrNumber,
    pub resname: PgPtr<::std::os::raw::c_char>,
    pub ressortgroupref: Index,
    pub resorigtbl: Oid,
    pub resorigcol: AttrNumber,
    pub resjunk: bool,
}
#[repr(C)]
pub struct RangeTblRef {
    pub type_: NodeTag,
    pub rtindex: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct JoinExpr {
    pub type_: NodeTag,
    pub jointype: JoinType,
    pub isNatural: bool,
    pub larg: PgPtr<Node>,
    pub rarg: PgPtr<Node>,
    pub usingClause: PgPtr<List>,
    pub quals: PgPtr<Node>,
    pub alias: PgPtr<Alias>,
    pub rtindex: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct FromExpr {
    pub type_: NodeTag,
    pub fromlist: PgPtr<List>,
    pub quals: PgPtr<Node>,
}
#[repr(C)]
pub struct OnConflictExpr {
    pub type_: NodeTag,
    pub action: OnConflictAction,
    pub arbiterElems: PgPtr<List>,
    pub arbiterWhere: PgPtr<Node>,
    pub constraint: Oid,
    pub onConflictSet: PgPtr<List>,
    pub onConflictWhere: PgPtr<Node>,
    pub exclRelIndex: ::std::os::raw::c_int,
    pub exclRelTlist: PgPtr<List>,
}
#[repr(C)]
pub struct PlannedStmt {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub queryId: uint64,
    pub hasReturning: bool,
    pub hasModifyingCTE: bool,
    pub canSetTag: bool,
    pub transientPlan: bool,
    pub dependsOnRole: bool,
    pub parallelModeNeeded: bool,
    pub jitFlags: ::std::os::raw::c_int,
    pub planTree: PgPtr<Plan>,
    pub rtable: PgPtr<List>,
    pub resultRelations: PgPtr<List>,
    pub rootResultRelations: PgPtr<List>,
    pub subplans: PgPtr<List>,
    pub rewindPlanIDs: PgPtr<Bitmapset>,
    pub rowMarks: PgPtr<List>,
    pub relationOids: PgPtr<List>,
    pub invalItems: PgPtr<List>,
    pub paramExecTypes: PgPtr<List>,
    pub utilityStmt: PgPtr<Node>,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct Plan {
    pub type_: NodeTag,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub plan_rows: f64,
    pub plan_width: ::std::os::raw::c_int,
    pub parallel_aware: bool,
    pub parallel_safe: bool,
    pub plan_node_id: ::std::os::raw::c_int,
    pub targetlist: PgPtr<List>,
    pub qual: PgPtr<List>,
    pub lefttree: PgPtr<Plan>,
    pub righttree: PgPtr<Plan>,
    pub initPlan: PgPtr<List>,
    pub extParam: PgPtr<Bitmapset>,
    pub allParam: PgPtr<Bitmapset>,
}
#[repr(C)]
pub struct Result {
    pub plan: Plan,
    pub resconstantqual: PgPtr<Node>,
}
#[repr(C)]
pub struct ProjectSet {
    pub plan: Plan,
}
#[repr(C)]
pub struct ModifyTable {
    pub plan: Plan,
    pub operation: CmdType,
    pub canSetTag: bool,
    pub nominalRelation: Index,
    pub rootRelation: Index,
    pub partColsUpdated: bool,
    pub resultRelations: PgPtr<List>,
    pub resultRelIndex: ::std::os::raw::c_int,
    pub rootResultRelIndex: ::std::os::raw::c_int,
    pub plans: PgPtr<List>,
    pub withCheckOptionLists: PgPtr<List>,
    pub returningLists: PgPtr<List>,
    pub fdwPrivLists: PgPtr<List>,
    pub fdwDirectModifyPlans: PgPtr<Bitmapset>,
    pub rowMarks: PgPtr<List>,
    pub epqParam: ::std::os::raw::c_int,
    pub onConflictAction: OnConflictAction,
    pub arbiterIndexes: PgPtr<List>,
    pub onConflictSet: PgPtr<List>,
    pub onConflictWhere: PgPtr<Node>,
    pub exclRelRTI: Index,
    pub exclRelTlist: PgPtr<List>,
}
#[repr(C)]
pub struct Append {
    pub plan: Plan,
    pub appendplans: PgPtr<List>,
    pub first_partial_plan: ::std::os::raw::c_int,
    pub part_prune_info: PgPtr<PartitionPruneInfo>,
}
#[repr(C)]
pub struct MergeAppend {
    pub plan: Plan,
    pub mergeplans: PgPtr<List>,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: PgPtr<AttrNumber>,
    pub sortOperators: PgPtr<Oid>,
    pub collations: PgPtr<Oid>,
    pub nullsFirst: PgPtr<bool>,
    pub part_prune_info: PgPtr<PartitionPruneInfo>,
}
#[repr(C)]
pub struct RecursiveUnion {
    pub plan: Plan,
    pub wtParam: ::std::os::raw::c_int,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: PgPtr<AttrNumber>,
    pub dupOperators: PgPtr<Oid>,
    pub dupCollations: PgPtr<Oid>,
    pub numGroups: ::std::os::raw::c_long,
}
#[repr(C)]
pub struct BitmapAnd {
    pub plan: Plan,
    pub bitmapplans: PgPtr<List>,
}
#[repr(C)]
pub struct BitmapOr {
    pub plan: Plan,
    pub isshared: bool,
    pub bitmapplans: PgPtr<List>,
}
#[repr(C)]
pub struct Scan {
    pub plan: Plan,
    pub scanrelid: Index,
}
pub type SeqScan = Scan;
#[repr(C)]
pub struct SampleScan {
    pub scan: Scan,
    pub tablesample: PgPtr<TableSampleClause>,
}
#[repr(C)]
pub struct IndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: PgPtr<List>,
    pub indexqualorig: PgPtr<List>,
    pub indexorderby: PgPtr<List>,
    pub indexorderbyorig: PgPtr<List>,
    pub indexorderbyops: PgPtr<List>,
    pub indexorderdir: ScanDirection,
}
#[repr(C)]
pub struct IndexOnlyScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: PgPtr<List>,
    pub indexorderby: PgPtr<List>,
    pub indextlist: PgPtr<List>,
    pub indexorderdir: ScanDirection,
}
#[repr(C)]
pub struct BitmapIndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub isshared: bool,
    pub indexqual: PgPtr<List>,
    pub indexqualorig: PgPtr<List>,
}
#[repr(C)]
pub struct BitmapHeapScan {
    pub scan: Scan,
    pub bitmapqualorig: PgPtr<List>,
}
#[repr(C)]
pub struct TidScan {
    pub scan: Scan,
    pub tidquals: PgPtr<List>,
}
#[repr(C)]
pub struct SubqueryScan {
    pub scan: Scan,
    pub subplan: PgPtr<Plan>,
}
#[repr(C)]
pub struct FunctionScan {
    pub scan: Scan,
    pub functions: PgPtr<List>,
    pub funcordinality: bool,
}
#[repr(C)]
pub struct ValuesScan {
    pub scan: Scan,
    pub values_lists: PgPtr<List>,
}
#[repr(C)]
pub struct TableFuncScan {
    pub scan: Scan,
    pub tablefunc: PgPtr<TableFunc>,
}
#[repr(C)]
pub struct CteScan {
    pub scan: Scan,
    pub ctePlanId: ::std::os::raw::c_int,
    pub cteParam: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct NamedTuplestoreScan {
    pub scan: Scan,
    pub enrname: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct WorkTableScan {
    pub scan: Scan,
    pub wtParam: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ForeignScan {
    pub scan: Scan,
    pub operation: CmdType,
    pub fs_server: Oid,
    pub fdw_exprs: PgPtr<List>,
    pub fdw_private: PgPtr<List>,
    pub fdw_scan_tlist: PgPtr<List>,
    pub fdw_recheck_quals: PgPtr<List>,
    pub fs_relids: PgPtr<Bitmapset>,
    pub fsSystemCol: bool,
}
#[repr(C)]
pub struct CustomScan {
    pub scan: Scan,
    pub flags: uint32,
    pub custom_plans: PgPtr<List>,
    pub custom_exprs: PgPtr<List>,
    pub custom_private: PgPtr<List>,
    pub custom_scan_tlist: PgPtr<List>,
    pub custom_relids: PgPtr<Bitmapset>,
    pub methods: PgPtr<CustomScanMethods>,
}
#[repr(C)]
pub struct Join {
    pub plan: Plan,
    pub jointype: JoinType,
    pub inner_unique: bool,
    pub joinqual: PgPtr<List>,
}
#[repr(C)]
pub struct NestLoop {
    pub join: Join,
    pub nestParams: PgPtr<List>,
}
#[repr(C)]
pub struct NestLoopParam {
    pub type_: NodeTag,
    pub paramno: ::std::os::raw::c_int,
    pub paramval: PgPtr<Var>,
}
#[repr(C)]
pub struct MergeJoin {
    pub join: Join,
    pub skip_mark_restore: bool,
    pub mergeclauses: PgPtr<List>,
    pub mergeFamilies: PgPtr<Oid>,
    pub mergeCollations: PgPtr<Oid>,
    pub mergeStrategies: PgPtr<::std::os::raw::c_int>,
    pub mergeNullsFirst: PgPtr<bool>,
}
#[repr(C)]
pub struct HashJoin {
    pub join: Join,
    pub hashclauses: PgPtr<List>,
    pub hashoperators: PgPtr<List>,
    pub hashcollations: PgPtr<List>,
    pub hashkeys: PgPtr<List>,
}
#[repr(C)]
pub struct Material {
    pub plan: Plan,
}
#[repr(C)]
pub struct Sort {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: PgPtr<AttrNumber>,
    pub sortOperators: PgPtr<Oid>,
    pub collations: PgPtr<Oid>,
    pub nullsFirst: PgPtr<bool>,
}
#[repr(C)]
pub struct Group {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: PgPtr<AttrNumber>,
    pub grpOperators: PgPtr<Oid>,
    pub grpCollations: PgPtr<Oid>,
}
#[repr(C)]
pub struct Agg {
    pub plan: Plan,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: PgPtr<AttrNumber>,
    pub grpOperators: PgPtr<Oid>,
    pub grpCollations: PgPtr<Oid>,
    pub numGroups: ::std::os::raw::c_long,
    pub aggParams: PgPtr<Bitmapset>,
    pub groupingSets: PgPtr<List>,
    pub chain: PgPtr<List>,
}
#[repr(C)]
pub struct WindowAgg {
    pub plan: Plan,
    pub winref: Index,
    pub partNumCols: ::std::os::raw::c_int,
    pub partColIdx: PgPtr<AttrNumber>,
    pub partOperators: PgPtr<Oid>,
    pub partCollations: PgPtr<Oid>,
    pub ordNumCols: ::std::os::raw::c_int,
    pub ordColIdx: PgPtr<AttrNumber>,
    pub ordOperators: PgPtr<Oid>,
    pub ordCollations: PgPtr<Oid>,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: PgPtr<Node>,
    pub endOffset: PgPtr<Node>,
    pub startInRangeFunc: Oid,
    pub endInRangeFunc: Oid,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
}
#[repr(C)]
pub struct Unique {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub uniqColIdx: PgPtr<AttrNumber>,
    pub uniqOperators: PgPtr<Oid>,
    pub uniqCollations: PgPtr<Oid>,
}
#[repr(C)]
pub struct Gather {
    pub plan: Plan,
    pub num_workers: ::std::os::raw::c_int,
    pub rescan_param: ::std::os::raw::c_int,
    pub single_copy: bool,
    pub invisible: bool,
    pub initParam: PgPtr<Bitmapset>,
}
#[repr(C)]
pub struct GatherMerge {
    pub plan: Plan,
    pub num_workers: ::std::os::raw::c_int,
    pub rescan_param: ::std::os::raw::c_int,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: PgPtr<AttrNumber>,
    pub sortOperators: PgPtr<Oid>,
    pub collations: PgPtr<Oid>,
    pub nullsFirst: PgPtr<bool>,
    pub initParam: PgPtr<Bitmapset>,
}
#[repr(C)]
pub struct Hash {
    pub plan: Plan,
    pub hashkeys: PgPtr<List>,
    pub skewTable: Oid,
    pub skewColumn: AttrNumber,
    pub skewInherit: bool,
    pub rows_total: f64,
}
#[repr(C)]
pub struct SetOp {
    pub plan: Plan,
    pub cmd: SetOpCmd,
    pub strategy: SetOpStrategy,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: PgPtr<AttrNumber>,
    pub dupOperators: PgPtr<Oid>,
    pub dupCollations: PgPtr<Oid>,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::std::os::raw::c_int,
    pub numGroups: ::std::os::raw::c_long,
}
#[repr(C)]
pub struct LockRows {
    pub plan: Plan,
    pub rowMarks: PgPtr<List>,
    pub epqParam: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct Limit {
    pub plan: Plan,
    pub limitOffset: PgPtr<Node>,
    pub limitCount: PgPtr<Node>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum RowMarkType {
    ROW_MARK_EXCLUSIVE = 0,
    ROW_MARK_NOKEYEXCLUSIVE = 1,
    ROW_MARK_SHARE = 2,
    ROW_MARK_KEYSHARE = 3,
    ROW_MARK_REFERENCE = 4,
    ROW_MARK_COPY = 5,
}
#[repr(C)]
pub struct PlanRowMark {
    pub type_: NodeTag,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub allMarkTypes: ::std::os::raw::c_int,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub isParent: bool,
}
#[repr(C)]
pub struct PartitionPruneInfo {
    pub type_: NodeTag,
    pub prune_infos: PgPtr<List>,
    pub other_subplans: PgPtr<Bitmapset>,
}
#[repr(C)]
pub struct PartitionedRelPruneInfo {
    pub type_: NodeTag,
    pub rtindex: Index,
    pub present_parts: PgPtr<Bitmapset>,
    pub nparts: ::std::os::raw::c_int,
    pub subplan_map: PgPtr<::std::os::raw::c_int>,
    pub subpart_map: PgPtr<::std::os::raw::c_int>,
    pub relid_map: PgPtr<Oid>,
    pub initial_pruning_steps: PgPtr<List>,
    pub exec_pruning_steps: PgPtr<List>,
    pub execparamids: PgPtr<Bitmapset>,
}
#[repr(C)]
pub struct PartitionPruneStep {
    pub type_: NodeTag,
    pub step_id: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct PartitionPruneStepOp {
    pub step: PartitionPruneStep,
    pub opstrategy: StrategyNumber,
    pub exprs: PgPtr<List>,
    pub cmpfns: PgPtr<List>,
    pub nullkeys: PgPtr<Bitmapset>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum PartitionPruneCombineOp {
    PARTPRUNE_COMBINE_UNION = 0,
    PARTPRUNE_COMBINE_INTERSECT = 1,
}
#[repr(C)]
pub struct PartitionPruneStepCombine {
    pub step: PartitionPruneStep,
    pub combineOp: PartitionPruneCombineOp,
    pub source_stepids: PgPtr<List>,
}
#[repr(C)]
pub struct PlanInvalItem {
    pub type_: NodeTag,
    pub cacheId: ::std::os::raw::c_int,
    pub hashValue: uint32,
}
#[repr(C)]
pub struct PartitionBoundInfoData {
    _unused: [u8; 0],
}
pub type PartitionBoundInfo = PgPtr<PartitionBoundInfoData>;
#[repr(C)]
pub struct PartitionKeyData {
    _unused: [u8; 0],
}
pub type PartitionKey = PgPtr<PartitionKeyData>;
#[repr(C)]
pub struct PartitionDescData {
    _unused: [u8; 0],
}
pub type PartitionDesc = PgPtr<PartitionDescData>;
#[repr(C)]
pub struct PartitionDirectoryData {
    _unused: [u8; 0],
}
pub type PartitionDirectory = PgPtr<PartitionDirectoryData>;
pub type HashValueFunc = ::std::option::Option<
    unsafe extern "C" fn(key: PgPtr<::std::os::raw::c_void>, keysize: Size) -> uint32,
>;
pub type HashCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(
        key1: PgPtr<::std::os::raw::c_void>,
        key2: PgPtr<::std::os::raw::c_void>,
        keysize: Size,
    ) -> ::std::os::raw::c_int,
>;
pub type HashCopyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        dest: PgPtr<::std::os::raw::c_void>,
        src: PgPtr<::std::os::raw::c_void>,
        keysize: Size,
    ) -> PgPtr<::std::os::raw::c_void>,
>;
pub type HashAllocFunc =
    ::std::option::Option<unsafe extern "C" fn(request: Size) -> PgPtr<::std::os::raw::c_void>>;
#[repr(C)]
pub struct HASHELEMENT {
    pub link: PgPtr<HASHELEMENT>,
    pub hashvalue: uint32,
}
#[repr(C)]
pub struct HASHHDR {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct HTAB {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct HASHCTL {
    pub num_partitions: ::std::os::raw::c_long,
    pub ssize: ::std::os::raw::c_long,
    pub dsize: ::std::os::raw::c_long,
    pub max_dsize: ::std::os::raw::c_long,
    pub ffactor: ::std::os::raw::c_long,
    pub keysize: Size,
    pub entrysize: Size,
    pub hash: HashValueFunc,
    pub match_: HashCompareFunc,
    pub keycopy: HashCopyFunc,
    pub alloc: HashAllocFunc,
    pub hcxt: PgPtr<MemoryContextData>,
    pub hctl: PgPtr<HASHHDR>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum HASHACTION {
    HASH_FIND = 0,
    HASH_ENTER = 1,
    HASH_REMOVE = 2,
    HASH_ENTER_NULL = 3,
}
#[repr(C)]
pub struct HASH_SEQ_STATUS {
    pub hashp: PgPtr<HTAB>,
    pub curBucket: uint32,
    pub curEntry: PgPtr<HASHELEMENT>,
}
#[pg_guard]
extern "C" {
    pub fn hash_create(
        tabname: PgPtr<::std::os::raw::c_char>,
        nelem: ::std::os::raw::c_long,
        info: PgPtr<HASHCTL>,
        flags: ::std::os::raw::c_int,
    ) -> PgPtr<HTAB>;
}
#[pg_guard]
extern "C" {
    pub fn hash_destroy(hashp: PgPtr<HTAB>);
}
#[pg_guard]
extern "C" {
    pub fn hash_stats(where_: PgPtr<::std::os::raw::c_char>, hashp: PgPtr<HTAB>);
}
#[pg_guard]
extern "C" {
    pub fn hash_search(
        hashp: PgPtr<HTAB>,
        keyPtr: PgPtr<::std::os::raw::c_void>,
        action: HASHACTION,
        foundPtr: PgPtr<bool>,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn get_hash_value(hashp: PgPtr<HTAB>, keyPtr: PgPtr<::std::os::raw::c_void>) -> uint32;
}
#[pg_guard]
extern "C" {
    pub fn hash_search_with_hash_value(
        hashp: PgPtr<HTAB>,
        keyPtr: PgPtr<::std::os::raw::c_void>,
        hashvalue: uint32,
        action: HASHACTION,
        foundPtr: PgPtr<bool>,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn hash_update_hash_key(
        hashp: PgPtr<HTAB>,
        existingEntry: PgPtr<::std::os::raw::c_void>,
        newKeyPtr: PgPtr<::std::os::raw::c_void>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn hash_get_num_entries(hashp: PgPtr<HTAB>) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn hash_seq_init(status: PgPtr<HASH_SEQ_STATUS>, hashp: PgPtr<HTAB>);
}
#[pg_guard]
extern "C" {
    pub fn hash_seq_search(status: PgPtr<HASH_SEQ_STATUS>) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn hash_seq_term(status: PgPtr<HASH_SEQ_STATUS>);
}
#[pg_guard]
extern "C" {
    pub fn hash_freeze(hashp: PgPtr<HTAB>);
}
#[pg_guard]
extern "C" {
    pub fn hash_estimate_size(num_entries: ::std::os::raw::c_long, entrysize: Size) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn hash_select_dirsize(num_entries: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn hash_get_shared_size(info: PgPtr<HASHCTL>, flags: ::std::os::raw::c_int) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn AtEOXact_HashTables(isCommit: bool);
}
#[pg_guard]
extern "C" {
    pub fn AtEOSubXact_HashTables(isCommit: bool, nestDepth: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn string_hash(key: PgPtr<::std::os::raw::c_void>, keysize: Size) -> uint32;
}
#[pg_guard]
extern "C" {
    pub fn tag_hash(key: PgPtr<::std::os::raw::c_void>, keysize: Size) -> uint32;
}
#[pg_guard]
extern "C" {
    pub fn uint32_hash(key: PgPtr<::std::os::raw::c_void>, keysize: Size) -> uint32;
}
#[pg_guard]
extern "C" {
    pub fn bitmap_hash(key: PgPtr<::std::os::raw::c_void>, keysize: Size) -> uint32;
}
#[pg_guard]
extern "C" {
    pub fn bitmap_match(
        key1: PgPtr<::std::os::raw::c_void>,
        key2: PgPtr<::std::os::raw::c_void>,
        keysize: Size,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum EphemeralNameRelationType {
    ENR_NAMED_TUPLESTORE = 0,
}
#[repr(C)]
pub struct EphemeralNamedRelationMetadataData {
    pub name: PgPtr<::std::os::raw::c_char>,
    pub reliddesc: Oid,
    pub tupdesc: PgPtr<TupleDescData>,
    pub enrtype: EphemeralNameRelationType,
    pub enrtuples: f64,
}
pub type EphemeralNamedRelationMetadata = PgPtr<EphemeralNamedRelationMetadataData>;
#[repr(C)]
pub struct EphemeralNamedRelationData {
    pub md: EphemeralNamedRelationMetadataData,
    pub reldata: PgPtr<::std::os::raw::c_void>,
}
pub type EphemeralNamedRelation = PgPtr<EphemeralNamedRelationData>;
#[repr(C)]
pub struct QueryEnvironment {
    _unused: [u8; 0],
}
#[pg_guard]
extern "C" {
    pub fn create_queryEnv() -> PgPtr<QueryEnvironment>;
}
#[pg_guard]
extern "C" {
    pub fn get_visible_ENR_metadata(
        queryEnv: PgPtr<QueryEnvironment>,
        refname: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<EphemeralNamedRelationMetadataData>;
}
#[pg_guard]
extern "C" {
    pub fn register_ENR(queryEnv: PgPtr<QueryEnvironment>, enr: PgPtr<EphemeralNamedRelationData>);
}
#[pg_guard]
extern "C" {
    pub fn unregister_ENR(queryEnv: PgPtr<QueryEnvironment>, name: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn get_ENR(
        queryEnv: PgPtr<QueryEnvironment>,
        name: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<EphemeralNamedRelationData>;
}
#[pg_guard]
extern "C" {
    pub fn ENRMetadataGetTupDesc(
        enrmd: PgPtr<EphemeralNamedRelationMetadataData>,
    ) -> PgPtr<TupleDescData>;
}
#[repr(C)]
pub struct Trigger {
    pub tgoid: Oid,
    pub tgname: PgPtr<::std::os::raw::c_char>,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::std::os::raw::c_char,
    pub tgisinternal: bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: bool,
    pub tginitdeferred: bool,
    pub tgnargs: int16,
    pub tgnattr: int16,
    pub tgattr: PgPtr<int16>,
    pub tgargs: PgPtr<PgPtr<::std::os::raw::c_char>>,
    pub tgqual: PgPtr<::std::os::raw::c_char>,
    pub tgoldtable: PgPtr<::std::os::raw::c_char>,
    pub tgnewtable: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct TriggerDesc {
    pub triggers: PgPtr<Trigger>,
    pub numtriggers: ::std::os::raw::c_int,
    pub trig_insert_before_row: bool,
    pub trig_insert_after_row: bool,
    pub trig_insert_instead_row: bool,
    pub trig_insert_before_statement: bool,
    pub trig_insert_after_statement: bool,
    pub trig_update_before_row: bool,
    pub trig_update_after_row: bool,
    pub trig_update_instead_row: bool,
    pub trig_update_before_statement: bool,
    pub trig_update_after_statement: bool,
    pub trig_delete_before_row: bool,
    pub trig_delete_after_row: bool,
    pub trig_delete_instead_row: bool,
    pub trig_delete_before_statement: bool,
    pub trig_delete_after_statement: bool,
    pub trig_truncate_before_statement: bool,
    pub trig_truncate_after_statement: bool,
    pub trig_insert_new_table: bool,
    pub trig_update_old_table: bool,
    pub trig_update_new_table: bool,
    pub trig_delete_old_table: bool,
}
#[repr(C)]
pub struct dirent {
    pub d_ino: __uint64_t,
    pub d_seekoff: __uint64_t,
    pub d_reclen: __uint16_t,
    pub d_namlen: __uint16_t,
    pub d_type: __uint8_t,
    pub d_name: [::std::os::raw::c_char; 1024usize],
}
#[repr(C)]
pub struct _telldir {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct DIR {
    pub __dd_fd: ::std::os::raw::c_int,
    pub __dd_loc: ::std::os::raw::c_long,
    pub __dd_size: ::std::os::raw::c_long,
    pub __dd_buf: PgPtr<::std::os::raw::c_char>,
    pub __dd_len: ::std::os::raw::c_int,
    pub __dd_seek: ::std::os::raw::c_long,
    pub __padding: ::std::os::raw::c_long,
    pub __dd_flags: ::std::os::raw::c_int,
    pub __dd_lock: __darwin_pthread_mutex_t,
    pub __dd_td: PgPtr<_telldir>,
}
#[pg_guard]
extern "C" {
    pub fn closedir(arg1: PgPtr<DIR>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_opendir$INODE64"]
    pub fn opendir(arg1: PgPtr<::std::os::raw::c_char>) -> PgPtr<DIR>;
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_readdir$INODE64"]
    pub fn readdir(arg1: PgPtr<DIR>) -> PgPtr<dirent>;
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_readdir_r$INODE64"]
    pub fn readdir_r(
        arg1: PgPtr<DIR>,
        arg2: PgPtr<dirent>,
        arg3: PgPtr<PgPtr<dirent>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_rewinddir$INODE64"]
    pub fn rewinddir(arg1: PgPtr<DIR>);
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_seekdir$INODE64"]
    pub fn seekdir(arg1: PgPtr<DIR>, arg2: ::std::os::raw::c_long);
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_telldir$INODE64"]
    pub fn telldir(arg1: PgPtr<DIR>) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_fdopendir$INODE64"]
    pub fn fdopendir(arg1: ::std::os::raw::c_int) -> PgPtr<DIR>;
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_alphasort$INODE64"]
    pub fn alphasort(
        arg1: PgPtr<PgPtr<dirent>>,
        arg2: PgPtr<PgPtr<dirent>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn dirfd(dirp: PgPtr<DIR>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_scandir$INODE64"]
    pub fn scandir(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<PgPtr<PgPtr<dirent>>>,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: PgPtr<dirent>) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: PgPtr<PgPtr<dirent>>,
                arg2: PgPtr<PgPtr<dirent>>,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_scandir_b$INODE64"]
    pub fn scandir_b(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: PgPtr<PgPtr<PgPtr<dirent>>>,
        arg3: PgPtr<::std::os::raw::c_void>,
        arg4: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}_getdirentries_is_not_available_when_64_bit_inodes_are_in_effect"]
    pub fn getdirentries(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<::std::os::raw::c_char>,
        arg3: ::std::os::raw::c_int,
        arg4: PgPtr<::std::os::raw::c_long>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    #[link_name = "\u{1}___opendir2$INODE64"]
    pub fn __opendir2(
        arg1: PgPtr<::std::os::raw::c_char>,
        arg2: ::std::os::raw::c_int,
    ) -> PgPtr<DIR>;
}
pub type File = ::std::os::raw::c_int;
#[pg_guard]
extern "C" {
    pub static mut max_files_per_process: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut data_sync_retry: bool;
}
#[pg_guard]
extern "C" {
    pub static mut max_safe_fds: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn PathNameOpenFile(
        fileName: PgPtr<::std::os::raw::c_char>,
        fileFlags: ::std::os::raw::c_int,
    ) -> File;
}
#[pg_guard]
extern "C" {
    pub fn PathNameOpenFilePerm(
        fileName: PgPtr<::std::os::raw::c_char>,
        fileFlags: ::std::os::raw::c_int,
        fileMode: mode_t,
    ) -> File;
}
#[pg_guard]
extern "C" {
    pub fn OpenTemporaryFile(interXact: bool) -> File;
}
#[pg_guard]
extern "C" {
    pub fn FileClose(file: File);
}
#[pg_guard]
extern "C" {
    pub fn FilePrefetch(
        file: File,
        offset: off_t,
        amount: ::std::os::raw::c_int,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn FileRead(
        file: File,
        buffer: PgPtr<::std::os::raw::c_char>,
        amount: ::std::os::raw::c_int,
        offset: off_t,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn FileWrite(
        file: File,
        buffer: PgPtr<::std::os::raw::c_char>,
        amount: ::std::os::raw::c_int,
        offset: off_t,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn FileSync(file: File, wait_event_info: uint32) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn FileSize(file: File) -> off_t;
}
#[pg_guard]
extern "C" {
    pub fn FileTruncate(
        file: File,
        offset: off_t,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn FileWriteback(file: File, offset: off_t, nbytes: off_t, wait_event_info: uint32);
}
#[pg_guard]
extern "C" {
    pub fn FilePathName(file: File) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn FileGetRawDesc(file: File) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn FileGetRawFlags(file: File) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn FileGetRawMode(file: File) -> mode_t;
}
#[pg_guard]
extern "C" {
    pub fn PathNameCreateTemporaryFile(
        name: PgPtr<::std::os::raw::c_char>,
        error_on_failure: bool,
    ) -> File;
}
#[pg_guard]
extern "C" {
    pub fn PathNameOpenTemporaryFile(name: PgPtr<::std::os::raw::c_char>) -> File;
}
#[pg_guard]
extern "C" {
    pub fn PathNameDeleteTemporaryFile(
        name: PgPtr<::std::os::raw::c_char>,
        error_on_failure: bool,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn PathNameCreateTemporaryDir(
        base: PgPtr<::std::os::raw::c_char>,
        name: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn PathNameDeleteTemporaryDir(name: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn TempTablespacePath(path: PgPtr<::std::os::raw::c_char>, tablespace: Oid);
}
#[pg_guard]
extern "C" {
    pub fn AllocateFile(
        name: PgPtr<::std::os::raw::c_char>,
        mode: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub fn FreeFile(file: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn OpenPipeStream(
        command: PgPtr<::std::os::raw::c_char>,
        mode: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<FILE>;
}
#[pg_guard]
extern "C" {
    pub fn ClosePipeStream(file: PgPtr<FILE>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn AllocateDir(dirname: PgPtr<::std::os::raw::c_char>) -> PgPtr<DIR>;
}
#[pg_guard]
extern "C" {
    pub fn ReadDir(dir: PgPtr<DIR>, dirname: PgPtr<::std::os::raw::c_char>) -> PgPtr<dirent>;
}
#[pg_guard]
extern "C" {
    pub fn ReadDirExtended(
        dir: PgPtr<DIR>,
        dirname: PgPtr<::std::os::raw::c_char>,
        elevel: ::std::os::raw::c_int,
    ) -> PgPtr<dirent>;
}
#[pg_guard]
extern "C" {
    pub fn FreeDir(dir: PgPtr<DIR>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn OpenTransientFile(
        fileName: PgPtr<::std::os::raw::c_char>,
        fileFlags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn OpenTransientFilePerm(
        fileName: PgPtr<::std::os::raw::c_char>,
        fileFlags: ::std::os::raw::c_int,
        fileMode: mode_t,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn CloseTransientFile(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn BasicOpenFile(
        fileName: PgPtr<::std::os::raw::c_char>,
        fileFlags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn BasicOpenFilePerm(
        fileName: PgPtr<::std::os::raw::c_char>,
        fileFlags: ::std::os::raw::c_int,
        fileMode: mode_t,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn MakePGDirectory(directoryName: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn InitFileAccess();
}
#[pg_guard]
extern "C" {
    pub fn set_max_safe_fds();
}
#[pg_guard]
extern "C" {
    pub fn closeAllVfds();
}
#[pg_guard]
extern "C" {
    pub fn SetTempTablespaces(tableSpaces: PgPtr<Oid>, numSpaces: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn TempTablespacesAreSet() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetTempTablespaces(
        tableSpaces: PgPtr<Oid>,
        numSpaces: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn GetNextTempTableSpace() -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn AtEOXact_Files(isCommit: bool);
}
#[pg_guard]
extern "C" {
    pub fn AtEOSubXact_Files(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
}
#[pg_guard]
extern "C" {
    pub fn RemovePgTempFiles();
}
#[pg_guard]
extern "C" {
    pub fn looks_like_temp_rel_name(name: PgPtr<::std::os::raw::c_char>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_fsync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_fsync_no_writethrough(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_fsync_writethrough(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_fdatasync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_flush_data(fd: ::std::os::raw::c_int, offset: off_t, amount: off_t);
}
#[pg_guard]
extern "C" {
    pub fn fsync_fname(fname: PgPtr<::std::os::raw::c_char>, isdir: bool);
}
#[pg_guard]
extern "C" {
    pub fn durable_rename(
        oldfile: PgPtr<::std::os::raw::c_char>,
        newfile: PgPtr<::std::os::raw::c_char>,
        loglevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn durable_unlink(
        fname: PgPtr<::std::os::raw::c_char>,
        loglevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn durable_link_or_rename(
        oldfile: PgPtr<::std::os::raw::c_char>,
        newfile: PgPtr<::std::os::raw::c_char>,
        loglevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SyncDataDirectory();
}
#[pg_guard]
extern "C" {
    pub fn data_sync_elevel(elevel: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut dynamic_shared_memory_type: ::std::os::raw::c_int;
}
pub type dsm_handle = uint32;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum dsm_op {
    DSM_OP_CREATE = 0,
    DSM_OP_ATTACH = 1,
    DSM_OP_DETACH = 2,
    DSM_OP_DESTROY = 3,
}
#[pg_guard]
extern "C" {
    pub fn dsm_impl_op(
        op: dsm_op,
        handle: dsm_handle,
        request_size: Size,
        impl_private: PgPtr<PgPtr<::std::os::raw::c_void>>,
        mapped_address: PgPtr<PgPtr<::std::os::raw::c_void>>,
        mapped_size: PgPtr<Size>,
        elevel: ::std::os::raw::c_int,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn dsm_impl_pin_segment(
        handle: dsm_handle,
        impl_private: PgPtr<::std::os::raw::c_void>,
        impl_private_pm_handle: PgPtr<PgPtr<::std::os::raw::c_void>>,
    );
}
#[pg_guard]
extern "C" {
    pub fn dsm_impl_unpin_segment(
        handle: dsm_handle,
        impl_private: PgPtr<PgPtr<::std::os::raw::c_void>>,
    );
}
#[repr(C)]
pub struct dsm_segment {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct PGShmemHeader {
    _unused: [u8; 0],
}
#[pg_guard]
extern "C" {
    pub fn dsm_cleanup_using_control_segment(old_control_handle: dsm_handle);
}
#[pg_guard]
extern "C" {
    pub fn dsm_postmaster_startup(arg1: PgPtr<PGShmemHeader>);
}
#[pg_guard]
extern "C" {
    pub fn dsm_backend_shutdown();
}
#[pg_guard]
extern "C" {
    pub fn dsm_detach_all();
}
#[pg_guard]
extern "C" {
    pub fn dsm_create(size: Size, flags: ::std::os::raw::c_int) -> PgPtr<dsm_segment>;
}
#[pg_guard]
extern "C" {
    pub fn dsm_attach(h: dsm_handle) -> PgPtr<dsm_segment>;
}
#[pg_guard]
extern "C" {
    pub fn dsm_detach(seg: PgPtr<dsm_segment>);
}
#[pg_guard]
extern "C" {
    pub fn dsm_pin_mapping(seg: PgPtr<dsm_segment>);
}
#[pg_guard]
extern "C" {
    pub fn dsm_unpin_mapping(seg: PgPtr<dsm_segment>);
}
#[pg_guard]
extern "C" {
    pub fn dsm_pin_segment(seg: PgPtr<dsm_segment>);
}
#[pg_guard]
extern "C" {
    pub fn dsm_unpin_segment(h: dsm_handle);
}
#[pg_guard]
extern "C" {
    pub fn dsm_find_mapping(h: dsm_handle) -> PgPtr<dsm_segment>;
}
#[pg_guard]
extern "C" {
    pub fn dsm_segment_address(seg: PgPtr<dsm_segment>) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn dsm_segment_map_length(seg: PgPtr<dsm_segment>) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn dsm_segment_handle(seg: PgPtr<dsm_segment>) -> dsm_handle;
}
pub type on_dsm_detach_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: PgPtr<dsm_segment>, arg: Datum)>;
#[pg_guard]
extern "C" {
    pub fn on_dsm_detach(seg: PgPtr<dsm_segment>, function: on_dsm_detach_callback, arg: Datum);
}
#[pg_guard]
extern "C" {
    pub fn cancel_on_dsm_detach(
        seg: PgPtr<dsm_segment>,
        function: on_dsm_detach_callback,
        arg: Datum,
    );
}
#[pg_guard]
extern "C" {
    pub fn reset_on_dsm_detach();
}
pub type slock_t = ::std::os::raw::c_uchar;
#[pg_guard]
extern "C" {
    pub static mut dummy_spinlock: slock_t;
}
#[pg_guard]
extern "C" {
    pub fn s_lock(
        lock: PgPtr<slock_t>,
        file: PgPtr<::std::os::raw::c_char>,
        line: ::std::os::raw::c_int,
        func: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn set_spins_per_delay(shared_spins_per_delay: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn update_spins_per_delay(
        shared_spins_per_delay: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct SpinDelayStatus {
    pub spins: ::std::os::raw::c_int,
    pub delays: ::std::os::raw::c_int,
    pub cur_delay: ::std::os::raw::c_int,
    pub file: PgPtr<::std::os::raw::c_char>,
    pub line: ::std::os::raw::c_int,
    pub func: PgPtr<::std::os::raw::c_char>,
}
#[pg_guard]
extern "C" {
    pub fn perform_spin_delay(status: PgPtr<SpinDelayStatus>);
}
#[pg_guard]
extern "C" {
    pub fn finish_spin_delay(status: PgPtr<SpinDelayStatus>);
}
#[pg_guard]
extern "C" {
    pub fn SpinlockSemas() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SpinlockSemaSize() -> Size;
}
#[repr(C)]
pub struct SharedFileSet {
    pub creator_pid: pid_t,
    pub number: uint32,
    pub mutex: slock_t,
    pub refcnt: ::std::os::raw::c_int,
    pub ntablespaces: ::std::os::raw::c_int,
    pub tablespaces: [Oid; 8usize],
}
#[pg_guard]
extern "C" {
    pub fn SharedFileSetInit(fileset: PgPtr<SharedFileSet>, seg: PgPtr<dsm_segment>);
}
#[pg_guard]
extern "C" {
    pub fn SharedFileSetAttach(fileset: PgPtr<SharedFileSet>, seg: PgPtr<dsm_segment>);
}
#[pg_guard]
extern "C" {
    pub fn SharedFileSetCreate(
        fileset: PgPtr<SharedFileSet>,
        name: PgPtr<::std::os::raw::c_char>,
    ) -> File;
}
#[pg_guard]
extern "C" {
    pub fn SharedFileSetOpen(
        fileset: PgPtr<SharedFileSet>,
        name: PgPtr<::std::os::raw::c_char>,
    ) -> File;
}
#[pg_guard]
extern "C" {
    pub fn SharedFileSetDelete(
        fileset: PgPtr<SharedFileSet>,
        name: PgPtr<::std::os::raw::c_char>,
        error_on_failure: bool,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn SharedFileSetDeleteAll(fileset: PgPtr<SharedFileSet>);
}
#[repr(C)]
pub struct SharedTuplestore {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct SharedTuplestoreAccessor {
    _unused: [u8; 0],
}
#[pg_guard]
extern "C" {
    pub fn sts_estimate(participants: ::std::os::raw::c_int) -> usize;
}
#[pg_guard]
extern "C" {
    pub fn sts_initialize(
        sts: PgPtr<SharedTuplestore>,
        participants: ::std::os::raw::c_int,
        my_participant_number: ::std::os::raw::c_int,
        meta_data_size: usize,
        flags: ::std::os::raw::c_int,
        fileset: PgPtr<SharedFileSet>,
        name: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<SharedTuplestoreAccessor>;
}
#[pg_guard]
extern "C" {
    pub fn sts_attach(
        sts: PgPtr<SharedTuplestore>,
        my_participant_number: ::std::os::raw::c_int,
        fileset: PgPtr<SharedFileSet>,
    ) -> PgPtr<SharedTuplestoreAccessor>;
}
#[pg_guard]
extern "C" {
    pub fn sts_end_write(accessor: PgPtr<SharedTuplestoreAccessor>);
}
#[pg_guard]
extern "C" {
    pub fn sts_reinitialize(accessor: PgPtr<SharedTuplestoreAccessor>);
}
#[pg_guard]
extern "C" {
    pub fn sts_begin_parallel_scan(accessor: PgPtr<SharedTuplestoreAccessor>);
}
#[pg_guard]
extern "C" {
    pub fn sts_end_parallel_scan(accessor: PgPtr<SharedTuplestoreAccessor>);
}
#[pg_guard]
extern "C" {
    pub fn sts_puttuple(
        accessor: PgPtr<SharedTuplestoreAccessor>,
        meta_data: PgPtr<::std::os::raw::c_void>,
        tuple: PgPtr<MinimalTupleData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn sts_parallel_scan_next(
        accessor: PgPtr<SharedTuplestoreAccessor>,
        meta_data: PgPtr<::std::os::raw::c_void>,
    ) -> PgPtr<MinimalTupleData>;
}
pub type Timestamp = int64;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
pub type fsec_t = int32;
#[repr(C)]
pub struct Interval {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SnapshotType {
    SNAPSHOT_MVCC = 0,
    SNAPSHOT_SELF = 1,
    SNAPSHOT_ANY = 2,
    SNAPSHOT_TOAST = 3,
    SNAPSHOT_DIRTY = 4,
    SNAPSHOT_HISTORIC_MVCC = 5,
    SNAPSHOT_NON_VACUUMABLE = 6,
}
pub type Snapshot = PgPtr<SnapshotData>;
#[repr(C)]
pub struct SnapshotData {
    pub snapshot_type: SnapshotType,
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub xip: PgPtr<TransactionId>,
    pub xcnt: uint32,
    pub subxip: PgPtr<TransactionId>,
    pub subxcnt: int32,
    pub suboverflowed: bool,
    pub takenDuringRecovery: bool,
    pub copied: bool,
    pub curcid: CommandId,
    pub speculativeToken: uint32,
    pub active_count: uint32,
    pub regd_count: uint32,
    pub ph_node: pairingheap_node,
    pub whenTaken: TimestampTz,
    pub lsn: XLogRecPtr,
}
pub type Relation = PgPtr<RelationData>;
pub type RelationPtr = PgPtr<PgPtr<RelationData>>;
#[pg_guard]
extern "C" {
    pub fn RelationIdGetRelation(relationId: Oid) -> PgPtr<RelationData>;
}
#[pg_guard]
extern "C" {
    pub fn RelationClose(relation: PgPtr<RelationData>);
}
#[pg_guard]
extern "C" {
    pub fn RelationGetFKeyList(relation: PgPtr<RelationData>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn RelationGetIndexList(relation: PgPtr<RelationData>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn RelationGetStatExtList(relation: PgPtr<RelationData>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn RelationGetPrimaryKeyIndex(relation: PgPtr<RelationData>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn RelationGetReplicaIndex(relation: PgPtr<RelationData>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn RelationGetIndexExpressions(relation: PgPtr<RelationData>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn RelationGetDummyIndexExpressions(relation: PgPtr<RelationData>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn RelationGetIndexPredicate(relation: PgPtr<RelationData>) -> PgPtr<List>;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum IndexAttrBitmapKind {
    INDEX_ATTR_BITMAP_ALL = 0,
    INDEX_ATTR_BITMAP_KEY = 1,
    INDEX_ATTR_BITMAP_PRIMARY_KEY = 2,
    INDEX_ATTR_BITMAP_IDENTITY_KEY = 3,
}
#[pg_guard]
extern "C" {
    pub fn RelationGetIndexAttrBitmap(
        relation: PgPtr<RelationData>,
        keyAttrs: IndexAttrBitmapKind,
    ) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn RelationGetExclusionInfo(
        indexRelation: PgPtr<RelationData>,
        operators: PgPtr<PgPtr<Oid>>,
        procs: PgPtr<PgPtr<Oid>>,
        strategies: PgPtr<PgPtr<uint16>>,
    );
}
#[pg_guard]
extern "C" {
    pub fn RelationInitIndexAccessInfo(relation: PgPtr<RelationData>);
}
#[pg_guard]
extern "C" {
    pub fn GetRelationPublicationActions(
        relation: PgPtr<RelationData>,
    ) -> PgPtr<PublicationActions>;
}
#[pg_guard]
extern "C" {
    pub fn RelationInitTableAccessMethod(relation: PgPtr<RelationData>);
}
#[pg_guard]
extern "C" {
    pub fn errtable(rel: PgPtr<RelationData>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errtablecol(
        rel: PgPtr<RelationData>,
        attnum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errtablecolname(
        rel: PgPtr<RelationData>,
        colname: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errtableconstraint(
        rel: PgPtr<RelationData>,
        conname: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn RelationCacheInitialize();
}
#[pg_guard]
extern "C" {
    pub fn RelationCacheInitializePhase2();
}
#[pg_guard]
extern "C" {
    pub fn RelationCacheInitializePhase3();
}
#[pg_guard]
extern "C" {
    pub fn RelationBuildLocalRelation(
        relname: PgPtr<::std::os::raw::c_char>,
        relnamespace: Oid,
        tupDesc: PgPtr<TupleDescData>,
        relid: Oid,
        accessmtd: Oid,
        relfilenode: Oid,
        reltablespace: Oid,
        shared_relation: bool,
        mapped_relation: bool,
        relpersistence: ::std::os::raw::c_char,
        relkind: ::std::os::raw::c_char,
    ) -> PgPtr<RelationData>;
}
#[pg_guard]
extern "C" {
    pub fn RelationSetNewRelfilenode(
        relation: PgPtr<RelationData>,
        persistence: ::std::os::raw::c_char,
    );
}
#[pg_guard]
extern "C" {
    pub fn RelationForgetRelation(rid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn RelationCacheInvalidateEntry(relationId: Oid);
}
#[pg_guard]
extern "C" {
    pub fn RelationCacheInvalidate();
}
#[pg_guard]
extern "C" {
    pub fn RelationCloseSmgrByOid(relationId: Oid);
}
#[pg_guard]
extern "C" {
    pub fn AtEOXact_RelationCache(isCommit: bool);
}
#[pg_guard]
extern "C" {
    pub fn AtEOSubXact_RelationCache(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
}
#[pg_guard]
extern "C" {
    pub fn RelationIdIsInInitFile(relationId: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn RelationCacheInitFilePreInvalidate();
}
#[pg_guard]
extern "C" {
    pub fn RelationCacheInitFilePostInvalidate();
}
#[pg_guard]
extern "C" {
    pub fn RelationCacheInitFileRemove();
}
#[pg_guard]
extern "C" {
    pub static mut criticalRelcachesBuilt: bool;
}
#[pg_guard]
extern "C" {
    pub static mut criticalSharedRelcachesBuilt: bool;
}
pub type SortSupport = PgPtr<SortSupportData>;
#[repr(C)]
pub struct SortSupportData {
    pub ssup_cxt: PgPtr<MemoryContextData>,
    pub ssup_collation: Oid,
    pub ssup_reverse: bool,
    pub ssup_nulls_first: bool,
    pub ssup_attno: AttrNumber,
    pub ssup_extra: PgPtr<::std::os::raw::c_void>,
    pub comparator: ::std::option::Option<
        unsafe extern "C" fn(
            x: Datum,
            y: Datum,
            ssup: PgPtr<SortSupportData>,
        ) -> ::std::os::raw::c_int,
    >,
    pub abbreviate: bool,
    pub abbrev_converter: ::std::option::Option<
        unsafe extern "C" fn(original: Datum, ssup: PgPtr<SortSupportData>) -> Datum,
    >,
    pub abbrev_abort: ::std::option::Option<
        unsafe extern "C" fn(
            memtupcount: ::std::os::raw::c_int,
            ssup: PgPtr<SortSupportData>,
        ) -> bool,
    >,
    pub abbrev_full_comparator: ::std::option::Option<
        unsafe extern "C" fn(
            x: Datum,
            y: Datum,
            ssup: PgPtr<SortSupportData>,
        ) -> ::std::os::raw::c_int,
    >,
}
#[pg_guard]
extern "C" {
    pub fn PrepareSortSupportComparisonShim(cmpFunc: Oid, ssup: PgPtr<SortSupportData>);
}
#[pg_guard]
extern "C" {
    pub fn PrepareSortSupportFromOrderingOp(orderingOp: Oid, ssup: PgPtr<SortSupportData>);
}
#[pg_guard]
extern "C" {
    pub fn PrepareSortSupportFromIndexRel(
        indexRel: PgPtr<RelationData>,
        strategy: int16,
        ssup: PgPtr<SortSupportData>,
    );
}
#[repr(C)]
pub struct Tuplestorestate {
    _unused: [u8; 0],
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_begin_heap(
        randomAccess: bool,
        interXact: bool,
        maxKBytes: ::std::os::raw::c_int,
    ) -> PgPtr<Tuplestorestate>;
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_set_eflags(state: PgPtr<Tuplestorestate>, eflags: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_puttupleslot(state: PgPtr<Tuplestorestate>, slot: PgPtr<TupleTableSlot>);
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_puttuple(state: PgPtr<Tuplestorestate>, tuple: PgPtr<HeapTupleData>);
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_putvalues(
        state: PgPtr<Tuplestorestate>,
        tdesc: PgPtr<TupleDescData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
    );
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_alloc_read_pointer(
        state: PgPtr<Tuplestorestate>,
        eflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_select_read_pointer(
        state: PgPtr<Tuplestorestate>,
        ptr: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_copy_read_pointer(
        state: PgPtr<Tuplestorestate>,
        srcptr: ::std::os::raw::c_int,
        destptr: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_trim(state: PgPtr<Tuplestorestate>);
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_in_memory(state: PgPtr<Tuplestorestate>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_gettupleslot(
        state: PgPtr<Tuplestorestate>,
        forward: bool,
        copy: bool,
        slot: PgPtr<TupleTableSlot>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_advance(state: PgPtr<Tuplestorestate>, forward: bool) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_skiptuples(
        state: PgPtr<Tuplestorestate>,
        ntuples: int64,
        forward: bool,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_tuple_count(state: PgPtr<Tuplestorestate>) -> int64;
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_ateof(state: PgPtr<Tuplestorestate>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_rescan(state: PgPtr<Tuplestorestate>);
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_clear(state: PgPtr<Tuplestorestate>);
}
#[pg_guard]
extern "C" {
    pub fn tuplestore_end(state: PgPtr<Tuplestorestate>);
}
#[repr(C)]
pub struct IndexTupleData {
    pub t_tid: ItemPointerData,
    pub t_info: ::std::os::raw::c_ushort,
}
pub type IndexTuple = PgPtr<IndexTupleData>;
#[repr(C)]
pub struct IndexAttributeBitMapData {
    pub bits: [bits8; 4usize],
}
pub type IndexAttributeBitMap = PgPtr<IndexAttributeBitMapData>;
#[pg_guard]
extern "C" {
    pub fn index_form_tuple(
        tupleDescriptor: PgPtr<TupleDescData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
    ) -> PgPtr<IndexTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn nocache_index_getattr(
        tup: PgPtr<IndexTupleData>,
        attnum: ::std::os::raw::c_int,
        tupleDesc: PgPtr<TupleDescData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn index_deform_tuple(
        tup: PgPtr<IndexTupleData>,
        tupleDescriptor: PgPtr<TupleDescData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
    );
}
#[pg_guard]
extern "C" {
    pub fn CopyIndexTuple(source: PgPtr<IndexTupleData>) -> PgPtr<IndexTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn index_truncate_tuple(
        sourceDescriptor: PgPtr<TupleDescData>,
        source: PgPtr<IndexTupleData>,
        leavenatts: ::std::os::raw::c_int,
    ) -> PgPtr<IndexTupleData>;
}
#[repr(C)]
pub struct Tuplesortstate {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct Sharedsort {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct SortCoordinateData {
    pub isWorker: bool,
    pub nParticipants: ::std::os::raw::c_int,
    pub sharedsort: PgPtr<Sharedsort>,
}
pub type SortCoordinate = PgPtr<SortCoordinateData>;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum TuplesortMethod {
    SORT_TYPE_STILL_IN_PROGRESS = 0,
    SORT_TYPE_TOP_N_HEAPSORT = 1,
    SORT_TYPE_QUICKSORT = 2,
    SORT_TYPE_EXTERNAL_SORT = 3,
    SORT_TYPE_EXTERNAL_MERGE = 4,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum TuplesortSpaceType {
    SORT_SPACE_TYPE_DISK = 0,
    SORT_SPACE_TYPE_MEMORY = 1,
}
#[repr(C)]
pub struct TuplesortInstrumentation {
    pub sortMethod: TuplesortMethod,
    pub spaceType: TuplesortSpaceType,
    pub spaceUsed: ::std::os::raw::c_long,
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_begin_heap(
        tupDesc: PgPtr<TupleDescData>,
        nkeys: ::std::os::raw::c_int,
        attNums: PgPtr<AttrNumber>,
        sortOperators: PgPtr<Oid>,
        sortCollations: PgPtr<Oid>,
        nullsFirstFlags: PgPtr<bool>,
        workMem: ::std::os::raw::c_int,
        coordinate: PgPtr<SortCoordinateData>,
        randomAccess: bool,
    ) -> PgPtr<Tuplesortstate>;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_begin_cluster(
        tupDesc: PgPtr<TupleDescData>,
        indexRel: PgPtr<RelationData>,
        workMem: ::std::os::raw::c_int,
        coordinate: PgPtr<SortCoordinateData>,
        randomAccess: bool,
    ) -> PgPtr<Tuplesortstate>;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_begin_index_btree(
        heapRel: PgPtr<RelationData>,
        indexRel: PgPtr<RelationData>,
        enforceUnique: bool,
        workMem: ::std::os::raw::c_int,
        coordinate: PgPtr<SortCoordinateData>,
        randomAccess: bool,
    ) -> PgPtr<Tuplesortstate>;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_begin_index_hash(
        heapRel: PgPtr<RelationData>,
        indexRel: PgPtr<RelationData>,
        high_mask: uint32,
        low_mask: uint32,
        max_buckets: uint32,
        workMem: ::std::os::raw::c_int,
        coordinate: PgPtr<SortCoordinateData>,
        randomAccess: bool,
    ) -> PgPtr<Tuplesortstate>;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_begin_datum(
        datumType: Oid,
        sortOperator: Oid,
        sortCollation: Oid,
        nullsFirstFlag: bool,
        workMem: ::std::os::raw::c_int,
        coordinate: PgPtr<SortCoordinateData>,
        randomAccess: bool,
    ) -> PgPtr<Tuplesortstate>;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_set_bound(state: PgPtr<Tuplesortstate>, bound: int64);
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_puttupleslot(state: PgPtr<Tuplesortstate>, slot: PgPtr<TupleTableSlot>);
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_putheaptuple(state: PgPtr<Tuplesortstate>, tup: PgPtr<HeapTupleData>);
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_putindextuplevalues(
        state: PgPtr<Tuplesortstate>,
        rel: PgPtr<RelationData>,
        self_: PgPtr<ItemPointerData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
    );
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_putdatum(state: PgPtr<Tuplesortstate>, val: Datum, isNull: bool);
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_performsort(state: PgPtr<Tuplesortstate>);
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_gettupleslot(
        state: PgPtr<Tuplesortstate>,
        forward: bool,
        copy: bool,
        slot: PgPtr<TupleTableSlot>,
        abbrev: PgPtr<Datum>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_getheaptuple(
        state: PgPtr<Tuplesortstate>,
        forward: bool,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_getindextuple(
        state: PgPtr<Tuplesortstate>,
        forward: bool,
    ) -> PgPtr<IndexTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_getdatum(
        state: PgPtr<Tuplesortstate>,
        forward: bool,
        val: PgPtr<Datum>,
        isNull: PgPtr<bool>,
        abbrev: PgPtr<Datum>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_skiptuples(
        state: PgPtr<Tuplesortstate>,
        ntuples: int64,
        forward: bool,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_end(state: PgPtr<Tuplesortstate>);
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_get_stats(
        state: PgPtr<Tuplesortstate>,
        stats: PgPtr<TuplesortInstrumentation>,
    );
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_method_name(m: TuplesortMethod) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_space_type_name(t: TuplesortSpaceType) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_merge_order(allowedMem: int64) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_estimate_shared(nworkers: ::std::os::raw::c_int) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_initialize_shared(
        shared: PgPtr<Sharedsort>,
        nWorkers: ::std::os::raw::c_int,
        seg: PgPtr<dsm_segment>,
    );
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_attach_shared(shared: PgPtr<Sharedsort>, seg: PgPtr<dsm_segment>);
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_rescan(state: PgPtr<Tuplesortstate>);
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_markpos(state: PgPtr<Tuplesortstate>);
}
#[pg_guard]
extern "C" {
    pub fn tuplesort_restorepos(state: PgPtr<Tuplesortstate>);
}
#[repr(C)]
pub struct pg_atomic_flag {
    pub value: ::std::os::raw::c_char,
}
#[repr(C)]
pub struct pg_atomic_uint32 {
    pub value: uint32,
}
#[repr(C)]
pub struct pg_atomic_uint64 {
    pub value: uint64,
}
#[repr(C)]
pub struct dsa_area {
    _unused: [u8; 0],
}
pub type dsa_pointer = uint64;
pub type dsa_pointer_atomic = pg_atomic_uint64;
pub type dsa_handle = dsm_handle;
#[pg_guard]
extern "C" {
    pub fn dsa_startup();
}
#[pg_guard]
extern "C" {
    pub fn dsa_create(tranche_id: ::std::os::raw::c_int) -> PgPtr<dsa_area>;
}
#[pg_guard]
extern "C" {
    pub fn dsa_create_in_place(
        place: PgPtr<::std::os::raw::c_void>,
        size: usize,
        tranche_id: ::std::os::raw::c_int,
        segment: PgPtr<dsm_segment>,
    ) -> PgPtr<dsa_area>;
}
#[pg_guard]
extern "C" {
    pub fn dsa_attach(handle: dsa_handle) -> PgPtr<dsa_area>;
}
#[pg_guard]
extern "C" {
    pub fn dsa_attach_in_place(
        place: PgPtr<::std::os::raw::c_void>,
        segment: PgPtr<dsm_segment>,
    ) -> PgPtr<dsa_area>;
}
#[pg_guard]
extern "C" {
    pub fn dsa_release_in_place(place: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn dsa_on_dsm_detach_release_in_place(arg1: PgPtr<dsm_segment>, arg2: Datum);
}
#[pg_guard]
extern "C" {
    pub fn dsa_on_shmem_exit_release_in_place(arg1: ::std::os::raw::c_int, arg2: Datum);
}
#[pg_guard]
extern "C" {
    pub fn dsa_pin_mapping(area: PgPtr<dsa_area>);
}
#[pg_guard]
extern "C" {
    pub fn dsa_detach(area: PgPtr<dsa_area>);
}
#[pg_guard]
extern "C" {
    pub fn dsa_pin(area: PgPtr<dsa_area>);
}
#[pg_guard]
extern "C" {
    pub fn dsa_unpin(area: PgPtr<dsa_area>);
}
#[pg_guard]
extern "C" {
    pub fn dsa_set_size_limit(area: PgPtr<dsa_area>, limit: usize);
}
#[pg_guard]
extern "C" {
    pub fn dsa_minimum_size() -> usize;
}
#[pg_guard]
extern "C" {
    pub fn dsa_get_handle(area: PgPtr<dsa_area>) -> dsa_handle;
}
#[pg_guard]
extern "C" {
    pub fn dsa_allocate_extended(
        area: PgPtr<dsa_area>,
        size: usize,
        flags: ::std::os::raw::c_int,
    ) -> dsa_pointer;
}
#[pg_guard]
extern "C" {
    pub fn dsa_free(area: PgPtr<dsa_area>, dp: dsa_pointer);
}
#[pg_guard]
extern "C" {
    pub fn dsa_get_address(area: PgPtr<dsa_area>, dp: dsa_pointer)
        -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn dsa_trim(area: PgPtr<dsa_area>);
}
#[pg_guard]
extern "C" {
    pub fn dsa_dump(area: PgPtr<dsa_area>);
}
#[repr(C)]
pub struct TIDBitmap {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct TBMIterator {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct TBMSharedIterator {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct TBMIterateResult {
    pub blockno: BlockNumber,
    pub ntuples: ::std::os::raw::c_int,
    pub recheck: bool,
    pub offsets: __IncompleteArrayField<OffsetNumber>,
}
#[pg_guard]
extern "C" {
    pub fn tbm_create(maxbytes: ::std::os::raw::c_long, dsa: PgPtr<dsa_area>) -> PgPtr<TIDBitmap>;
}
#[pg_guard]
extern "C" {
    pub fn tbm_free(tbm: PgPtr<TIDBitmap>);
}
#[pg_guard]
extern "C" {
    pub fn tbm_free_shared_area(dsa: PgPtr<dsa_area>, dp: dsa_pointer);
}
#[pg_guard]
extern "C" {
    pub fn tbm_add_tuples(
        tbm: PgPtr<TIDBitmap>,
        tids: PgPtr<ItemPointerData>,
        ntids: ::std::os::raw::c_int,
        recheck: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn tbm_add_page(tbm: PgPtr<TIDBitmap>, pageno: BlockNumber);
}
#[pg_guard]
extern "C" {
    pub fn tbm_union(a: PgPtr<TIDBitmap>, b: PgPtr<TIDBitmap>);
}
#[pg_guard]
extern "C" {
    pub fn tbm_intersect(a: PgPtr<TIDBitmap>, b: PgPtr<TIDBitmap>);
}
#[pg_guard]
extern "C" {
    pub fn tbm_is_empty(tbm: PgPtr<TIDBitmap>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn tbm_begin_iterate(tbm: PgPtr<TIDBitmap>) -> PgPtr<TBMIterator>;
}
#[pg_guard]
extern "C" {
    pub fn tbm_prepare_shared_iterate(tbm: PgPtr<TIDBitmap>) -> dsa_pointer;
}
#[pg_guard]
extern "C" {
    pub fn tbm_iterate(iterator: PgPtr<TBMIterator>) -> PgPtr<TBMIterateResult>;
}
#[pg_guard]
extern "C" {
    pub fn tbm_shared_iterate(iterator: PgPtr<TBMSharedIterator>) -> PgPtr<TBMIterateResult>;
}
#[pg_guard]
extern "C" {
    pub fn tbm_end_iterate(iterator: PgPtr<TBMIterator>);
}
#[pg_guard]
extern "C" {
    pub fn tbm_end_shared_iterate(iterator: PgPtr<TBMSharedIterator>);
}
#[pg_guard]
extern "C" {
    pub fn tbm_attach_shared_iterate(
        dsa: PgPtr<dsa_area>,
        dp: dsa_pointer,
    ) -> PgPtr<TBMSharedIterator>;
}
#[pg_guard]
extern "C" {
    pub fn tbm_calculate_entries(maxbytes: f64) -> ::std::os::raw::c_long;
}
#[repr(C)]
pub struct proclist_node {
    pub next: ::std::os::raw::c_int,
    pub prev: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct proclist_head {
    pub head: ::std::os::raw::c_int,
    pub tail: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct proclist_mutable_iter {
    pub cur: ::std::os::raw::c_int,
    pub next: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ConditionVariable {
    pub mutex: slock_t,
    pub wakeup: proclist_head,
}
#[pg_guard]
extern "C" {
    pub fn ConditionVariableInit(cv: PgPtr<ConditionVariable>);
}
#[pg_guard]
extern "C" {
    pub fn ConditionVariableSleep(cv: PgPtr<ConditionVariable>, wait_event_info: uint32);
}
#[pg_guard]
extern "C" {
    pub fn ConditionVariableCancelSleep();
}
#[pg_guard]
extern "C" {
    pub fn ConditionVariablePrepareToSleep(cv: PgPtr<ConditionVariable>);
}
#[pg_guard]
extern "C" {
    pub fn ConditionVariableSignal(cv: PgPtr<ConditionVariable>);
}
#[pg_guard]
extern "C" {
    pub fn ConditionVariableBroadcast(cv: PgPtr<ConditionVariable>);
}
#[repr(C)]
pub struct PartitionRoutingInfo {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ParallelHashJoinState {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ExprEvalStep {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct CopyMultiInsertBuffer {
    _unused: [u8; 0],
}
pub type ExprStateEvalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        expression: PgPtr<ExprState>,
        econtext: PgPtr<ExprContext>,
        isNull: PgPtr<bool>,
    ) -> Datum,
>;
#[repr(C)]
pub struct ExprState {
    pub tag: Node,
    pub flags: uint8,
    pub resnull: bool,
    pub resvalue: Datum,
    pub resultslot: PgPtr<TupleTableSlot>,
    pub steps: PgPtr<ExprEvalStep>,
    pub evalfunc: ExprStateEvalFunc,
    pub expr: PgPtr<Expr>,
    pub evalfunc_private: PgPtr<::std::os::raw::c_void>,
    pub steps_len: ::std::os::raw::c_int,
    pub steps_alloc: ::std::os::raw::c_int,
    pub parent: PgPtr<PlanState>,
    pub ext_params: PgPtr<ParamListInfoData>,
    pub innermost_caseval: PgPtr<Datum>,
    pub innermost_casenull: PgPtr<bool>,
    pub innermost_domainval: PgPtr<Datum>,
    pub innermost_domainnull: PgPtr<bool>,
}
#[repr(C)]
pub struct IndexInfo {
    pub type_: NodeTag,
    pub ii_NumIndexAttrs: ::std::os::raw::c_int,
    pub ii_NumIndexKeyAttrs: ::std::os::raw::c_int,
    pub ii_IndexAttrNumbers: [AttrNumber; 32usize],
    pub ii_Expressions: PgPtr<List>,
    pub ii_ExpressionsState: PgPtr<List>,
    pub ii_Predicate: PgPtr<List>,
    pub ii_PredicateState: PgPtr<ExprState>,
    pub ii_ExclusionOps: PgPtr<Oid>,
    pub ii_ExclusionProcs: PgPtr<Oid>,
    pub ii_ExclusionStrats: PgPtr<uint16>,
    pub ii_UniqueOps: PgPtr<Oid>,
    pub ii_UniqueProcs: PgPtr<Oid>,
    pub ii_UniqueStrats: PgPtr<uint16>,
    pub ii_Unique: bool,
    pub ii_ReadyForInserts: bool,
    pub ii_Concurrent: bool,
    pub ii_BrokenHotChain: bool,
    pub ii_ParallelWorkers: ::std::os::raw::c_int,
    pub ii_Am: Oid,
    pub ii_AmCache: PgPtr<::std::os::raw::c_void>,
    pub ii_Context: PgPtr<MemoryContextData>,
}
pub type ExprContextCallbackFunction = ::std::option::Option<unsafe extern "C" fn(arg: Datum)>;
#[repr(C)]
pub struct ExprContext_CB {
    pub next: PgPtr<ExprContext_CB>,
    pub function: ExprContextCallbackFunction,
    pub arg: Datum,
}
#[repr(C)]
pub struct ExprContext {
    pub type_: NodeTag,
    pub ecxt_scantuple: PgPtr<TupleTableSlot>,
    pub ecxt_innertuple: PgPtr<TupleTableSlot>,
    pub ecxt_outertuple: PgPtr<TupleTableSlot>,
    pub ecxt_per_query_memory: PgPtr<MemoryContextData>,
    pub ecxt_per_tuple_memory: PgPtr<MemoryContextData>,
    pub ecxt_param_exec_vals: PgPtr<ParamExecData>,
    pub ecxt_param_list_info: PgPtr<ParamListInfoData>,
    pub ecxt_aggvalues: PgPtr<Datum>,
    pub ecxt_aggnulls: PgPtr<bool>,
    pub caseValue_datum: Datum,
    pub caseValue_isNull: bool,
    pub domainValue_datum: Datum,
    pub domainValue_isNull: bool,
    pub ecxt_estate: PgPtr<EState>,
    pub ecxt_callbacks: PgPtr<ExprContext_CB>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ExprDoneCond {
    ExprSingleResult = 0,
    ExprMultipleResult = 1,
    ExprEndResult = 2,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SetFunctionReturnMode {
    SFRM_ValuePerCall = 1,
    SFRM_Materialize = 2,
    SFRM_Materialize_Random = 4,
    SFRM_Materialize_Preferred = 8,
}
#[repr(C)]
pub struct ReturnSetInfo {
    pub type_: NodeTag,
    pub econtext: PgPtr<ExprContext>,
    pub expectedDesc: PgPtr<TupleDescData>,
    pub allowedModes: ::std::os::raw::c_int,
    pub returnMode: SetFunctionReturnMode,
    pub isDone: ExprDoneCond,
    pub setResult: PgPtr<Tuplestorestate>,
    pub setDesc: PgPtr<TupleDescData>,
}
#[repr(C)]
pub struct ProjectionInfo {
    pub type_: NodeTag,
    pub pi_state: ExprState,
    pub pi_exprContext: PgPtr<ExprContext>,
}
#[repr(C)]
pub struct JunkFilter {
    pub type_: NodeTag,
    pub jf_targetList: PgPtr<List>,
    pub jf_cleanTupType: PgPtr<TupleDescData>,
    pub jf_cleanMap: PgPtr<AttrNumber>,
    pub jf_resultSlot: PgPtr<TupleTableSlot>,
    pub jf_junkAttNo: AttrNumber,
}
#[repr(C)]
pub struct OnConflictSetState {
    pub type_: NodeTag,
    pub oc_Existing: PgPtr<TupleTableSlot>,
    pub oc_ProjSlot: PgPtr<TupleTableSlot>,
    pub oc_ProjInfo: PgPtr<ProjectionInfo>,
    pub oc_WhereClause: PgPtr<ExprState>,
}
#[repr(C)]
pub struct ResultRelInfo {
    pub type_: NodeTag,
    pub ri_RangeTableIndex: Index,
    pub ri_RelationDesc: PgPtr<RelationData>,
    pub ri_NumIndices: ::std::os::raw::c_int,
    pub ri_IndexRelationDescs: PgPtr<Relation>,
    pub ri_IndexRelationInfo: PgPtr<PgPtr<IndexInfo>>,
    pub ri_TrigDesc: PgPtr<TriggerDesc>,
    pub ri_TrigFunctions: PgPtr<FmgrInfo>,
    pub ri_TrigWhenExprs: PgPtr<PgPtr<ExprState>>,
    pub ri_TrigInstrument: PgPtr<Instrumentation>,
    pub ri_ReturningSlot: PgPtr<TupleTableSlot>,
    pub ri_TrigOldSlot: PgPtr<TupleTableSlot>,
    pub ri_TrigNewSlot: PgPtr<TupleTableSlot>,
    pub ri_FdwRoutine: PgPtr<FdwRoutine>,
    pub ri_FdwState: PgPtr<::std::os::raw::c_void>,
    pub ri_usesFdwDirectModify: bool,
    pub ri_WithCheckOptions: PgPtr<List>,
    pub ri_WithCheckOptionExprs: PgPtr<List>,
    pub ri_ConstraintExprs: PgPtr<PgPtr<ExprState>>,
    pub ri_GeneratedExprs: PgPtr<PgPtr<ExprState>>,
    pub ri_junkFilter: PgPtr<JunkFilter>,
    pub ri_returningList: PgPtr<List>,
    pub ri_projectReturning: PgPtr<ProjectionInfo>,
    pub ri_onConflictArbiterIndexes: PgPtr<List>,
    pub ri_onConflict: PgPtr<OnConflictSetState>,
    pub ri_PartitionCheck: PgPtr<List>,
    pub ri_PartitionCheckExpr: PgPtr<ExprState>,
    pub ri_PartitionRoot: PgPtr<RelationData>,
    pub ri_PartitionInfo: PgPtr<PartitionRoutingInfo>,
    pub ri_CopyMultiInsertBuffer: PgPtr<CopyMultiInsertBuffer>,
}
#[repr(C)]
pub struct EState {
    pub type_: NodeTag,
    pub es_direction: ScanDirection,
    pub es_snapshot: PgPtr<SnapshotData>,
    pub es_crosscheck_snapshot: PgPtr<SnapshotData>,
    pub es_range_table: PgPtr<List>,
    pub es_range_table_array: PgPtr<PgPtr<RangeTblEntry>>,
    pub es_range_table_size: Index,
    pub es_relations: PgPtr<PgPtr<RelationData>>,
    pub es_rowmarks: PgPtr<PgPtr<ExecRowMark>>,
    pub es_plannedstmt: PgPtr<PlannedStmt>,
    pub es_sourceText: PgPtr<::std::os::raw::c_char>,
    pub es_junkFilter: PgPtr<JunkFilter>,
    pub es_output_cid: CommandId,
    pub es_result_relations: PgPtr<ResultRelInfo>,
    pub es_num_result_relations: ::std::os::raw::c_int,
    pub es_result_relation_info: PgPtr<ResultRelInfo>,
    pub es_root_result_relations: PgPtr<ResultRelInfo>,
    pub es_num_root_result_relations: ::std::os::raw::c_int,
    pub es_partition_directory: PgPtr<PartitionDirectoryData>,
    pub es_tuple_routing_result_relations: PgPtr<List>,
    pub es_trig_target_relations: PgPtr<List>,
    pub es_param_list_info: PgPtr<ParamListInfoData>,
    pub es_param_exec_vals: PgPtr<ParamExecData>,
    pub es_queryEnv: PgPtr<QueryEnvironment>,
    pub es_query_cxt: PgPtr<MemoryContextData>,
    pub es_tupleTable: PgPtr<List>,
    pub es_processed: uint64,
    pub es_top_eflags: ::std::os::raw::c_int,
    pub es_instrument: ::std::os::raw::c_int,
    pub es_finished: bool,
    pub es_exprcontexts: PgPtr<List>,
    pub es_subplanstates: PgPtr<List>,
    pub es_auxmodifytables: PgPtr<List>,
    pub es_per_tuple_exprcontext: PgPtr<ExprContext>,
    pub es_epq_active: PgPtr<EPQState>,
    pub es_use_parallel_mode: bool,
    pub es_query_dsa: PgPtr<dsa_area>,
    pub es_jit_flags: ::std::os::raw::c_int,
    pub es_jit: PgPtr<JitContext>,
    pub es_jit_worker_instr: PgPtr<JitInstrumentation>,
}
#[repr(C)]
pub struct ExecRowMark {
    pub relation: PgPtr<RelationData>,
    pub relid: Oid,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub ermActive: bool,
    pub curCtid: ItemPointerData,
    pub ermExtra: PgPtr<::std::os::raw::c_void>,
}
#[repr(C)]
pub struct ExecAuxRowMark {
    pub rowmark: PgPtr<ExecRowMark>,
    pub ctidAttNo: AttrNumber,
    pub toidAttNo: AttrNumber,
    pub wholeAttNo: AttrNumber,
}
pub type TupleHashEntry = PgPtr<TupleHashEntryData>;
pub type TupleHashTable = PgPtr<TupleHashTableData>;
#[repr(C)]
pub struct TupleHashEntryData {
    pub firstTuple: PgPtr<MinimalTupleData>,
    pub additional: PgPtr<::std::os::raw::c_void>,
    pub status: uint32,
    pub hash: uint32,
}
#[repr(C)]
pub struct tuplehash_hash {
    pub size: uint64,
    pub members: uint32,
    pub sizemask: uint32,
    pub grow_threshold: uint32,
    pub data: PgPtr<TupleHashEntryData>,
    pub ctx: PgPtr<MemoryContextData>,
    pub private_data: PgPtr<::std::os::raw::c_void>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum tuplehash_status {
    tuplehash_SH_EMPTY = 0,
    tuplehash_SH_IN_USE = 1,
}
#[repr(C)]
pub struct tuplehash_iterator {
    pub cur: uint32,
    pub end: uint32,
    pub done: bool,
}
#[pg_guard]
extern "C" {
    pub fn tuplehash_create(
        ctx: PgPtr<MemoryContextData>,
        nelements: uint32,
        private_data: PgPtr<::std::os::raw::c_void>,
    ) -> PgPtr<tuplehash_hash>;
}
#[pg_guard]
extern "C" {
    pub fn tuplehash_destroy(tb: PgPtr<tuplehash_hash>);
}
#[pg_guard]
extern "C" {
    pub fn tuplehash_reset(tb: PgPtr<tuplehash_hash>);
}
#[pg_guard]
extern "C" {
    pub fn tuplehash_grow(tb: PgPtr<tuplehash_hash>, newsize: uint32);
}
#[pg_guard]
extern "C" {
    pub fn tuplehash_insert(
        tb: PgPtr<tuplehash_hash>,
        key: PgPtr<MinimalTupleData>,
        found: PgPtr<bool>,
    ) -> PgPtr<TupleHashEntryData>;
}
#[pg_guard]
extern "C" {
    pub fn tuplehash_lookup(
        tb: PgPtr<tuplehash_hash>,
        key: PgPtr<MinimalTupleData>,
    ) -> PgPtr<TupleHashEntryData>;
}
#[pg_guard]
extern "C" {
    pub fn tuplehash_delete(tb: PgPtr<tuplehash_hash>, key: PgPtr<MinimalTupleData>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn tuplehash_start_iterate(tb: PgPtr<tuplehash_hash>, iter: PgPtr<tuplehash_iterator>);
}
#[pg_guard]
extern "C" {
    pub fn tuplehash_start_iterate_at(
        tb: PgPtr<tuplehash_hash>,
        iter: PgPtr<tuplehash_iterator>,
        at: uint32,
    );
}
#[pg_guard]
extern "C" {
    pub fn tuplehash_iterate(
        tb: PgPtr<tuplehash_hash>,
        iter: PgPtr<tuplehash_iterator>,
    ) -> PgPtr<TupleHashEntryData>;
}
#[pg_guard]
extern "C" {
    pub fn tuplehash_stat(tb: PgPtr<tuplehash_hash>);
}
#[repr(C)]
pub struct TupleHashTableData {
    pub hashtab: PgPtr<tuplehash_hash>,
    pub numCols: ::std::os::raw::c_int,
    pub keyColIdx: PgPtr<AttrNumber>,
    pub tab_hash_funcs: PgPtr<FmgrInfo>,
    pub tab_eq_func: PgPtr<ExprState>,
    pub tab_collations: PgPtr<Oid>,
    pub tablecxt: PgPtr<MemoryContextData>,
    pub tempcxt: PgPtr<MemoryContextData>,
    pub entrysize: Size,
    pub tableslot: PgPtr<TupleTableSlot>,
    pub inputslot: PgPtr<TupleTableSlot>,
    pub in_hash_funcs: PgPtr<FmgrInfo>,
    pub cur_eq_func: PgPtr<ExprState>,
    pub hash_iv: uint32,
    pub exprcontext: PgPtr<ExprContext>,
}
pub type TupleHashIterator = tuplehash_iterator;
#[repr(C)]
pub struct AggrefExprState {
    pub type_: NodeTag,
    pub aggref: PgPtr<Aggref>,
    pub aggno: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct WindowFuncExprState {
    pub type_: NodeTag,
    pub wfunc: PgPtr<WindowFunc>,
    pub args: PgPtr<List>,
    pub aggfilter: PgPtr<ExprState>,
    pub wfuncno: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct SetExprState {
    pub type_: NodeTag,
    pub expr: PgPtr<Expr>,
    pub args: PgPtr<List>,
    pub elidedFuncState: PgPtr<ExprState>,
    pub func: FmgrInfo,
    pub funcResultStore: PgPtr<Tuplestorestate>,
    pub funcResultSlot: PgPtr<TupleTableSlot>,
    pub funcResultDesc: PgPtr<TupleDescData>,
    pub funcReturnsTuple: bool,
    pub funcReturnsSet: bool,
    pub setArgsValid: bool,
    pub shutdown_reg: bool,
    pub fcinfo: PgPtr<FunctionCallInfoBaseData>,
}
#[repr(C)]
pub struct SubPlanState {
    pub type_: NodeTag,
    pub subplan: PgPtr<SubPlan>,
    pub planstate: PgPtr<PlanState>,
    pub parent: PgPtr<PlanState>,
    pub testexpr: PgPtr<ExprState>,
    pub args: PgPtr<List>,
    pub curTuple: PgPtr<HeapTupleData>,
    pub curArray: Datum,
    pub descRight: PgPtr<TupleDescData>,
    pub projLeft: PgPtr<ProjectionInfo>,
    pub projRight: PgPtr<ProjectionInfo>,
    pub hashtable: PgPtr<TupleHashTableData>,
    pub hashnulls: PgPtr<TupleHashTableData>,
    pub havehashrows: bool,
    pub havenullrows: bool,
    pub hashtablecxt: PgPtr<MemoryContextData>,
    pub hashtempcxt: PgPtr<MemoryContextData>,
    pub innerecontext: PgPtr<ExprContext>,
    pub keyColIdx: PgPtr<AttrNumber>,
    pub tab_eq_funcoids: PgPtr<Oid>,
    pub tab_collations: PgPtr<Oid>,
    pub tab_hash_funcs: PgPtr<FmgrInfo>,
    pub tab_eq_funcs: PgPtr<FmgrInfo>,
    pub lhs_hash_funcs: PgPtr<FmgrInfo>,
    pub cur_eq_funcs: PgPtr<FmgrInfo>,
    pub cur_eq_comp: PgPtr<ExprState>,
}
#[repr(C)]
pub struct AlternativeSubPlanState {
    pub type_: NodeTag,
    pub subplan: PgPtr<AlternativeSubPlan>,
    pub subplans: PgPtr<List>,
    pub active: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum DomainConstraintType {
    DOM_CONSTRAINT_NOTNULL = 0,
    DOM_CONSTRAINT_CHECK = 1,
}
#[repr(C)]
pub struct DomainConstraintState {
    pub type_: NodeTag,
    pub constrainttype: DomainConstraintType,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub check_expr: PgPtr<Expr>,
    pub check_exprstate: PgPtr<ExprState>,
}
pub type ExecProcNodeMtd =
    ::std::option::Option<unsafe extern "C" fn(pstate: PgPtr<PlanState>) -> PgPtr<TupleTableSlot>>;
#[repr(C)]
pub struct PlanState {
    pub type_: NodeTag,
    pub plan: PgPtr<Plan>,
    pub state: PgPtr<EState>,
    pub ExecProcNode: ExecProcNodeMtd,
    pub ExecProcNodeReal: ExecProcNodeMtd,
    pub instrument: PgPtr<Instrumentation>,
    pub worker_instrument: PgPtr<WorkerInstrumentation>,
    pub worker_jit_instrument: PgPtr<SharedJitInstrumentation>,
    pub qual: PgPtr<ExprState>,
    pub lefttree: PgPtr<PlanState>,
    pub righttree: PgPtr<PlanState>,
    pub initPlan: PgPtr<List>,
    pub subPlan: PgPtr<List>,
    pub chgParam: PgPtr<Bitmapset>,
    pub ps_ResultTupleDesc: PgPtr<TupleDescData>,
    pub ps_ResultTupleSlot: PgPtr<TupleTableSlot>,
    pub ps_ExprContext: PgPtr<ExprContext>,
    pub ps_ProjInfo: PgPtr<ProjectionInfo>,
    pub scandesc: PgPtr<TupleDescData>,
    pub scanops: PgPtr<TupleTableSlotOps>,
    pub outerops: PgPtr<TupleTableSlotOps>,
    pub innerops: PgPtr<TupleTableSlotOps>,
    pub resultops: PgPtr<TupleTableSlotOps>,
    pub scanopsfixed: bool,
    pub outeropsfixed: bool,
    pub inneropsfixed: bool,
    pub resultopsfixed: bool,
    pub scanopsset: bool,
    pub outeropsset: bool,
    pub inneropsset: bool,
    pub resultopsset: bool,
}
#[repr(C)]
pub struct EPQState {
    pub parentestate: PgPtr<EState>,
    pub epqParam: ::std::os::raw::c_int,
    pub tuple_table: PgPtr<List>,
    pub relsubs_slot: PgPtr<PgPtr<TupleTableSlot>>,
    pub plan: PgPtr<Plan>,
    pub arowMarks: PgPtr<List>,
    pub origslot: PgPtr<TupleTableSlot>,
    pub recheckestate: PgPtr<EState>,
    pub relsubs_rowmark: PgPtr<PgPtr<ExecAuxRowMark>>,
    pub relsubs_done: PgPtr<bool>,
    pub recheckplanstate: PgPtr<PlanState>,
}
#[repr(C)]
pub struct ResultState {
    pub ps: PlanState,
    pub resconstantqual: PgPtr<ExprState>,
    pub rs_done: bool,
    pub rs_checkqual: bool,
}
#[repr(C)]
pub struct ProjectSetState {
    pub ps: PlanState,
    pub elems: PgPtr<PgPtr<Node>>,
    pub elemdone: PgPtr<ExprDoneCond>,
    pub nelems: ::std::os::raw::c_int,
    pub pending_srf_tuples: bool,
    pub argcontext: PgPtr<MemoryContextData>,
}
#[repr(C)]
pub struct ModifyTableState {
    pub ps: PlanState,
    pub operation: CmdType,
    pub canSetTag: bool,
    pub mt_done: bool,
    pub mt_plans: PgPtr<PgPtr<PlanState>>,
    pub mt_nplans: ::std::os::raw::c_int,
    pub mt_whichplan: ::std::os::raw::c_int,
    pub mt_scans: PgPtr<PgPtr<TupleTableSlot>>,
    pub resultRelInfo: PgPtr<ResultRelInfo>,
    pub rootResultRelInfo: PgPtr<ResultRelInfo>,
    pub mt_arowmarks: PgPtr<PgPtr<List>>,
    pub mt_epqstate: EPQState,
    pub fireBSTriggers: bool,
    pub mt_excludedtlist: PgPtr<List>,
    pub mt_root_tuple_slot: PgPtr<TupleTableSlot>,
    pub mt_partition_tuple_routing: PgPtr<PartitionTupleRouting>,
    pub mt_transition_capture: PgPtr<TransitionCaptureState>,
    pub mt_oc_transition_capture: PgPtr<TransitionCaptureState>,
    pub mt_per_subplan_tupconv_maps: PgPtr<PgPtr<TupleConversionMap>>,
}
#[repr(C)]
pub struct ParallelAppendState {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct PartitionPruneState {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct AppendState {
    pub ps: PlanState,
    pub appendplans: PgPtr<PgPtr<PlanState>>,
    pub as_nplans: ::std::os::raw::c_int,
    pub as_whichplan: ::std::os::raw::c_int,
    pub as_first_partial_plan: ::std::os::raw::c_int,
    pub as_pstate: PgPtr<ParallelAppendState>,
    pub pstate_len: Size,
    pub as_prune_state: PgPtr<PartitionPruneState>,
    pub as_valid_subplans: PgPtr<Bitmapset>,
    pub choose_next_subplan:
        ::std::option::Option<unsafe extern "C" fn(arg1: PgPtr<AppendState>) -> bool>,
}
#[repr(C)]
pub struct MergeAppendState {
    pub ps: PlanState,
    pub mergeplans: PgPtr<PgPtr<PlanState>>,
    pub ms_nplans: ::std::os::raw::c_int,
    pub ms_nkeys: ::std::os::raw::c_int,
    pub ms_sortkeys: PgPtr<SortSupportData>,
    pub ms_slots: PgPtr<PgPtr<TupleTableSlot>>,
    pub ms_heap: PgPtr<binaryheap>,
    pub ms_initialized: bool,
    pub ms_noopscan: bool,
    pub ms_prune_state: PgPtr<PartitionPruneState>,
    pub ms_valid_subplans: PgPtr<Bitmapset>,
}
#[repr(C)]
pub struct RecursiveUnionState {
    pub ps: PlanState,
    pub recursing: bool,
    pub intermediate_empty: bool,
    pub working_table: PgPtr<Tuplestorestate>,
    pub intermediate_table: PgPtr<Tuplestorestate>,
    pub eqfuncoids: PgPtr<Oid>,
    pub hashfunctions: PgPtr<FmgrInfo>,
    pub tempContext: PgPtr<MemoryContextData>,
    pub hashtable: PgPtr<TupleHashTableData>,
    pub tableContext: PgPtr<MemoryContextData>,
}
#[repr(C)]
pub struct BitmapAndState {
    pub ps: PlanState,
    pub bitmapplans: PgPtr<PgPtr<PlanState>>,
    pub nplans: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct BitmapOrState {
    pub ps: PlanState,
    pub bitmapplans: PgPtr<PgPtr<PlanState>>,
    pub nplans: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ScanState {
    pub ps: PlanState,
    pub ss_currentRelation: PgPtr<RelationData>,
    pub ss_currentScanDesc: PgPtr<TableScanDescData>,
    pub ss_ScanTupleSlot: PgPtr<TupleTableSlot>,
}
#[repr(C)]
pub struct SeqScanState {
    pub ss: ScanState,
    pub pscan_len: Size,
}
#[repr(C)]
pub struct SampleScanState {
    pub ss: ScanState,
    pub args: PgPtr<List>,
    pub repeatable: PgPtr<ExprState>,
    pub tsmroutine: PgPtr<TsmRoutine>,
    pub tsm_state: PgPtr<::std::os::raw::c_void>,
    pub use_bulkread: bool,
    pub use_pagemode: bool,
    pub begun: bool,
    pub seed: uint32,
    pub donetuples: int64,
    pub haveblock: bool,
    pub done: bool,
}
#[repr(C)]
pub struct IndexRuntimeKeyInfo {
    pub scan_key: PgPtr<ScanKeyData>,
    pub key_expr: PgPtr<ExprState>,
    pub key_toastable: bool,
}
#[repr(C)]
pub struct IndexArrayKeyInfo {
    pub scan_key: PgPtr<ScanKeyData>,
    pub array_expr: PgPtr<ExprState>,
    pub next_elem: ::std::os::raw::c_int,
    pub num_elems: ::std::os::raw::c_int,
    pub elem_values: PgPtr<Datum>,
    pub elem_nulls: PgPtr<bool>,
}
#[repr(C)]
pub struct IndexScanState {
    pub ss: ScanState,
    pub indexqualorig: PgPtr<ExprState>,
    pub indexorderbyorig: PgPtr<List>,
    pub iss_ScanKeys: PgPtr<ScanKeyData>,
    pub iss_NumScanKeys: ::std::os::raw::c_int,
    pub iss_OrderByKeys: PgPtr<ScanKeyData>,
    pub iss_NumOrderByKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeys: PgPtr<IndexRuntimeKeyInfo>,
    pub iss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeysReady: bool,
    pub iss_RuntimeContext: PgPtr<ExprContext>,
    pub iss_RelationDesc: PgPtr<RelationData>,
    pub iss_ScanDesc: PgPtr<IndexScanDescData>,
    pub iss_ReorderQueue: PgPtr<pairingheap>,
    pub iss_ReachedEnd: bool,
    pub iss_OrderByValues: PgPtr<Datum>,
    pub iss_OrderByNulls: PgPtr<bool>,
    pub iss_SortSupport: PgPtr<SortSupportData>,
    pub iss_OrderByTypByVals: PgPtr<bool>,
    pub iss_OrderByTypLens: PgPtr<int16>,
    pub iss_PscanLen: Size,
}
#[repr(C)]
pub struct IndexOnlyScanState {
    pub ss: ScanState,
    pub indexqual: PgPtr<ExprState>,
    pub ioss_ScanKeys: PgPtr<ScanKeyData>,
    pub ioss_NumScanKeys: ::std::os::raw::c_int,
    pub ioss_OrderByKeys: PgPtr<ScanKeyData>,
    pub ioss_NumOrderByKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeys: PgPtr<IndexRuntimeKeyInfo>,
    pub ioss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeysReady: bool,
    pub ioss_RuntimeContext: PgPtr<ExprContext>,
    pub ioss_RelationDesc: PgPtr<RelationData>,
    pub ioss_ScanDesc: PgPtr<IndexScanDescData>,
    pub ioss_TableSlot: PgPtr<TupleTableSlot>,
    pub ioss_VMBuffer: Buffer,
    pub ioss_PscanLen: Size,
}
#[repr(C)]
pub struct BitmapIndexScanState {
    pub ss: ScanState,
    pub biss_result: PgPtr<TIDBitmap>,
    pub biss_ScanKeys: PgPtr<ScanKeyData>,
    pub biss_NumScanKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeys: PgPtr<IndexRuntimeKeyInfo>,
    pub biss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub biss_ArrayKeys: PgPtr<IndexArrayKeyInfo>,
    pub biss_NumArrayKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeysReady: bool,
    pub biss_RuntimeContext: PgPtr<ExprContext>,
    pub biss_RelationDesc: PgPtr<RelationData>,
    pub biss_ScanDesc: PgPtr<IndexScanDescData>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SharedBitmapState {
    BM_INITIAL = 0,
    BM_INPROGRESS = 1,
    BM_FINISHED = 2,
}
#[repr(C)]
pub struct ParallelBitmapHeapState {
    pub tbmiterator: dsa_pointer,
    pub prefetch_iterator: dsa_pointer,
    pub mutex: slock_t,
    pub prefetch_pages: ::std::os::raw::c_int,
    pub prefetch_target: ::std::os::raw::c_int,
    pub state: SharedBitmapState,
    pub cv: ConditionVariable,
    pub phs_snapshot_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct BitmapHeapScanState {
    pub ss: ScanState,
    pub bitmapqualorig: PgPtr<ExprState>,
    pub tbm: PgPtr<TIDBitmap>,
    pub tbmiterator: PgPtr<TBMIterator>,
    pub tbmres: PgPtr<TBMIterateResult>,
    pub can_skip_fetch: bool,
    pub return_empty_tuples: ::std::os::raw::c_int,
    pub vmbuffer: Buffer,
    pub pvmbuffer: Buffer,
    pub exact_pages: ::std::os::raw::c_long,
    pub lossy_pages: ::std::os::raw::c_long,
    pub prefetch_iterator: PgPtr<TBMIterator>,
    pub prefetch_pages: ::std::os::raw::c_int,
    pub prefetch_target: ::std::os::raw::c_int,
    pub prefetch_maximum: ::std::os::raw::c_int,
    pub pscan_len: Size,
    pub initialized: bool,
    pub shared_tbmiterator: PgPtr<TBMSharedIterator>,
    pub shared_prefetch_iterator: PgPtr<TBMSharedIterator>,
    pub pstate: PgPtr<ParallelBitmapHeapState>,
}
#[repr(C)]
pub struct TidScanState {
    pub ss: ScanState,
    pub tss_tidexprs: PgPtr<List>,
    pub tss_isCurrentOf: bool,
    pub tss_NumTids: ::std::os::raw::c_int,
    pub tss_TidPtr: ::std::os::raw::c_int,
    pub tss_TidList: PgPtr<ItemPointerData>,
    pub tss_htup: HeapTupleData,
}
#[repr(C)]
pub struct SubqueryScanState {
    pub ss: ScanState,
    pub subplan: PgPtr<PlanState>,
}
#[repr(C)]
pub struct FunctionScanPerFuncState {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct FunctionScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub ordinality: bool,
    pub simple: bool,
    pub ordinal: int64,
    pub nfuncs: ::std::os::raw::c_int,
    pub funcstates: PgPtr<FunctionScanPerFuncState>,
    pub argcontext: PgPtr<MemoryContextData>,
}
#[repr(C)]
pub struct ValuesScanState {
    pub ss: ScanState,
    pub rowcontext: PgPtr<ExprContext>,
    pub exprlists: PgPtr<PgPtr<List>>,
    pub array_len: ::std::os::raw::c_int,
    pub curr_idx: ::std::os::raw::c_int,
    pub exprstatelists: PgPtr<PgPtr<List>>,
}
#[repr(C)]
pub struct TableFuncScanState {
    pub ss: ScanState,
    pub docexpr: PgPtr<ExprState>,
    pub rowexpr: PgPtr<ExprState>,
    pub colexprs: PgPtr<List>,
    pub coldefexprs: PgPtr<List>,
    pub ns_names: PgPtr<List>,
    pub ns_uris: PgPtr<List>,
    pub notnulls: PgPtr<Bitmapset>,
    pub opaque: PgPtr<::std::os::raw::c_void>,
    pub routine: PgPtr<TableFuncRoutine>,
    pub in_functions: PgPtr<FmgrInfo>,
    pub typioparams: PgPtr<Oid>,
    pub ordinal: int64,
    pub perTableCxt: PgPtr<MemoryContextData>,
    pub tupstore: PgPtr<Tuplestorestate>,
}
#[repr(C)]
pub struct CteScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub readptr: ::std::os::raw::c_int,
    pub cteplanstate: PgPtr<PlanState>,
    pub leader: PgPtr<CteScanState>,
    pub cte_table: PgPtr<Tuplestorestate>,
    pub eof_cte: bool,
}
#[repr(C)]
pub struct NamedTuplestoreScanState {
    pub ss: ScanState,
    pub readptr: ::std::os::raw::c_int,
    pub tupdesc: PgPtr<TupleDescData>,
    pub relation: PgPtr<Tuplestorestate>,
}
#[repr(C)]
pub struct WorkTableScanState {
    pub ss: ScanState,
    pub rustate: PgPtr<RecursiveUnionState>,
}
#[repr(C)]
pub struct ForeignScanState {
    pub ss: ScanState,
    pub fdw_recheck_quals: PgPtr<ExprState>,
    pub pscan_len: Size,
    pub fdwroutine: PgPtr<FdwRoutine>,
    pub fdw_state: PgPtr<::std::os::raw::c_void>,
}
#[repr(C)]
pub struct CustomScanState {
    pub ss: ScanState,
    pub flags: uint32,
    pub custom_ps: PgPtr<List>,
    pub pscan_len: Size,
    pub methods: PgPtr<CustomExecMethods>,
}
#[repr(C)]
pub struct JoinState {
    pub ps: PlanState,
    pub jointype: JoinType,
    pub single_match: bool,
    pub joinqual: PgPtr<ExprState>,
}
#[repr(C)]
pub struct NestLoopState {
    pub js: JoinState,
    pub nl_NeedNewOuter: bool,
    pub nl_MatchedOuter: bool,
    pub nl_NullInnerTupleSlot: PgPtr<TupleTableSlot>,
}
#[repr(C)]
pub struct MergeJoinClauseData {
    _unused: [u8; 0],
}
pub type MergeJoinClause = PgPtr<MergeJoinClauseData>;
#[repr(C)]
pub struct MergeJoinState {
    pub js: JoinState,
    pub mj_NumClauses: ::std::os::raw::c_int,
    pub mj_Clauses: PgPtr<MergeJoinClauseData>,
    pub mj_JoinState: ::std::os::raw::c_int,
    pub mj_SkipMarkRestore: bool,
    pub mj_ExtraMarks: bool,
    pub mj_ConstFalseJoin: bool,
    pub mj_FillOuter: bool,
    pub mj_FillInner: bool,
    pub mj_MatchedOuter: bool,
    pub mj_MatchedInner: bool,
    pub mj_OuterTupleSlot: PgPtr<TupleTableSlot>,
    pub mj_InnerTupleSlot: PgPtr<TupleTableSlot>,
    pub mj_MarkedTupleSlot: PgPtr<TupleTableSlot>,
    pub mj_NullOuterTupleSlot: PgPtr<TupleTableSlot>,
    pub mj_NullInnerTupleSlot: PgPtr<TupleTableSlot>,
    pub mj_OuterEContext: PgPtr<ExprContext>,
    pub mj_InnerEContext: PgPtr<ExprContext>,
}
#[repr(C)]
pub struct HashJoinTupleData {
    _unused: [u8; 0],
}
pub type HashJoinTuple = PgPtr<HashJoinTupleData>;
#[repr(C)]
pub struct HashJoinTableData {
    _unused: [u8; 0],
}
pub type HashJoinTable = PgPtr<HashJoinTableData>;
#[repr(C)]
pub struct HashJoinState {
    pub js: JoinState,
    pub hashclauses: PgPtr<ExprState>,
    pub hj_OuterHashKeys: PgPtr<List>,
    pub hj_HashOperators: PgPtr<List>,
    pub hj_Collations: PgPtr<List>,
    pub hj_HashTable: PgPtr<HashJoinTableData>,
    pub hj_CurHashValue: uint32,
    pub hj_CurBucketNo: ::std::os::raw::c_int,
    pub hj_CurSkewBucketNo: ::std::os::raw::c_int,
    pub hj_CurTuple: PgPtr<HashJoinTupleData>,
    pub hj_OuterTupleSlot: PgPtr<TupleTableSlot>,
    pub hj_HashTupleSlot: PgPtr<TupleTableSlot>,
    pub hj_NullOuterTupleSlot: PgPtr<TupleTableSlot>,
    pub hj_NullInnerTupleSlot: PgPtr<TupleTableSlot>,
    pub hj_FirstOuterTupleSlot: PgPtr<TupleTableSlot>,
    pub hj_JoinState: ::std::os::raw::c_int,
    pub hj_MatchedOuter: bool,
    pub hj_OuterNotEmpty: bool,
}
#[repr(C)]
pub struct MaterialState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub eof_underlying: bool,
    pub tuplestorestate: PgPtr<Tuplestorestate>,
}
#[repr(C)]
pub struct SharedSortInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub sinstrument: __IncompleteArrayField<TuplesortInstrumentation>,
}
#[repr(C)]
pub struct SortState {
    pub ss: ScanState,
    pub randomAccess: bool,
    pub bounded: bool,
    pub bound: int64,
    pub sort_Done: bool,
    pub bounded_Done: bool,
    pub bound_Done: int64,
    pub tuplesortstate: PgPtr<::std::os::raw::c_void>,
    pub am_worker: bool,
    pub shared_info: PgPtr<SharedSortInfo>,
}
#[repr(C)]
pub struct GroupState {
    pub ss: ScanState,
    pub eqfunction: PgPtr<ExprState>,
    pub grp_done: bool,
}
#[repr(C)]
pub struct AggStatePerAggData {
    _unused: [u8; 0],
}
pub type AggStatePerAgg = PgPtr<AggStatePerAggData>;
#[repr(C)]
pub struct AggStatePerTransData {
    _unused: [u8; 0],
}
pub type AggStatePerTrans = PgPtr<AggStatePerTransData>;
#[repr(C)]
pub struct AggStatePerGroupData {
    _unused: [u8; 0],
}
pub type AggStatePerGroup = PgPtr<AggStatePerGroupData>;
#[repr(C)]
pub struct AggStatePerPhaseData {
    _unused: [u8; 0],
}
pub type AggStatePerPhase = PgPtr<AggStatePerPhaseData>;
#[repr(C)]
pub struct AggStatePerHashData {
    _unused: [u8; 0],
}
pub type AggStatePerHash = PgPtr<AggStatePerHashData>;
#[repr(C)]
pub struct AggState {
    pub ss: ScanState,
    pub aggs: PgPtr<List>,
    pub numaggs: ::std::os::raw::c_int,
    pub numtrans: ::std::os::raw::c_int,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub phase: PgPtr<AggStatePerPhaseData>,
    pub numphases: ::std::os::raw::c_int,
    pub current_phase: ::std::os::raw::c_int,
    pub peragg: PgPtr<AggStatePerAggData>,
    pub pertrans: PgPtr<AggStatePerTransData>,
    pub hashcontext: PgPtr<ExprContext>,
    pub aggcontexts: PgPtr<PgPtr<ExprContext>>,
    pub tmpcontext: PgPtr<ExprContext>,
    pub curaggcontext: PgPtr<ExprContext>,
    pub curperagg: PgPtr<AggStatePerAggData>,
    pub curpertrans: PgPtr<AggStatePerTransData>,
    pub input_done: bool,
    pub agg_done: bool,
    pub projected_set: ::std::os::raw::c_int,
    pub current_set: ::std::os::raw::c_int,
    pub grouped_cols: PgPtr<Bitmapset>,
    pub all_grouped_cols: PgPtr<List>,
    pub maxsets: ::std::os::raw::c_int,
    pub phases: PgPtr<AggStatePerPhaseData>,
    pub sort_in: PgPtr<Tuplesortstate>,
    pub sort_out: PgPtr<Tuplesortstate>,
    pub sort_slot: PgPtr<TupleTableSlot>,
    pub pergroups: PgPtr<PgPtr<AggStatePerGroupData>>,
    pub grp_firstTuple: PgPtr<HeapTupleData>,
    pub table_filled: bool,
    pub num_hashes: ::std::os::raw::c_int,
    pub perhash: PgPtr<AggStatePerHashData>,
    pub hash_pergroup: PgPtr<PgPtr<AggStatePerGroupData>>,
    pub all_pergroups: PgPtr<PgPtr<AggStatePerGroupData>>,
    pub combinedproj: PgPtr<ProjectionInfo>,
}
#[repr(C)]
pub struct WindowStatePerFuncData {
    _unused: [u8; 0],
}
pub type WindowStatePerFunc = PgPtr<WindowStatePerFuncData>;
#[repr(C)]
pub struct WindowStatePerAggData {
    _unused: [u8; 0],
}
pub type WindowStatePerAgg = PgPtr<WindowStatePerAggData>;
#[repr(C)]
pub struct WindowAggState {
    pub ss: ScanState,
    pub funcs: PgPtr<List>,
    pub numfuncs: ::std::os::raw::c_int,
    pub numaggs: ::std::os::raw::c_int,
    pub perfunc: PgPtr<WindowStatePerFuncData>,
    pub peragg: PgPtr<WindowStatePerAggData>,
    pub partEqfunction: PgPtr<ExprState>,
    pub ordEqfunction: PgPtr<ExprState>,
    pub buffer: PgPtr<Tuplestorestate>,
    pub current_ptr: ::std::os::raw::c_int,
    pub framehead_ptr: ::std::os::raw::c_int,
    pub frametail_ptr: ::std::os::raw::c_int,
    pub grouptail_ptr: ::std::os::raw::c_int,
    pub spooled_rows: int64,
    pub currentpos: int64,
    pub frameheadpos: int64,
    pub frametailpos: int64,
    pub agg_winobj: PgPtr<WindowObjectData>,
    pub aggregatedbase: int64,
    pub aggregatedupto: int64,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: PgPtr<ExprState>,
    pub endOffset: PgPtr<ExprState>,
    pub startOffsetValue: Datum,
    pub endOffsetValue: Datum,
    pub startInRangeFunc: FmgrInfo,
    pub endInRangeFunc: FmgrInfo,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
    pub currentgroup: int64,
    pub frameheadgroup: int64,
    pub frametailgroup: int64,
    pub groupheadpos: int64,
    pub grouptailpos: int64,
    pub partcontext: PgPtr<MemoryContextData>,
    pub aggcontext: PgPtr<MemoryContextData>,
    pub curaggcontext: PgPtr<MemoryContextData>,
    pub tmpcontext: PgPtr<ExprContext>,
    pub all_first: bool,
    pub all_done: bool,
    pub partition_spooled: bool,
    pub more_partitions: bool,
    pub framehead_valid: bool,
    pub frametail_valid: bool,
    pub grouptail_valid: bool,
    pub first_part_slot: PgPtr<TupleTableSlot>,
    pub framehead_slot: PgPtr<TupleTableSlot>,
    pub frametail_slot: PgPtr<TupleTableSlot>,
    pub agg_row_slot: PgPtr<TupleTableSlot>,
    pub temp_slot_1: PgPtr<TupleTableSlot>,
    pub temp_slot_2: PgPtr<TupleTableSlot>,
}
#[repr(C)]
pub struct UniqueState {
    pub ps: PlanState,
    pub eqfunction: PgPtr<ExprState>,
}
#[repr(C)]
pub struct GatherState {
    pub ps: PlanState,
    pub initialized: bool,
    pub need_to_scan_locally: bool,
    pub tuples_needed: int64,
    pub funnel_slot: PgPtr<TupleTableSlot>,
    pub pei: PgPtr<ParallelExecutorInfo>,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub nreaders: ::std::os::raw::c_int,
    pub nextreader: ::std::os::raw::c_int,
    pub reader: PgPtr<PgPtr<TupleQueueReader>>,
}
#[repr(C)]
pub struct GMReaderTupleBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct GatherMergeState {
    pub ps: PlanState,
    pub initialized: bool,
    pub gm_initialized: bool,
    pub need_to_scan_locally: bool,
    pub tuples_needed: int64,
    pub tupDesc: PgPtr<TupleDescData>,
    pub gm_nkeys: ::std::os::raw::c_int,
    pub gm_sortkeys: PgPtr<SortSupportData>,
    pub pei: PgPtr<ParallelExecutorInfo>,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub nreaders: ::std::os::raw::c_int,
    pub gm_slots: PgPtr<PgPtr<TupleTableSlot>>,
    pub reader: PgPtr<PgPtr<TupleQueueReader>>,
    pub gm_tuple_buffers: PgPtr<GMReaderTupleBuffer>,
    pub gm_heap: PgPtr<binaryheap>,
}
#[repr(C)]
pub struct HashInstrumentation {
    pub nbuckets: ::std::os::raw::c_int,
    pub nbuckets_original: ::std::os::raw::c_int,
    pub nbatch: ::std::os::raw::c_int,
    pub nbatch_original: ::std::os::raw::c_int,
    pub space_peak: usize,
}
#[repr(C)]
pub struct SharedHashInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub hinstrument: __IncompleteArrayField<HashInstrumentation>,
}
#[repr(C)]
pub struct HashState {
    pub ps: PlanState,
    pub hashtable: PgPtr<HashJoinTableData>,
    pub hashkeys: PgPtr<List>,
    pub shared_info: PgPtr<SharedHashInfo>,
    pub hinstrument: PgPtr<HashInstrumentation>,
    pub parallel_state: PgPtr<ParallelHashJoinState>,
}
#[repr(C)]
pub struct SetOpStatePerGroupData {
    _unused: [u8; 0],
}
pub type SetOpStatePerGroup = PgPtr<SetOpStatePerGroupData>;
#[repr(C)]
pub struct SetOpState {
    pub ps: PlanState,
    pub eqfunction: PgPtr<ExprState>,
    pub eqfuncoids: PgPtr<Oid>,
    pub hashfunctions: PgPtr<FmgrInfo>,
    pub setop_done: bool,
    pub numOutput: ::std::os::raw::c_long,
    pub pergroup: PgPtr<SetOpStatePerGroupData>,
    pub grp_firstTuple: PgPtr<HeapTupleData>,
    pub hashtable: PgPtr<TupleHashTableData>,
    pub tableContext: PgPtr<MemoryContextData>,
    pub table_filled: bool,
    pub hashiter: TupleHashIterator,
}
#[repr(C)]
pub struct LockRowsState {
    pub ps: PlanState,
    pub lr_arowMarks: PgPtr<List>,
    pub lr_epqstate: EPQState,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum LimitStateCond {
    LIMIT_INITIAL = 0,
    LIMIT_RESCAN = 1,
    LIMIT_EMPTY = 2,
    LIMIT_INWINDOW = 3,
    LIMIT_SUBPLANEOF = 4,
    LIMIT_WINDOWEND = 5,
    LIMIT_WINDOWSTART = 6,
}
#[repr(C)]
pub struct LimitState {
    pub ps: PlanState,
    pub limitOffset: PgPtr<ExprState>,
    pub limitCount: PgPtr<ExprState>,
    pub offset: int64,
    pub count: int64,
    pub noCount: bool,
    pub lstate: LimitStateCond,
    pub position: int64,
    pub subSlot: PgPtr<TupleTableSlot>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum CommandDest {
    DestNone = 0,
    DestDebug = 1,
    DestRemote = 2,
    DestRemoteExecute = 3,
    DestRemoteSimple = 4,
    DestSPI = 5,
    DestTuplestore = 6,
    DestIntoRel = 7,
    DestCopyOut = 8,
    DestSQLFunction = 9,
    DestTransientRel = 10,
    DestTupleQueue = 11,
}
pub type DestReceiver = _DestReceiver;
#[repr(C)]
pub struct _DestReceiver {
    pub receiveSlot: ::std::option::Option<
        unsafe extern "C" fn(slot: PgPtr<TupleTableSlot>, self_: PgPtr<DestReceiver>) -> bool,
    >,
    pub rStartup: ::std::option::Option<
        unsafe extern "C" fn(
            self_: PgPtr<DestReceiver>,
            operation: ::std::os::raw::c_int,
            typeinfo: PgPtr<TupleDescData>,
        ),
    >,
    pub rShutdown: ::std::option::Option<unsafe extern "C" fn(self_: PgPtr<DestReceiver>)>,
    pub rDestroy: ::std::option::Option<unsafe extern "C" fn(self_: PgPtr<DestReceiver>)>,
    pub mydest: CommandDest,
}
#[pg_guard]
extern "C" {
    pub static mut None_Receiver: PgPtr<DestReceiver>;
}
#[pg_guard]
extern "C" {
    pub fn BeginCommand(commandTag: PgPtr<::std::os::raw::c_char>, dest: CommandDest);
}
#[pg_guard]
extern "C" {
    pub fn CreateDestReceiver(dest: CommandDest) -> PgPtr<DestReceiver>;
}
#[pg_guard]
extern "C" {
    pub fn EndCommand(commandTag: PgPtr<::std::os::raw::c_char>, dest: CommandDest);
}
#[pg_guard]
extern "C" {
    pub fn NullCommand(dest: CommandDest);
}
#[pg_guard]
extern "C" {
    pub fn ReadyForQuery(dest: CommandDest);
}
#[repr(C)]
pub struct QueryDesc {
    pub operation: CmdType,
    pub plannedstmt: PgPtr<PlannedStmt>,
    pub sourceText: PgPtr<::std::os::raw::c_char>,
    pub snapshot: PgPtr<SnapshotData>,
    pub crosscheck_snapshot: PgPtr<SnapshotData>,
    pub dest: PgPtr<DestReceiver>,
    pub params: PgPtr<ParamListInfoData>,
    pub queryEnv: PgPtr<QueryEnvironment>,
    pub instrument_options: ::std::os::raw::c_int,
    pub tupDesc: PgPtr<TupleDescData>,
    pub estate: PgPtr<EState>,
    pub planstate: PgPtr<PlanState>,
    pub already_executed: bool,
    pub totaltime: PgPtr<Instrumentation>,
}
#[pg_guard]
extern "C" {
    pub fn CreateQueryDesc(
        plannedstmt: PgPtr<PlannedStmt>,
        sourceText: PgPtr<::std::os::raw::c_char>,
        snapshot: PgPtr<SnapshotData>,
        crosscheck_snapshot: PgPtr<SnapshotData>,
        dest: PgPtr<DestReceiver>,
        params: PgPtr<ParamListInfoData>,
        queryEnv: PgPtr<QueryEnvironment>,
        instrument_options: ::std::os::raw::c_int,
    ) -> PgPtr<QueryDesc>;
}
#[pg_guard]
extern "C" {
    pub fn FreeQueryDesc(qdesc: PgPtr<QueryDesc>);
}
#[repr(C)]
pub struct Value {
    pub type_: NodeTag,
    pub val: Value_ValUnion,
}
#[repr(C)]
pub struct Value_ValUnion {
    pub ival: __BindgenUnionField<::std::os::raw::c_int>,
    pub str_: __BindgenUnionField<PgPtr<::std::os::raw::c_char>>,
    pub bindgen_union_field: u64,
}
#[pg_guard]
extern "C" {
    pub fn makeInteger(i: ::std::os::raw::c_int) -> PgPtr<Value>;
}
#[pg_guard]
extern "C" {
    pub fn makeFloat(numericStr: PgPtr<::std::os::raw::c_char>) -> PgPtr<Value>;
}
#[pg_guard]
extern "C" {
    pub fn makeString(str_: PgPtr<::std::os::raw::c_char>) -> PgPtr<Value>;
}
#[pg_guard]
extern "C" {
    pub fn makeBitString(str_: PgPtr<::std::os::raw::c_char>) -> PgPtr<Value>;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum OverridingKind {
    OVERRIDING_NOT_SET = 0,
    OVERRIDING_USER_VALUE = 1,
    OVERRIDING_SYSTEM_VALUE = 2,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum QuerySource {
    QSRC_ORIGINAL = 0,
    QSRC_PARSER = 1,
    QSRC_INSTEAD_RULE = 2,
    QSRC_QUAL_INSTEAD_RULE = 3,
    QSRC_NON_INSTEAD_RULE = 4,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SortByDir {
    SORTBY_DEFAULT = 0,
    SORTBY_ASC = 1,
    SORTBY_DESC = 2,
    SORTBY_USING = 3,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SortByNulls {
    SORTBY_NULLS_DEFAULT = 0,
    SORTBY_NULLS_FIRST = 1,
    SORTBY_NULLS_LAST = 2,
}
pub type AclMode = uint32;
#[doc = "\tQuery Tree"]
#[repr(C)]
pub struct Query {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub querySource: QuerySource,
    pub queryId: uint64,
    pub canSetTag: bool,
    pub utilityStmt: PgPtr<Node>,
    pub resultRelation: ::std::os::raw::c_int,
    pub hasAggs: bool,
    pub hasWindowFuncs: bool,
    pub hasTargetSRFs: bool,
    pub hasSubLinks: bool,
    pub hasDistinctOn: bool,
    pub hasRecursive: bool,
    pub hasModifyingCTE: bool,
    pub hasForUpdate: bool,
    pub hasRowSecurity: bool,
    pub cteList: PgPtr<List>,
    pub rtable: PgPtr<List>,
    pub jointree: PgPtr<FromExpr>,
    pub targetList: PgPtr<List>,
    pub override_: OverridingKind,
    pub onConflict: PgPtr<OnConflictExpr>,
    pub returningList: PgPtr<List>,
    pub groupClause: PgPtr<List>,
    pub groupingSets: PgPtr<List>,
    pub havingQual: PgPtr<Node>,
    pub windowClause: PgPtr<List>,
    pub distinctClause: PgPtr<List>,
    pub sortClause: PgPtr<List>,
    pub limitOffset: PgPtr<Node>,
    pub limitCount: PgPtr<Node>,
    pub rowMarks: PgPtr<List>,
    pub setOperations: PgPtr<Node>,
    pub constraintDeps: PgPtr<List>,
    pub withCheckOptions: PgPtr<List>,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
#[doc = "\tSupporting data structures for Parse Trees"]
#[doc = ""]
#[doc = "\tMost of these node types appear in raw parsetrees output by the grammar,"]
#[doc = "\tand get transformed to something else by the analyzer.  A few of them"]
#[doc = "\tare used as-is in transformed querytrees."]
#[repr(C)]
pub struct TypeName {
    pub type_: NodeTag,
    pub names: PgPtr<List>,
    pub typeOid: Oid,
    pub setof: bool,
    pub pct_type: bool,
    pub typmods: PgPtr<List>,
    pub typemod: int32,
    pub arrayBounds: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ColumnRef {
    pub type_: NodeTag,
    pub fields: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ParamRef {
    pub type_: NodeTag,
    pub number: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum A_Expr_Kind {
    AEXPR_OP = 0,
    AEXPR_OP_ANY = 1,
    AEXPR_OP_ALL = 2,
    AEXPR_DISTINCT = 3,
    AEXPR_NOT_DISTINCT = 4,
    AEXPR_NULLIF = 5,
    AEXPR_OF = 6,
    AEXPR_IN = 7,
    AEXPR_LIKE = 8,
    AEXPR_ILIKE = 9,
    AEXPR_SIMILAR = 10,
    AEXPR_BETWEEN = 11,
    AEXPR_NOT_BETWEEN = 12,
    AEXPR_BETWEEN_SYM = 13,
    AEXPR_NOT_BETWEEN_SYM = 14,
    AEXPR_PAREN = 15,
}
#[repr(C)]
pub struct A_Expr {
    pub type_: NodeTag,
    pub kind: A_Expr_Kind,
    pub name: PgPtr<List>,
    pub lexpr: PgPtr<Node>,
    pub rexpr: PgPtr<Node>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct A_Const {
    pub type_: NodeTag,
    pub val: Value,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct TypeCast {
    pub type_: NodeTag,
    pub arg: PgPtr<Node>,
    pub typeName: PgPtr<TypeName>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct CollateClause {
    pub type_: NodeTag,
    pub arg: PgPtr<Node>,
    pub collname: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum RoleSpecType {
    ROLESPEC_CSTRING = 0,
    ROLESPEC_CURRENT_USER = 1,
    ROLESPEC_SESSION_USER = 2,
    ROLESPEC_PUBLIC = 3,
}
#[repr(C)]
pub struct RoleSpec {
    pub type_: NodeTag,
    pub roletype: RoleSpecType,
    pub rolename: PgPtr<::std::os::raw::c_char>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct FuncCall {
    pub type_: NodeTag,
    pub funcname: PgPtr<List>,
    pub args: PgPtr<List>,
    pub agg_order: PgPtr<List>,
    pub agg_filter: PgPtr<Node>,
    pub agg_within_group: bool,
    pub agg_star: bool,
    pub agg_distinct: bool,
    pub func_variadic: bool,
    pub over: PgPtr<WindowDef>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct A_Star {
    pub type_: NodeTag,
}
#[repr(C)]
pub struct A_Indices {
    pub type_: NodeTag,
    pub is_slice: bool,
    pub lidx: PgPtr<Node>,
    pub uidx: PgPtr<Node>,
}
#[repr(C)]
pub struct A_Indirection {
    pub type_: NodeTag,
    pub arg: PgPtr<Node>,
    pub indirection: PgPtr<List>,
}
#[repr(C)]
pub struct A_ArrayExpr {
    pub type_: NodeTag,
    pub elements: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ResTarget {
    pub type_: NodeTag,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub indirection: PgPtr<List>,
    pub val: PgPtr<Node>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct MultiAssignRef {
    pub type_: NodeTag,
    pub source: PgPtr<Node>,
    pub colno: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct SortBy {
    pub type_: NodeTag,
    pub node: PgPtr<Node>,
    pub sortby_dir: SortByDir,
    pub sortby_nulls: SortByNulls,
    pub useOp: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct WindowDef {
    pub type_: NodeTag,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub refname: PgPtr<::std::os::raw::c_char>,
    pub partitionClause: PgPtr<List>,
    pub orderClause: PgPtr<List>,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: PgPtr<Node>,
    pub endOffset: PgPtr<Node>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct RangeSubselect {
    pub type_: NodeTag,
    pub lateral: bool,
    pub subquery: PgPtr<Node>,
    pub alias: PgPtr<Alias>,
}
#[repr(C)]
pub struct RangeFunction {
    pub type_: NodeTag,
    pub lateral: bool,
    pub ordinality: bool,
    pub is_rowsfrom: bool,
    pub functions: PgPtr<List>,
    pub alias: PgPtr<Alias>,
    pub coldeflist: PgPtr<List>,
}
#[repr(C)]
pub struct RangeTableFunc {
    pub type_: NodeTag,
    pub lateral: bool,
    pub docexpr: PgPtr<Node>,
    pub rowexpr: PgPtr<Node>,
    pub namespaces: PgPtr<List>,
    pub columns: PgPtr<List>,
    pub alias: PgPtr<Alias>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct RangeTableFuncCol {
    pub type_: NodeTag,
    pub colname: PgPtr<::std::os::raw::c_char>,
    pub typeName: PgPtr<TypeName>,
    pub for_ordinality: bool,
    pub is_not_null: bool,
    pub colexpr: PgPtr<Node>,
    pub coldefexpr: PgPtr<Node>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct RangeTableSample {
    pub type_: NodeTag,
    pub relation: PgPtr<Node>,
    pub method: PgPtr<List>,
    pub args: PgPtr<List>,
    pub repeatable: PgPtr<Node>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ColumnDef {
    pub type_: NodeTag,
    pub colname: PgPtr<::std::os::raw::c_char>,
    pub typeName: PgPtr<TypeName>,
    pub inhcount: ::std::os::raw::c_int,
    pub is_local: bool,
    pub is_not_null: bool,
    pub is_from_type: bool,
    pub storage: ::std::os::raw::c_char,
    pub raw_default: PgPtr<Node>,
    pub cooked_default: PgPtr<Node>,
    pub identity: ::std::os::raw::c_char,
    pub identitySequence: PgPtr<RangeVar>,
    pub generated: ::std::os::raw::c_char,
    pub collClause: PgPtr<CollateClause>,
    pub collOid: Oid,
    pub constraints: PgPtr<List>,
    pub fdwoptions: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct TableLikeClause {
    pub type_: NodeTag,
    pub relation: PgPtr<RangeVar>,
    pub options: bits32,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum TableLikeOption {
    CREATE_TABLE_LIKE_COMMENTS = 1,
    CREATE_TABLE_LIKE_CONSTRAINTS = 2,
    CREATE_TABLE_LIKE_DEFAULTS = 4,
    CREATE_TABLE_LIKE_GENERATED = 8,
    CREATE_TABLE_LIKE_IDENTITY = 16,
    CREATE_TABLE_LIKE_INDEXES = 32,
    CREATE_TABLE_LIKE_STATISTICS = 64,
    CREATE_TABLE_LIKE_STORAGE = 128,
    CREATE_TABLE_LIKE_ALL = 2147483647,
}
#[repr(C)]
pub struct IndexElem {
    pub type_: NodeTag,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub expr: PgPtr<Node>,
    pub indexcolname: PgPtr<::std::os::raw::c_char>,
    pub collation: PgPtr<List>,
    pub opclass: PgPtr<List>,
    pub ordering: SortByDir,
    pub nulls_ordering: SortByNulls,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum DefElemAction {
    DEFELEM_UNSPEC = 0,
    DEFELEM_SET = 1,
    DEFELEM_ADD = 2,
    DEFELEM_DROP = 3,
}
#[repr(C)]
pub struct DefElem {
    pub type_: NodeTag,
    pub defnamespace: PgPtr<::std::os::raw::c_char>,
    pub defname: PgPtr<::std::os::raw::c_char>,
    pub arg: PgPtr<Node>,
    pub defaction: DefElemAction,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct LockingClause {
    pub type_: NodeTag,
    pub lockedRels: PgPtr<List>,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
}
#[repr(C)]
pub struct XmlSerialize {
    pub type_: NodeTag,
    pub xmloption: XmlOptionType,
    pub expr: PgPtr<Node>,
    pub typeName: PgPtr<TypeName>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct PartitionElem {
    pub type_: NodeTag,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub expr: PgPtr<Node>,
    pub collation: PgPtr<List>,
    pub opclass: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct PartitionSpec {
    pub type_: NodeTag,
    pub strategy: PgPtr<::std::os::raw::c_char>,
    pub partParams: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct PartitionBoundSpec {
    pub type_: NodeTag,
    pub strategy: ::std::os::raw::c_char,
    pub is_default: bool,
    pub modulus: ::std::os::raw::c_int,
    pub remainder: ::std::os::raw::c_int,
    pub listdatums: PgPtr<List>,
    pub lowerdatums: PgPtr<List>,
    pub upperdatums: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(i32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum PartitionRangeDatumKind {
    PARTITION_RANGE_DATUM_MINVALUE = -1,
    PARTITION_RANGE_DATUM_VALUE = 0,
    PARTITION_RANGE_DATUM_MAXVALUE = 1,
}
#[repr(C)]
pub struct PartitionRangeDatum {
    pub type_: NodeTag,
    pub kind: PartitionRangeDatumKind,
    pub value: PgPtr<Node>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct PartitionCmd {
    pub type_: NodeTag,
    pub name: PgPtr<RangeVar>,
    pub bound: PgPtr<PartitionBoundSpec>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum RTEKind {
    RTE_RELATION = 0,
    RTE_SUBQUERY = 1,
    RTE_JOIN = 2,
    RTE_FUNCTION = 3,
    RTE_TABLEFUNC = 4,
    RTE_VALUES = 5,
    RTE_CTE = 6,
    RTE_NAMEDTUPLESTORE = 7,
    RTE_RESULT = 8,
}
#[repr(C)]
pub struct RangeTblEntry {
    pub type_: NodeTag,
    pub rtekind: RTEKind,
    pub relid: Oid,
    pub relkind: ::std::os::raw::c_char,
    pub rellockmode: ::std::os::raw::c_int,
    pub tablesample: PgPtr<TableSampleClause>,
    pub subquery: PgPtr<Query>,
    pub security_barrier: bool,
    pub jointype: JoinType,
    pub joinaliasvars: PgPtr<List>,
    pub functions: PgPtr<List>,
    pub funcordinality: bool,
    pub tablefunc: PgPtr<TableFunc>,
    pub values_lists: PgPtr<List>,
    pub ctename: PgPtr<::std::os::raw::c_char>,
    pub ctelevelsup: Index,
    pub self_reference: bool,
    pub coltypes: PgPtr<List>,
    pub coltypmods: PgPtr<List>,
    pub colcollations: PgPtr<List>,
    pub enrname: PgPtr<::std::os::raw::c_char>,
    pub enrtuples: f64,
    pub alias: PgPtr<Alias>,
    pub eref: PgPtr<Alias>,
    pub lateral: bool,
    pub inh: bool,
    pub inFromCl: bool,
    pub requiredPerms: AclMode,
    pub checkAsUser: Oid,
    pub selectedCols: PgPtr<Bitmapset>,
    pub insertedCols: PgPtr<Bitmapset>,
    pub updatedCols: PgPtr<Bitmapset>,
    pub extraUpdatedCols: PgPtr<Bitmapset>,
    pub securityQuals: PgPtr<List>,
}
#[repr(C)]
pub struct RangeTblFunction {
    pub type_: NodeTag,
    pub funcexpr: PgPtr<Node>,
    pub funccolcount: ::std::os::raw::c_int,
    pub funccolnames: PgPtr<List>,
    pub funccoltypes: PgPtr<List>,
    pub funccoltypmods: PgPtr<List>,
    pub funccolcollations: PgPtr<List>,
    pub funcparams: PgPtr<Bitmapset>,
}
#[repr(C)]
pub struct TableSampleClause {
    pub type_: NodeTag,
    pub tsmhandler: Oid,
    pub args: PgPtr<List>,
    pub repeatable: PgPtr<Expr>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum WCOKind {
    WCO_VIEW_CHECK = 0,
    WCO_RLS_INSERT_CHECK = 1,
    WCO_RLS_UPDATE_CHECK = 2,
    WCO_RLS_CONFLICT_CHECK = 3,
}
#[repr(C)]
pub struct WithCheckOption {
    pub type_: NodeTag,
    pub kind: WCOKind,
    pub relname: PgPtr<::std::os::raw::c_char>,
    pub polname: PgPtr<::std::os::raw::c_char>,
    pub qual: PgPtr<Node>,
    pub cascaded: bool,
}
#[repr(C)]
pub struct SortGroupClause {
    pub type_: NodeTag,
    pub tleSortGroupRef: Index,
    pub eqop: Oid,
    pub sortop: Oid,
    pub nulls_first: bool,
    pub hashable: bool,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum GroupingSetKind {
    GROUPING_SET_EMPTY = 0,
    GROUPING_SET_SIMPLE = 1,
    GROUPING_SET_ROLLUP = 2,
    GROUPING_SET_CUBE = 3,
    GROUPING_SET_SETS = 4,
}
#[repr(C)]
pub struct GroupingSet {
    pub type_: NodeTag,
    pub kind: GroupingSetKind,
    pub content: PgPtr<List>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct WindowClause {
    pub type_: NodeTag,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub refname: PgPtr<::std::os::raw::c_char>,
    pub partitionClause: PgPtr<List>,
    pub orderClause: PgPtr<List>,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: PgPtr<Node>,
    pub endOffset: PgPtr<Node>,
    pub startInRangeFunc: Oid,
    pub endInRangeFunc: Oid,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
    pub winref: Index,
    pub copiedOrder: bool,
}
#[repr(C)]
pub struct RowMarkClause {
    pub type_: NodeTag,
    pub rti: Index,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub pushedDown: bool,
}
#[repr(C)]
pub struct WithClause {
    pub type_: NodeTag,
    pub ctes: PgPtr<List>,
    pub recursive: bool,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct InferClause {
    pub type_: NodeTag,
    pub indexElems: PgPtr<List>,
    pub whereClause: PgPtr<Node>,
    pub conname: PgPtr<::std::os::raw::c_char>,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct OnConflictClause {
    pub type_: NodeTag,
    pub action: OnConflictAction,
    pub infer: PgPtr<InferClause>,
    pub targetList: PgPtr<List>,
    pub whereClause: PgPtr<Node>,
    pub location: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum CTEMaterialize {
    CTEMaterializeDefault = 0,
    CTEMaterializeAlways = 1,
    CTEMaterializeNever = 2,
}
#[repr(C)]
pub struct CommonTableExpr {
    pub type_: NodeTag,
    pub ctename: PgPtr<::std::os::raw::c_char>,
    pub aliascolnames: PgPtr<List>,
    pub ctematerialized: CTEMaterialize,
    pub ctequery: PgPtr<Node>,
    pub location: ::std::os::raw::c_int,
    pub cterecursive: bool,
    pub cterefcount: ::std::os::raw::c_int,
    pub ctecolnames: PgPtr<List>,
    pub ctecoltypes: PgPtr<List>,
    pub ctecoltypmods: PgPtr<List>,
    pub ctecolcollations: PgPtr<List>,
}
#[repr(C)]
pub struct TriggerTransition {
    pub type_: NodeTag,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub isNew: bool,
    pub isTable: bool,
}
#[doc = "\t\tRaw Grammar Output Statements"]
#[repr(C)]
pub struct RawStmt {
    pub type_: NodeTag,
    pub stmt: PgPtr<Node>,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
#[doc = "\t\tOptimizable Statements"]
#[repr(C)]
pub struct InsertStmt {
    pub type_: NodeTag,
    pub relation: PgPtr<RangeVar>,
    pub cols: PgPtr<List>,
    pub selectStmt: PgPtr<Node>,
    pub onConflictClause: PgPtr<OnConflictClause>,
    pub returningList: PgPtr<List>,
    pub withClause: PgPtr<WithClause>,
    pub override_: OverridingKind,
}
#[repr(C)]
pub struct DeleteStmt {
    pub type_: NodeTag,
    pub relation: PgPtr<RangeVar>,
    pub usingClause: PgPtr<List>,
    pub whereClause: PgPtr<Node>,
    pub returningList: PgPtr<List>,
    pub withClause: PgPtr<WithClause>,
}
#[repr(C)]
pub struct UpdateStmt {
    pub type_: NodeTag,
    pub relation: PgPtr<RangeVar>,
    pub targetList: PgPtr<List>,
    pub whereClause: PgPtr<Node>,
    pub fromClause: PgPtr<List>,
    pub returningList: PgPtr<List>,
    pub withClause: PgPtr<WithClause>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SetOperation {
    SETOP_NONE = 0,
    SETOP_UNION = 1,
    SETOP_INTERSECT = 2,
    SETOP_EXCEPT = 3,
}
#[repr(C)]
pub struct SelectStmt {
    pub type_: NodeTag,
    pub distinctClause: PgPtr<List>,
    pub intoClause: PgPtr<IntoClause>,
    pub targetList: PgPtr<List>,
    pub fromClause: PgPtr<List>,
    pub whereClause: PgPtr<Node>,
    pub groupClause: PgPtr<List>,
    pub havingClause: PgPtr<Node>,
    pub windowClause: PgPtr<List>,
    pub valuesLists: PgPtr<List>,
    pub sortClause: PgPtr<List>,
    pub limitOffset: PgPtr<Node>,
    pub limitCount: PgPtr<Node>,
    pub lockingClause: PgPtr<List>,
    pub withClause: PgPtr<WithClause>,
    pub op: SetOperation,
    pub all: bool,
    pub larg: PgPtr<SelectStmt>,
    pub rarg: PgPtr<SelectStmt>,
}
#[repr(C)]
pub struct SetOperationStmt {
    pub type_: NodeTag,
    pub op: SetOperation,
    pub all: bool,
    pub larg: PgPtr<Node>,
    pub rarg: PgPtr<Node>,
    pub colTypes: PgPtr<List>,
    pub colTypmods: PgPtr<List>,
    pub colCollations: PgPtr<List>,
    pub groupClauses: PgPtr<List>,
}
#[repr(u32)]
#[doc = "\t\tOther Statements (no optimizations required)"]
#[doc = ""]
#[doc = "\t\tThese are not touched by parser/analyze.c except to put them into"]
#[doc = "\t\tthe utilityStmt field of a Query.  This is eventually passed to"]
#[doc = "\t\tProcessUtility (by-passing rewriting and planning).  Some of the"]
#[doc = "\t\tstatements do need attention from parse analysis, and this is"]
#[doc = "\t\tdone by routines in parser/parse_utilcmd.c after ProcessUtility"]
#[doc = "\t\treceives the command for execution."]
#[doc = "\t\tDECLARE CURSOR, EXPLAIN, and CREATE TABLE AS are special cases:"]
#[doc = "\t\tthey contain optimizable statements, which get processed normally"]
#[doc = "\t\tby parser/analyze.c."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ObjectType {
    OBJECT_ACCESS_METHOD = 0,
    OBJECT_AGGREGATE = 1,
    OBJECT_AMOP = 2,
    OBJECT_AMPROC = 3,
    OBJECT_ATTRIBUTE = 4,
    OBJECT_CAST = 5,
    OBJECT_COLUMN = 6,
    OBJECT_COLLATION = 7,
    OBJECT_CONVERSION = 8,
    OBJECT_DATABASE = 9,
    OBJECT_DEFAULT = 10,
    OBJECT_DEFACL = 11,
    OBJECT_DOMAIN = 12,
    OBJECT_DOMCONSTRAINT = 13,
    OBJECT_EVENT_TRIGGER = 14,
    OBJECT_EXTENSION = 15,
    OBJECT_FDW = 16,
    OBJECT_FOREIGN_SERVER = 17,
    OBJECT_FOREIGN_TABLE = 18,
    OBJECT_FUNCTION = 19,
    OBJECT_INDEX = 20,
    OBJECT_LANGUAGE = 21,
    OBJECT_LARGEOBJECT = 22,
    OBJECT_MATVIEW = 23,
    OBJECT_OPCLASS = 24,
    OBJECT_OPERATOR = 25,
    OBJECT_OPFAMILY = 26,
    OBJECT_POLICY = 27,
    OBJECT_PROCEDURE = 28,
    OBJECT_PUBLICATION = 29,
    OBJECT_PUBLICATION_REL = 30,
    OBJECT_ROLE = 31,
    OBJECT_ROUTINE = 32,
    OBJECT_RULE = 33,
    OBJECT_SCHEMA = 34,
    OBJECT_SEQUENCE = 35,
    OBJECT_SUBSCRIPTION = 36,
    OBJECT_STATISTIC_EXT = 37,
    OBJECT_TABCONSTRAINT = 38,
    OBJECT_TABLE = 39,
    OBJECT_TABLESPACE = 40,
    OBJECT_TRANSFORM = 41,
    OBJECT_TRIGGER = 42,
    OBJECT_TSCONFIGURATION = 43,
    OBJECT_TSDICTIONARY = 44,
    OBJECT_TSPARSER = 45,
    OBJECT_TSTEMPLATE = 46,
    OBJECT_TYPE = 47,
    OBJECT_USER_MAPPING = 48,
    OBJECT_VIEW = 49,
}
#[repr(C)]
pub struct CreateSchemaStmt {
    pub type_: NodeTag,
    pub schemaname: PgPtr<::std::os::raw::c_char>,
    pub authrole: PgPtr<RoleSpec>,
    pub schemaElts: PgPtr<List>,
    pub if_not_exists: bool,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum DropBehavior {
    DROP_RESTRICT = 0,
    DROP_CASCADE = 1,
}
#[repr(C)]
pub struct AlterTableStmt {
    pub type_: NodeTag,
    pub relation: PgPtr<RangeVar>,
    pub cmds: PgPtr<List>,
    pub relkind: ObjectType,
    pub missing_ok: bool,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum AlterTableType {
    AT_AddColumn = 0,
    AT_AddColumnRecurse = 1,
    AT_AddColumnToView = 2,
    AT_ColumnDefault = 3,
    AT_DropNotNull = 4,
    AT_SetNotNull = 5,
    AT_CheckNotNull = 6,
    AT_SetStatistics = 7,
    AT_SetOptions = 8,
    AT_ResetOptions = 9,
    AT_SetStorage = 10,
    AT_DropColumn = 11,
    AT_DropColumnRecurse = 12,
    AT_AddIndex = 13,
    AT_ReAddIndex = 14,
    AT_AddConstraint = 15,
    AT_AddConstraintRecurse = 16,
    AT_ReAddConstraint = 17,
    AT_ReAddDomainConstraint = 18,
    AT_AlterConstraint = 19,
    AT_ValidateConstraint = 20,
    AT_ValidateConstraintRecurse = 21,
    AT_ProcessedConstraint = 22,
    AT_AddIndexConstraint = 23,
    AT_DropConstraint = 24,
    AT_DropConstraintRecurse = 25,
    AT_ReAddComment = 26,
    AT_AlterColumnType = 27,
    AT_AlterColumnGenericOptions = 28,
    AT_ChangeOwner = 29,
    AT_ClusterOn = 30,
    AT_DropCluster = 31,
    AT_SetLogged = 32,
    AT_SetUnLogged = 33,
    AT_DropOids = 34,
    AT_SetTableSpace = 35,
    AT_SetRelOptions = 36,
    AT_ResetRelOptions = 37,
    AT_ReplaceRelOptions = 38,
    AT_EnableTrig = 39,
    AT_EnableAlwaysTrig = 40,
    AT_EnableReplicaTrig = 41,
    AT_DisableTrig = 42,
    AT_EnableTrigAll = 43,
    AT_DisableTrigAll = 44,
    AT_EnableTrigUser = 45,
    AT_DisableTrigUser = 46,
    AT_EnableRule = 47,
    AT_EnableAlwaysRule = 48,
    AT_EnableReplicaRule = 49,
    AT_DisableRule = 50,
    AT_AddInherit = 51,
    AT_DropInherit = 52,
    AT_AddOf = 53,
    AT_DropOf = 54,
    AT_ReplicaIdentity = 55,
    AT_EnableRowSecurity = 56,
    AT_DisableRowSecurity = 57,
    AT_ForceRowSecurity = 58,
    AT_NoForceRowSecurity = 59,
    AT_GenericOptions = 60,
    AT_AttachPartition = 61,
    AT_DetachPartition = 62,
    AT_AddIdentity = 63,
    AT_SetIdentity = 64,
    AT_DropIdentity = 65,
}
#[repr(C)]
pub struct ReplicaIdentityStmt {
    pub type_: NodeTag,
    pub identity_type: ::std::os::raw::c_char,
    pub name: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct AlterTableCmd {
    pub type_: NodeTag,
    pub subtype: AlterTableType,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub num: int16,
    pub newowner: PgPtr<RoleSpec>,
    pub def: PgPtr<Node>,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
}
#[repr(C)]
pub struct AlterCollationStmt {
    pub type_: NodeTag,
    pub collname: PgPtr<List>,
}
#[repr(C)]
pub struct AlterDomainStmt {
    pub type_: NodeTag,
    pub subtype: ::std::os::raw::c_char,
    pub typeName: PgPtr<List>,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub def: PgPtr<Node>,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrantTargetType {
    ACL_TARGET_OBJECT = 0,
    ACL_TARGET_ALL_IN_SCHEMA = 1,
    ACL_TARGET_DEFAULTS = 2,
}
#[repr(C)]
pub struct GrantStmt {
    pub type_: NodeTag,
    pub is_grant: bool,
    pub targtype: GrantTargetType,
    pub objtype: ObjectType,
    pub objects: PgPtr<List>,
    pub privileges: PgPtr<List>,
    pub grantees: PgPtr<List>,
    pub grant_option: bool,
    pub behavior: DropBehavior,
}
#[repr(C)]
pub struct ObjectWithArgs {
    pub type_: NodeTag,
    pub objname: PgPtr<List>,
    pub objargs: PgPtr<List>,
    pub args_unspecified: bool,
}
#[repr(C)]
pub struct AccessPriv {
    pub type_: NodeTag,
    pub priv_name: PgPtr<::std::os::raw::c_char>,
    pub cols: PgPtr<List>,
}
#[repr(C)]
pub struct GrantRoleStmt {
    pub type_: NodeTag,
    pub granted_roles: PgPtr<List>,
    pub grantee_roles: PgPtr<List>,
    pub is_grant: bool,
    pub admin_opt: bool,
    pub grantor: PgPtr<RoleSpec>,
    pub behavior: DropBehavior,
}
#[repr(C)]
pub struct AlterDefaultPrivilegesStmt {
    pub type_: NodeTag,
    pub options: PgPtr<List>,
    pub action: PgPtr<GrantStmt>,
}
#[repr(C)]
pub struct CopyStmt {
    pub type_: NodeTag,
    pub relation: PgPtr<RangeVar>,
    pub query: PgPtr<Node>,
    pub attlist: PgPtr<List>,
    pub is_from: bool,
    pub is_program: bool,
    pub filename: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
    pub whereClause: PgPtr<Node>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum VariableSetKind {
    VAR_SET_VALUE = 0,
    VAR_SET_DEFAULT = 1,
    VAR_SET_CURRENT = 2,
    VAR_SET_MULTI = 3,
    VAR_RESET = 4,
    VAR_RESET_ALL = 5,
}
#[repr(C)]
pub struct VariableSetStmt {
    pub type_: NodeTag,
    pub kind: VariableSetKind,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub args: PgPtr<List>,
    pub is_local: bool,
}
#[repr(C)]
pub struct VariableShowStmt {
    pub type_: NodeTag,
    pub name: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct CreateStmt {
    pub type_: NodeTag,
    pub relation: PgPtr<RangeVar>,
    pub tableElts: PgPtr<List>,
    pub inhRelations: PgPtr<List>,
    pub partbound: PgPtr<PartitionBoundSpec>,
    pub partspec: PgPtr<PartitionSpec>,
    pub ofTypename: PgPtr<TypeName>,
    pub constraints: PgPtr<List>,
    pub options: PgPtr<List>,
    pub oncommit: OnCommitAction,
    pub tablespacename: PgPtr<::std::os::raw::c_char>,
    pub accessMethod: PgPtr<::std::os::raw::c_char>,
    pub if_not_exists: bool,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ConstrType {
    CONSTR_NULL = 0,
    CONSTR_NOTNULL = 1,
    CONSTR_DEFAULT = 2,
    CONSTR_IDENTITY = 3,
    CONSTR_GENERATED = 4,
    CONSTR_CHECK = 5,
    CONSTR_PRIMARY = 6,
    CONSTR_UNIQUE = 7,
    CONSTR_EXCLUSION = 8,
    CONSTR_FOREIGN = 9,
    CONSTR_ATTR_DEFERRABLE = 10,
    CONSTR_ATTR_NOT_DEFERRABLE = 11,
    CONSTR_ATTR_DEFERRED = 12,
    CONSTR_ATTR_IMMEDIATE = 13,
}
#[repr(C)]
pub struct Constraint {
    pub type_: NodeTag,
    pub contype: ConstrType,
    pub conname: PgPtr<::std::os::raw::c_char>,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub location: ::std::os::raw::c_int,
    pub is_no_inherit: bool,
    pub raw_expr: PgPtr<Node>,
    pub cooked_expr: PgPtr<::std::os::raw::c_char>,
    pub generated_when: ::std::os::raw::c_char,
    pub keys: PgPtr<List>,
    pub including: PgPtr<List>,
    pub exclusions: PgPtr<List>,
    pub options: PgPtr<List>,
    pub indexname: PgPtr<::std::os::raw::c_char>,
    pub indexspace: PgPtr<::std::os::raw::c_char>,
    pub reset_default_tblspc: bool,
    pub access_method: PgPtr<::std::os::raw::c_char>,
    pub where_clause: PgPtr<Node>,
    pub pktable: PgPtr<RangeVar>,
    pub fk_attrs: PgPtr<List>,
    pub pk_attrs: PgPtr<List>,
    pub fk_matchtype: ::std::os::raw::c_char,
    pub fk_upd_action: ::std::os::raw::c_char,
    pub fk_del_action: ::std::os::raw::c_char,
    pub old_conpfeqop: PgPtr<List>,
    pub old_pktable_oid: Oid,
    pub skip_validation: bool,
    pub initially_valid: bool,
}
#[repr(C)]
pub struct CreateTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: PgPtr<::std::os::raw::c_char>,
    pub owner: PgPtr<RoleSpec>,
    pub location: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct DropTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: PgPtr<::std::os::raw::c_char>,
    pub missing_ok: bool,
}
#[repr(C)]
pub struct AlterTableSpaceOptionsStmt {
    pub type_: NodeTag,
    pub tablespacename: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
    pub isReset: bool,
}
#[repr(C)]
pub struct AlterTableMoveAllStmt {
    pub type_: NodeTag,
    pub orig_tablespacename: PgPtr<::std::os::raw::c_char>,
    pub objtype: ObjectType,
    pub roles: PgPtr<List>,
    pub new_tablespacename: PgPtr<::std::os::raw::c_char>,
    pub nowait: bool,
}
#[repr(C)]
pub struct CreateExtensionStmt {
    pub type_: NodeTag,
    pub extname: PgPtr<::std::os::raw::c_char>,
    pub if_not_exists: bool,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct AlterExtensionStmt {
    pub type_: NodeTag,
    pub extname: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct AlterExtensionContentsStmt {
    pub type_: NodeTag,
    pub extname: PgPtr<::std::os::raw::c_char>,
    pub action: ::std::os::raw::c_int,
    pub objtype: ObjectType,
    pub object: PgPtr<Node>,
}
#[repr(C)]
pub struct CreateFdwStmt {
    pub type_: NodeTag,
    pub fdwname: PgPtr<::std::os::raw::c_char>,
    pub func_options: PgPtr<List>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct AlterFdwStmt {
    pub type_: NodeTag,
    pub fdwname: PgPtr<::std::os::raw::c_char>,
    pub func_options: PgPtr<List>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct CreateForeignServerStmt {
    pub type_: NodeTag,
    pub servername: PgPtr<::std::os::raw::c_char>,
    pub servertype: PgPtr<::std::os::raw::c_char>,
    pub version: PgPtr<::std::os::raw::c_char>,
    pub fdwname: PgPtr<::std::os::raw::c_char>,
    pub if_not_exists: bool,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct AlterForeignServerStmt {
    pub type_: NodeTag,
    pub servername: PgPtr<::std::os::raw::c_char>,
    pub version: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
    pub has_version: bool,
}
#[repr(C)]
pub struct CreateForeignTableStmt {
    pub base: CreateStmt,
    pub servername: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct CreateUserMappingStmt {
    pub type_: NodeTag,
    pub user: PgPtr<RoleSpec>,
    pub servername: PgPtr<::std::os::raw::c_char>,
    pub if_not_exists: bool,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct AlterUserMappingStmt {
    pub type_: NodeTag,
    pub user: PgPtr<RoleSpec>,
    pub servername: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct DropUserMappingStmt {
    pub type_: NodeTag,
    pub user: PgPtr<RoleSpec>,
    pub servername: PgPtr<::std::os::raw::c_char>,
    pub missing_ok: bool,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ImportForeignSchemaType {
    FDW_IMPORT_SCHEMA_ALL = 0,
    FDW_IMPORT_SCHEMA_LIMIT_TO = 1,
    FDW_IMPORT_SCHEMA_EXCEPT = 2,
}
#[repr(C)]
pub struct ImportForeignSchemaStmt {
    pub type_: NodeTag,
    pub server_name: PgPtr<::std::os::raw::c_char>,
    pub remote_schema: PgPtr<::std::os::raw::c_char>,
    pub local_schema: PgPtr<::std::os::raw::c_char>,
    pub list_type: ImportForeignSchemaType,
    pub table_list: PgPtr<List>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct CreatePolicyStmt {
    pub type_: NodeTag,
    pub policy_name: PgPtr<::std::os::raw::c_char>,
    pub table: PgPtr<RangeVar>,
    pub cmd_name: PgPtr<::std::os::raw::c_char>,
    pub permissive: bool,
    pub roles: PgPtr<List>,
    pub qual: PgPtr<Node>,
    pub with_check: PgPtr<Node>,
}
#[repr(C)]
pub struct AlterPolicyStmt {
    pub type_: NodeTag,
    pub policy_name: PgPtr<::std::os::raw::c_char>,
    pub table: PgPtr<RangeVar>,
    pub roles: PgPtr<List>,
    pub qual: PgPtr<Node>,
    pub with_check: PgPtr<Node>,
}
#[repr(C)]
pub struct CreateAmStmt {
    pub type_: NodeTag,
    pub amname: PgPtr<::std::os::raw::c_char>,
    pub handler_name: PgPtr<List>,
    pub amtype: ::std::os::raw::c_char,
}
#[repr(C)]
pub struct CreateTrigStmt {
    pub type_: NodeTag,
    pub trigname: PgPtr<::std::os::raw::c_char>,
    pub relation: PgPtr<RangeVar>,
    pub funcname: PgPtr<List>,
    pub args: PgPtr<List>,
    pub row: bool,
    pub timing: int16,
    pub events: int16,
    pub columns: PgPtr<List>,
    pub whenClause: PgPtr<Node>,
    pub isconstraint: bool,
    pub transitionRels: PgPtr<List>,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub constrrel: PgPtr<RangeVar>,
}
#[repr(C)]
pub struct CreateEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: PgPtr<::std::os::raw::c_char>,
    pub eventname: PgPtr<::std::os::raw::c_char>,
    pub whenclause: PgPtr<List>,
    pub funcname: PgPtr<List>,
}
#[repr(C)]
pub struct AlterEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: PgPtr<::std::os::raw::c_char>,
    pub tgenabled: ::std::os::raw::c_char,
}
#[repr(C)]
pub struct CreatePLangStmt {
    pub type_: NodeTag,
    pub replace: bool,
    pub plname: PgPtr<::std::os::raw::c_char>,
    pub plhandler: PgPtr<List>,
    pub plinline: PgPtr<List>,
    pub plvalidator: PgPtr<List>,
    pub pltrusted: bool,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum RoleStmtType {
    ROLESTMT_ROLE = 0,
    ROLESTMT_USER = 1,
    ROLESTMT_GROUP = 2,
}
#[repr(C)]
pub struct CreateRoleStmt {
    pub type_: NodeTag,
    pub stmt_type: RoleStmtType,
    pub role: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct AlterRoleStmt {
    pub type_: NodeTag,
    pub role: PgPtr<RoleSpec>,
    pub options: PgPtr<List>,
    pub action: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct AlterRoleSetStmt {
    pub type_: NodeTag,
    pub role: PgPtr<RoleSpec>,
    pub database: PgPtr<::std::os::raw::c_char>,
    pub setstmt: PgPtr<VariableSetStmt>,
}
#[repr(C)]
pub struct DropRoleStmt {
    pub type_: NodeTag,
    pub roles: PgPtr<List>,
    pub missing_ok: bool,
}
#[repr(C)]
pub struct CreateSeqStmt {
    pub type_: NodeTag,
    pub sequence: PgPtr<RangeVar>,
    pub options: PgPtr<List>,
    pub ownerId: Oid,
    pub for_identity: bool,
    pub if_not_exists: bool,
}
#[repr(C)]
pub struct AlterSeqStmt {
    pub type_: NodeTag,
    pub sequence: PgPtr<RangeVar>,
    pub options: PgPtr<List>,
    pub for_identity: bool,
    pub missing_ok: bool,
}
#[repr(C)]
pub struct DefineStmt {
    pub type_: NodeTag,
    pub kind: ObjectType,
    pub oldstyle: bool,
    pub defnames: PgPtr<List>,
    pub args: PgPtr<List>,
    pub definition: PgPtr<List>,
    pub if_not_exists: bool,
    pub replace: bool,
}
#[repr(C)]
pub struct CreateDomainStmt {
    pub type_: NodeTag,
    pub domainname: PgPtr<List>,
    pub typeName: PgPtr<TypeName>,
    pub collClause: PgPtr<CollateClause>,
    pub constraints: PgPtr<List>,
}
#[repr(C)]
pub struct CreateOpClassStmt {
    pub type_: NodeTag,
    pub opclassname: PgPtr<List>,
    pub opfamilyname: PgPtr<List>,
    pub amname: PgPtr<::std::os::raw::c_char>,
    pub datatype: PgPtr<TypeName>,
    pub items: PgPtr<List>,
    pub isDefault: bool,
}
#[repr(C)]
pub struct CreateOpClassItem {
    pub type_: NodeTag,
    pub itemtype: ::std::os::raw::c_int,
    pub name: PgPtr<ObjectWithArgs>,
    pub number: ::std::os::raw::c_int,
    pub order_family: PgPtr<List>,
    pub class_args: PgPtr<List>,
    pub storedtype: PgPtr<TypeName>,
}
#[repr(C)]
pub struct CreateOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: PgPtr<List>,
    pub amname: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct AlterOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: PgPtr<List>,
    pub amname: PgPtr<::std::os::raw::c_char>,
    pub isDrop: bool,
    pub items: PgPtr<List>,
}
#[repr(C)]
pub struct DropStmt {
    pub type_: NodeTag,
    pub objects: PgPtr<List>,
    pub removeType: ObjectType,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
    pub concurrent: bool,
}
#[repr(C)]
pub struct TruncateStmt {
    pub type_: NodeTag,
    pub relations: PgPtr<List>,
    pub restart_seqs: bool,
    pub behavior: DropBehavior,
}
#[repr(C)]
pub struct CommentStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub object: PgPtr<Node>,
    pub comment: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct SecLabelStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub object: PgPtr<Node>,
    pub provider: PgPtr<::std::os::raw::c_char>,
    pub label: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct DeclareCursorStmt {
    pub type_: NodeTag,
    pub portalname: PgPtr<::std::os::raw::c_char>,
    pub options: ::std::os::raw::c_int,
    pub query: PgPtr<Node>,
}
#[repr(C)]
pub struct ClosePortalStmt {
    pub type_: NodeTag,
    pub portalname: PgPtr<::std::os::raw::c_char>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum FetchDirection {
    FETCH_FORWARD = 0,
    FETCH_BACKWARD = 1,
    FETCH_ABSOLUTE = 2,
    FETCH_RELATIVE = 3,
}
#[repr(C)]
pub struct FetchStmt {
    pub type_: NodeTag,
    pub direction: FetchDirection,
    pub howMany: ::std::os::raw::c_long,
    pub portalname: PgPtr<::std::os::raw::c_char>,
    pub ismove: bool,
}
#[repr(C)]
pub struct IndexStmt {
    pub type_: NodeTag,
    pub idxname: PgPtr<::std::os::raw::c_char>,
    pub relation: PgPtr<RangeVar>,
    pub accessMethod: PgPtr<::std::os::raw::c_char>,
    pub tableSpace: PgPtr<::std::os::raw::c_char>,
    pub indexParams: PgPtr<List>,
    pub indexIncludingParams: PgPtr<List>,
    pub options: PgPtr<List>,
    pub whereClause: PgPtr<Node>,
    pub excludeOpNames: PgPtr<List>,
    pub idxcomment: PgPtr<::std::os::raw::c_char>,
    pub indexOid: Oid,
    pub oldNode: Oid,
    pub unique: bool,
    pub primary: bool,
    pub isconstraint: bool,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub transformed: bool,
    pub concurrent: bool,
    pub if_not_exists: bool,
    pub reset_default_tblspc: bool,
}
#[repr(C)]
pub struct CreateStatsStmt {
    pub type_: NodeTag,
    pub defnames: PgPtr<List>,
    pub stat_types: PgPtr<List>,
    pub exprs: PgPtr<List>,
    pub relations: PgPtr<List>,
    pub stxcomment: PgPtr<::std::os::raw::c_char>,
    pub if_not_exists: bool,
}
#[repr(C)]
pub struct CreateFunctionStmt {
    pub type_: NodeTag,
    pub is_procedure: bool,
    pub replace: bool,
    pub funcname: PgPtr<List>,
    pub parameters: PgPtr<List>,
    pub returnType: PgPtr<TypeName>,
    pub options: PgPtr<List>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum FunctionParameterMode {
    FUNC_PARAM_IN = 105,
    FUNC_PARAM_OUT = 111,
    FUNC_PARAM_INOUT = 98,
    FUNC_PARAM_VARIADIC = 118,
    FUNC_PARAM_TABLE = 116,
}
#[repr(C)]
pub struct FunctionParameter {
    pub type_: NodeTag,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub argType: PgPtr<TypeName>,
    pub mode: FunctionParameterMode,
    pub defexpr: PgPtr<Node>,
}
#[repr(C)]
pub struct AlterFunctionStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub func: PgPtr<ObjectWithArgs>,
    pub actions: PgPtr<List>,
}
#[repr(C)]
pub struct DoStmt {
    pub type_: NodeTag,
    pub args: PgPtr<List>,
}
#[repr(C)]
pub struct InlineCodeBlock {
    pub type_: NodeTag,
    pub source_text: PgPtr<::std::os::raw::c_char>,
    pub langOid: Oid,
    pub langIsTrusted: bool,
    pub atomic: bool,
}
#[repr(C)]
pub struct CallStmt {
    pub type_: NodeTag,
    pub funccall: PgPtr<FuncCall>,
    pub funcexpr: PgPtr<FuncExpr>,
}
#[repr(C)]
pub struct CallContext {
    pub type_: NodeTag,
    pub atomic: bool,
}
#[repr(C)]
pub struct RenameStmt {
    pub type_: NodeTag,
    pub renameType: ObjectType,
    pub relationType: ObjectType,
    pub relation: PgPtr<RangeVar>,
    pub object: PgPtr<Node>,
    pub subname: PgPtr<::std::os::raw::c_char>,
    pub newname: PgPtr<::std::os::raw::c_char>,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
}
#[repr(C)]
pub struct AlterObjectDependsStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: PgPtr<RangeVar>,
    pub object: PgPtr<Node>,
    pub extname: PgPtr<Value>,
}
#[repr(C)]
pub struct AlterObjectSchemaStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: PgPtr<RangeVar>,
    pub object: PgPtr<Node>,
    pub newschema: PgPtr<::std::os::raw::c_char>,
    pub missing_ok: bool,
}
#[repr(C)]
pub struct AlterOwnerStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: PgPtr<RangeVar>,
    pub object: PgPtr<Node>,
    pub newowner: PgPtr<RoleSpec>,
}
#[repr(C)]
pub struct AlterOperatorStmt {
    pub type_: NodeTag,
    pub opername: PgPtr<ObjectWithArgs>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct RuleStmt {
    pub type_: NodeTag,
    pub relation: PgPtr<RangeVar>,
    pub rulename: PgPtr<::std::os::raw::c_char>,
    pub whereClause: PgPtr<Node>,
    pub event: CmdType,
    pub instead: bool,
    pub actions: PgPtr<List>,
    pub replace: bool,
}
#[repr(C)]
pub struct NotifyStmt {
    pub type_: NodeTag,
    pub conditionname: PgPtr<::std::os::raw::c_char>,
    pub payload: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct ListenStmt {
    pub type_: NodeTag,
    pub conditionname: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct UnlistenStmt {
    pub type_: NodeTag,
    pub conditionname: PgPtr<::std::os::raw::c_char>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum TransactionStmtKind {
    TRANS_STMT_BEGIN = 0,
    TRANS_STMT_START = 1,
    TRANS_STMT_COMMIT = 2,
    TRANS_STMT_ROLLBACK = 3,
    TRANS_STMT_SAVEPOINT = 4,
    TRANS_STMT_RELEASE = 5,
    TRANS_STMT_ROLLBACK_TO = 6,
    TRANS_STMT_PREPARE = 7,
    TRANS_STMT_COMMIT_PREPARED = 8,
    TRANS_STMT_ROLLBACK_PREPARED = 9,
}
#[repr(C)]
pub struct TransactionStmt {
    pub type_: NodeTag,
    pub kind: TransactionStmtKind,
    pub options: PgPtr<List>,
    pub savepoint_name: PgPtr<::std::os::raw::c_char>,
    pub gid: PgPtr<::std::os::raw::c_char>,
    pub chain: bool,
}
#[repr(C)]
pub struct CompositeTypeStmt {
    pub type_: NodeTag,
    pub typevar: PgPtr<RangeVar>,
    pub coldeflist: PgPtr<List>,
}
#[repr(C)]
pub struct CreateEnumStmt {
    pub type_: NodeTag,
    pub typeName: PgPtr<List>,
    pub vals: PgPtr<List>,
}
#[repr(C)]
pub struct CreateRangeStmt {
    pub type_: NodeTag,
    pub typeName: PgPtr<List>,
    pub params: PgPtr<List>,
}
#[repr(C)]
pub struct AlterEnumStmt {
    pub type_: NodeTag,
    pub typeName: PgPtr<List>,
    pub oldVal: PgPtr<::std::os::raw::c_char>,
    pub newVal: PgPtr<::std::os::raw::c_char>,
    pub newValNeighbor: PgPtr<::std::os::raw::c_char>,
    pub newValIsAfter: bool,
    pub skipIfNewValExists: bool,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ViewCheckOption {
    NO_CHECK_OPTION = 0,
    LOCAL_CHECK_OPTION = 1,
    CASCADED_CHECK_OPTION = 2,
}
#[repr(C)]
pub struct ViewStmt {
    pub type_: NodeTag,
    pub view: PgPtr<RangeVar>,
    pub aliases: PgPtr<List>,
    pub query: PgPtr<Node>,
    pub replace: bool,
    pub options: PgPtr<List>,
    pub withCheckOption: ViewCheckOption,
}
#[repr(C)]
pub struct LoadStmt {
    pub type_: NodeTag,
    pub filename: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct CreatedbStmt {
    pub type_: NodeTag,
    pub dbname: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct AlterDatabaseStmt {
    pub type_: NodeTag,
    pub dbname: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct AlterDatabaseSetStmt {
    pub type_: NodeTag,
    pub dbname: PgPtr<::std::os::raw::c_char>,
    pub setstmt: PgPtr<VariableSetStmt>,
}
#[repr(C)]
pub struct DropdbStmt {
    pub type_: NodeTag,
    pub dbname: PgPtr<::std::os::raw::c_char>,
    pub missing_ok: bool,
}
#[repr(C)]
pub struct AlterSystemStmt {
    pub type_: NodeTag,
    pub setstmt: PgPtr<VariableSetStmt>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ClusterOption {
    CLUOPT_RECHECK = 1,
    CLUOPT_VERBOSE = 2,
}
#[repr(C)]
pub struct ClusterStmt {
    pub type_: NodeTag,
    pub relation: PgPtr<RangeVar>,
    pub indexname: PgPtr<::std::os::raw::c_char>,
    pub options: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct VacuumStmt {
    pub type_: NodeTag,
    pub options: PgPtr<List>,
    pub rels: PgPtr<List>,
    pub is_vacuumcmd: bool,
}
#[repr(C)]
pub struct VacuumRelation {
    pub type_: NodeTag,
    pub relation: PgPtr<RangeVar>,
    pub oid: Oid,
    pub va_cols: PgPtr<List>,
}
#[repr(C)]
pub struct ExplainStmt {
    pub type_: NodeTag,
    pub query: PgPtr<Node>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct CreateTableAsStmt {
    pub type_: NodeTag,
    pub query: PgPtr<Node>,
    pub into: PgPtr<IntoClause>,
    pub relkind: ObjectType,
    pub is_select_into: bool,
    pub if_not_exists: bool,
}
#[repr(C)]
pub struct RefreshMatViewStmt {
    pub type_: NodeTag,
    pub concurrent: bool,
    pub skipData: bool,
    pub relation: PgPtr<RangeVar>,
}
#[repr(C)]
pub struct CheckPointStmt {
    pub type_: NodeTag,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum DiscardMode {
    DISCARD_ALL = 0,
    DISCARD_PLANS = 1,
    DISCARD_SEQUENCES = 2,
    DISCARD_TEMP = 3,
}
#[repr(C)]
pub struct DiscardStmt {
    pub type_: NodeTag,
    pub target: DiscardMode,
}
#[repr(C)]
pub struct LockStmt {
    pub type_: NodeTag,
    pub relations: PgPtr<List>,
    pub mode: ::std::os::raw::c_int,
    pub nowait: bool,
}
#[repr(C)]
pub struct ConstraintsSetStmt {
    pub type_: NodeTag,
    pub constraints: PgPtr<List>,
    pub deferred: bool,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ReindexObjectType {
    REINDEX_OBJECT_INDEX = 0,
    REINDEX_OBJECT_TABLE = 1,
    REINDEX_OBJECT_SCHEMA = 2,
    REINDEX_OBJECT_SYSTEM = 3,
    REINDEX_OBJECT_DATABASE = 4,
}
#[repr(C)]
pub struct ReindexStmt {
    pub type_: NodeTag,
    pub kind: ReindexObjectType,
    pub relation: PgPtr<RangeVar>,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub options: ::std::os::raw::c_int,
    pub concurrent: bool,
}
#[repr(C)]
pub struct CreateConversionStmt {
    pub type_: NodeTag,
    pub conversion_name: PgPtr<List>,
    pub for_encoding_name: PgPtr<::std::os::raw::c_char>,
    pub to_encoding_name: PgPtr<::std::os::raw::c_char>,
    pub func_name: PgPtr<List>,
    pub def: bool,
}
#[repr(C)]
pub struct CreateCastStmt {
    pub type_: NodeTag,
    pub sourcetype: PgPtr<TypeName>,
    pub targettype: PgPtr<TypeName>,
    pub func: PgPtr<ObjectWithArgs>,
    pub context: CoercionContext,
    pub inout: bool,
}
#[repr(C)]
pub struct CreateTransformStmt {
    pub type_: NodeTag,
    pub replace: bool,
    pub type_name: PgPtr<TypeName>,
    pub lang: PgPtr<::std::os::raw::c_char>,
    pub fromsql: PgPtr<ObjectWithArgs>,
    pub tosql: PgPtr<ObjectWithArgs>,
}
#[repr(C)]
pub struct PrepareStmt {
    pub type_: NodeTag,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub argtypes: PgPtr<List>,
    pub query: PgPtr<Node>,
}
#[repr(C)]
pub struct ExecuteStmt {
    pub type_: NodeTag,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub params: PgPtr<List>,
}
#[repr(C)]
pub struct DeallocateStmt {
    pub type_: NodeTag,
    pub name: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct DropOwnedStmt {
    pub type_: NodeTag,
    pub roles: PgPtr<List>,
    pub behavior: DropBehavior,
}
#[repr(C)]
pub struct ReassignOwnedStmt {
    pub type_: NodeTag,
    pub roles: PgPtr<List>,
    pub newrole: PgPtr<RoleSpec>,
}
#[repr(C)]
pub struct AlterTSDictionaryStmt {
    pub type_: NodeTag,
    pub dictname: PgPtr<List>,
    pub options: PgPtr<List>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum AlterTSConfigType {
    ALTER_TSCONFIG_ADD_MAPPING = 0,
    ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN = 1,
    ALTER_TSCONFIG_REPLACE_DICT = 2,
    ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN = 3,
    ALTER_TSCONFIG_DROP_MAPPING = 4,
}
#[repr(C)]
pub struct AlterTSConfigurationStmt {
    pub type_: NodeTag,
    pub kind: AlterTSConfigType,
    pub cfgname: PgPtr<List>,
    pub tokentype: PgPtr<List>,
    pub dicts: PgPtr<List>,
    pub override_: bool,
    pub replace: bool,
    pub missing_ok: bool,
}
#[repr(C)]
pub struct CreatePublicationStmt {
    pub type_: NodeTag,
    pub pubname: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
    pub tables: PgPtr<List>,
    pub for_all_tables: bool,
}
#[repr(C)]
pub struct AlterPublicationStmt {
    pub type_: NodeTag,
    pub pubname: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
    pub tables: PgPtr<List>,
    pub for_all_tables: bool,
    pub tableAction: DefElemAction,
}
#[repr(C)]
pub struct CreateSubscriptionStmt {
    pub type_: NodeTag,
    pub subname: PgPtr<::std::os::raw::c_char>,
    pub conninfo: PgPtr<::std::os::raw::c_char>,
    pub publication: PgPtr<List>,
    pub options: PgPtr<List>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum AlterSubscriptionType {
    ALTER_SUBSCRIPTION_OPTIONS = 0,
    ALTER_SUBSCRIPTION_CONNECTION = 1,
    ALTER_SUBSCRIPTION_PUBLICATION = 2,
    ALTER_SUBSCRIPTION_REFRESH = 3,
    ALTER_SUBSCRIPTION_ENABLED = 4,
}
#[repr(C)]
pub struct AlterSubscriptionStmt {
    pub type_: NodeTag,
    pub kind: AlterSubscriptionType,
    pub subname: PgPtr<::std::os::raw::c_char>,
    pub conninfo: PgPtr<::std::os::raw::c_char>,
    pub publication: PgPtr<List>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct DropSubscriptionStmt {
    pub type_: NodeTag,
    pub subname: PgPtr<::std::os::raw::c_char>,
    pub missing_ok: bool,
    pub behavior: DropBehavior,
}
#[repr(C)]
pub struct MemoryContextCounters {
    pub nblocks: Size,
    pub freechunks: Size,
    pub totalspace: Size,
    pub freespace: Size,
}
pub type MemoryStatsPrintFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: PgPtr<MemoryContextData>,
        passthru: PgPtr<::std::os::raw::c_void>,
        stats_string: PgPtr<::std::os::raw::c_char>,
    ),
>;
#[repr(C)]
pub struct MemoryContextMethods {
    pub alloc: ::std::option::Option<
        unsafe extern "C" fn(
            context: PgPtr<MemoryContextData>,
            size: Size,
        ) -> PgPtr<::std::os::raw::c_void>,
    >,
    pub free_p: ::std::option::Option<
        unsafe extern "C" fn(
            context: PgPtr<MemoryContextData>,
            pointer: PgPtr<::std::os::raw::c_void>,
        ),
    >,
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            context: PgPtr<MemoryContextData>,
            pointer: PgPtr<::std::os::raw::c_void>,
            size: Size,
        ) -> PgPtr<::std::os::raw::c_void>,
    >,
    pub reset: ::std::option::Option<unsafe extern "C" fn(context: PgPtr<MemoryContextData>)>,
    pub delete_context:
        ::std::option::Option<unsafe extern "C" fn(context: PgPtr<MemoryContextData>)>,
    pub get_chunk_space: ::std::option::Option<
        unsafe extern "C" fn(
            context: PgPtr<MemoryContextData>,
            pointer: PgPtr<::std::os::raw::c_void>,
        ) -> Size,
    >,
    pub is_empty:
        ::std::option::Option<unsafe extern "C" fn(context: PgPtr<MemoryContextData>) -> bool>,
    pub stats: ::std::option::Option<
        unsafe extern "C" fn(
            context: PgPtr<MemoryContextData>,
            printfunc: MemoryStatsPrintFunc,
            passthru: PgPtr<::std::os::raw::c_void>,
            totals: PgPtr<MemoryContextCounters>,
        ),
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(context: PgPtr<MemoryContextData>)>,
}
#[repr(C)]
pub struct MemoryContextData {
    pub type_: NodeTag,
    pub isReset: bool,
    pub allowInCritSection: bool,
    pub methods: PgPtr<MemoryContextMethods>,
    pub parent: PgPtr<MemoryContextData>,
    pub firstchild: PgPtr<MemoryContextData>,
    pub prevchild: PgPtr<MemoryContextData>,
    pub nextchild: PgPtr<MemoryContextData>,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub ident: PgPtr<::std::os::raw::c_char>,
    pub reset_cbs: PgPtr<MemoryContextCallback>,
}
#[pg_guard]
extern "C" {
    pub static mut TopMemoryContext: PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub static mut ErrorContext: PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub static mut PostmasterContext: PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub static mut CacheMemoryContext: PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub static mut MessageContext: PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub static mut TopTransactionContext: PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub static mut CurTransactionContext: PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub static mut PortalContext: PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextInit();
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextReset(context: PgPtr<MemoryContextData>);
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextDelete(context: PgPtr<MemoryContextData>);
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextResetOnly(context: PgPtr<MemoryContextData>);
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextResetChildren(context: PgPtr<MemoryContextData>);
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextDeleteChildren(context: PgPtr<MemoryContextData>);
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextSetIdentifier(
        context: PgPtr<MemoryContextData>,
        id: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextSetParent(
        context: PgPtr<MemoryContextData>,
        new_parent: PgPtr<MemoryContextData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn GetMemoryChunkSpace(pointer: PgPtr<::std::os::raw::c_void>) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextGetParent(context: PgPtr<MemoryContextData>) -> PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextIsEmpty(context: PgPtr<MemoryContextData>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextStats(context: PgPtr<MemoryContextData>);
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextStatsDetail(
        context: PgPtr<MemoryContextData>,
        max_children: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextAllowInCriticalSection(context: PgPtr<MemoryContextData>, allow: bool);
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextCheck(context: PgPtr<MemoryContextData>);
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextContains(
        context: PgPtr<MemoryContextData>,
        pointer: PgPtr<::std::os::raw::c_void>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn MemoryContextCreate(
        node: PgPtr<MemoryContextData>,
        tag: NodeTag,
        methods: PgPtr<MemoryContextMethods>,
        parent: PgPtr<MemoryContextData>,
        name: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn AllocSetContextCreateInternal(
        parent: PgPtr<MemoryContextData>,
        name: PgPtr<::std::os::raw::c_char>,
        minContextSize: Size,
        initBlockSize: Size,
        maxBlockSize: Size,
    ) -> PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub fn SlabContextCreate(
        parent: PgPtr<MemoryContextData>,
        name: PgPtr<::std::os::raw::c_char>,
        blockSize: Size,
        chunkSize: Size,
    ) -> PgPtr<MemoryContextData>;
}
#[pg_guard]
extern "C" {
    pub fn GenerationContextCreate(
        parent: PgPtr<MemoryContextData>,
        name: PgPtr<::std::os::raw::c_char>,
        blockSize: Size,
    ) -> PgPtr<MemoryContextData>;
}
pub type ExecutorStart_hook_type = ::std::option::Option<
    unsafe extern "C" fn(queryDesc: PgPtr<QueryDesc>, eflags: ::std::os::raw::c_int),
>;
#[pg_guard]
extern "C" {
    pub static mut ExecutorStart_hook: ExecutorStart_hook_type;
}
pub type ExecutorRun_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        queryDesc: PgPtr<QueryDesc>,
        direction: ScanDirection,
        count: uint64,
        execute_once: bool,
    ),
>;
#[pg_guard]
extern "C" {
    pub static mut ExecutorRun_hook: ExecutorRun_hook_type;
}
pub type ExecutorFinish_hook_type =
    ::std::option::Option<unsafe extern "C" fn(queryDesc: PgPtr<QueryDesc>)>;
#[pg_guard]
extern "C" {
    pub static mut ExecutorFinish_hook: ExecutorFinish_hook_type;
}
pub type ExecutorEnd_hook_type =
    ::std::option::Option<unsafe extern "C" fn(queryDesc: PgPtr<QueryDesc>)>;
#[pg_guard]
extern "C" {
    pub static mut ExecutorEnd_hook: ExecutorEnd_hook_type;
}
pub type ExecutorCheckPerms_hook_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: PgPtr<List>, arg2: bool) -> bool>;
#[pg_guard]
extern "C" {
    pub static mut ExecutorCheckPerms_hook: ExecutorCheckPerms_hook_type;
}
#[pg_guard]
extern "C" {
    pub fn ExecReScan(node: PgPtr<PlanState>);
}
#[pg_guard]
extern "C" {
    pub fn ExecMarkPos(node: PgPtr<PlanState>);
}
#[pg_guard]
extern "C" {
    pub fn ExecRestrPos(node: PgPtr<PlanState>);
}
#[pg_guard]
extern "C" {
    pub fn ExecSupportsMarkRestore(pathnode: PgPtr<Path>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecSupportsBackwardScan(node: PgPtr<Plan>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecMaterializesOutput(plantype: NodeTag) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn execCurrentOf(
        cexpr: PgPtr<CurrentOfExpr>,
        econtext: PgPtr<ExprContext>,
        table_oid: Oid,
        current_tid: PgPtr<ItemPointerData>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn execTuplesMatchPrepare(
        desc: PgPtr<TupleDescData>,
        numCols: ::std::os::raw::c_int,
        keyColIdx: PgPtr<AttrNumber>,
        eqOperators: PgPtr<Oid>,
        collations: PgPtr<Oid>,
        parent: PgPtr<PlanState>,
    ) -> PgPtr<ExprState>;
}
#[pg_guard]
extern "C" {
    pub fn execTuplesHashPrepare(
        numCols: ::std::os::raw::c_int,
        eqOperators: PgPtr<Oid>,
        eqFuncOids: PgPtr<PgPtr<Oid>>,
        hashFunctions: PgPtr<PgPtr<FmgrInfo>>,
    );
}
#[pg_guard]
extern "C" {
    pub fn BuildTupleHashTable(
        parent: PgPtr<PlanState>,
        inputDesc: PgPtr<TupleDescData>,
        numCols: ::std::os::raw::c_int,
        keyColIdx: PgPtr<AttrNumber>,
        eqfuncoids: PgPtr<Oid>,
        hashfunctions: PgPtr<FmgrInfo>,
        collations: PgPtr<Oid>,
        nbuckets: ::std::os::raw::c_long,
        additionalsize: Size,
        tablecxt: PgPtr<MemoryContextData>,
        tempcxt: PgPtr<MemoryContextData>,
        use_variable_hash_iv: bool,
    ) -> PgPtr<TupleHashTableData>;
}
#[pg_guard]
extern "C" {
    pub fn BuildTupleHashTableExt(
        parent: PgPtr<PlanState>,
        inputDesc: PgPtr<TupleDescData>,
        numCols: ::std::os::raw::c_int,
        keyColIdx: PgPtr<AttrNumber>,
        eqfuncoids: PgPtr<Oid>,
        hashfunctions: PgPtr<FmgrInfo>,
        collations: PgPtr<Oid>,
        nbuckets: ::std::os::raw::c_long,
        additionalsize: Size,
        metacxt: PgPtr<MemoryContextData>,
        tablecxt: PgPtr<MemoryContextData>,
        tempcxt: PgPtr<MemoryContextData>,
        use_variable_hash_iv: bool,
    ) -> PgPtr<TupleHashTableData>;
}
#[pg_guard]
extern "C" {
    pub fn LookupTupleHashEntry(
        hashtable: PgPtr<TupleHashTableData>,
        slot: PgPtr<TupleTableSlot>,
        isnew: PgPtr<bool>,
    ) -> PgPtr<TupleHashEntryData>;
}
#[pg_guard]
extern "C" {
    pub fn FindTupleHashEntry(
        hashtable: PgPtr<TupleHashTableData>,
        slot: PgPtr<TupleTableSlot>,
        eqcomp: PgPtr<ExprState>,
        hashfunctions: PgPtr<FmgrInfo>,
    ) -> PgPtr<TupleHashEntryData>;
}
#[pg_guard]
extern "C" {
    pub fn ResetTupleHashTable(hashtable: PgPtr<TupleHashTableData>);
}
#[pg_guard]
extern "C" {
    pub fn ExecInitJunkFilter(
        targetList: PgPtr<List>,
        slot: PgPtr<TupleTableSlot>,
    ) -> PgPtr<JunkFilter>;
}
#[pg_guard]
extern "C" {
    pub fn ExecInitJunkFilterConversion(
        targetList: PgPtr<List>,
        cleanTupType: PgPtr<TupleDescData>,
        slot: PgPtr<TupleTableSlot>,
    ) -> PgPtr<JunkFilter>;
}
#[pg_guard]
extern "C" {
    pub fn ExecFindJunkAttribute(
        junkfilter: PgPtr<JunkFilter>,
        attrName: PgPtr<::std::os::raw::c_char>,
    ) -> AttrNumber;
}
#[pg_guard]
extern "C" {
    pub fn ExecFindJunkAttributeInTlist(
        targetlist: PgPtr<List>,
        attrName: PgPtr<::std::os::raw::c_char>,
    ) -> AttrNumber;
}
#[pg_guard]
extern "C" {
    pub fn ExecGetJunkAttribute(
        slot: PgPtr<TupleTableSlot>,
        attno: AttrNumber,
        isNull: PgPtr<bool>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ExecFilterJunk(
        junkfilter: PgPtr<JunkFilter>,
        slot: PgPtr<TupleTableSlot>,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecutorStart(queryDesc: PgPtr<QueryDesc>, eflags: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn standard_ExecutorStart(queryDesc: PgPtr<QueryDesc>, eflags: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn ExecutorRun(
        queryDesc: PgPtr<QueryDesc>,
        direction: ScanDirection,
        count: uint64,
        execute_once: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn standard_ExecutorRun(
        queryDesc: PgPtr<QueryDesc>,
        direction: ScanDirection,
        count: uint64,
        execute_once: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecutorFinish(queryDesc: PgPtr<QueryDesc>);
}
#[pg_guard]
extern "C" {
    pub fn standard_ExecutorFinish(queryDesc: PgPtr<QueryDesc>);
}
#[pg_guard]
extern "C" {
    pub fn ExecutorEnd(queryDesc: PgPtr<QueryDesc>);
}
#[pg_guard]
extern "C" {
    pub fn standard_ExecutorEnd(queryDesc: PgPtr<QueryDesc>);
}
#[pg_guard]
extern "C" {
    pub fn ExecutorRewind(queryDesc: PgPtr<QueryDesc>);
}
#[pg_guard]
extern "C" {
    pub fn ExecCheckRTPerms(rangeTable: PgPtr<List>, ereport_on_violation: bool) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn CheckValidResultRel(resultRelInfo: PgPtr<ResultRelInfo>, operation: CmdType);
}
#[pg_guard]
extern "C" {
    pub fn InitResultRelInfo(
        resultRelInfo: PgPtr<ResultRelInfo>,
        resultRelationDesc: PgPtr<RelationData>,
        resultRelationIndex: Index,
        partition_root: PgPtr<RelationData>,
        instrument_options: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecGetTriggerResultRel(estate: PgPtr<EState>, relid: Oid) -> PgPtr<ResultRelInfo>;
}
#[pg_guard]
extern "C" {
    pub fn ExecCleanUpTriggerState(estate: PgPtr<EState>);
}
#[pg_guard]
extern "C" {
    pub fn ExecConstraints(
        resultRelInfo: PgPtr<ResultRelInfo>,
        slot: PgPtr<TupleTableSlot>,
        estate: PgPtr<EState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecPartitionCheck(
        resultRelInfo: PgPtr<ResultRelInfo>,
        slot: PgPtr<TupleTableSlot>,
        estate: PgPtr<EState>,
        emitError: bool,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecPartitionCheckEmitError(
        resultRelInfo: PgPtr<ResultRelInfo>,
        slot: PgPtr<TupleTableSlot>,
        estate: PgPtr<EState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecWithCheckOptions(
        kind: WCOKind,
        resultRelInfo: PgPtr<ResultRelInfo>,
        slot: PgPtr<TupleTableSlot>,
        estate: PgPtr<EState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecUpdateLockMode(
        estate: PgPtr<EState>,
        relinfo: PgPtr<ResultRelInfo>,
    ) -> LockTupleMode;
}
#[pg_guard]
extern "C" {
    pub fn ExecFindRowMark(
        estate: PgPtr<EState>,
        rti: Index,
        missing_ok: bool,
    ) -> PgPtr<ExecRowMark>;
}
#[pg_guard]
extern "C" {
    pub fn ExecBuildAuxRowMark(
        erm: PgPtr<ExecRowMark>,
        targetlist: PgPtr<List>,
    ) -> PgPtr<ExecAuxRowMark>;
}
#[pg_guard]
extern "C" {
    pub fn EvalPlanQual(
        epqstate: PgPtr<EPQState>,
        relation: PgPtr<RelationData>,
        rti: Index,
        testslot: PgPtr<TupleTableSlot>,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn EvalPlanQualInit(
        epqstate: PgPtr<EPQState>,
        parentestate: PgPtr<EState>,
        subplan: PgPtr<Plan>,
        auxrowmarks: PgPtr<List>,
        epqParam: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn EvalPlanQualSetPlan(
        epqstate: PgPtr<EPQState>,
        subplan: PgPtr<Plan>,
        auxrowmarks: PgPtr<List>,
    );
}
#[pg_guard]
extern "C" {
    pub fn EvalPlanQualSlot(
        epqstate: PgPtr<EPQState>,
        relation: PgPtr<RelationData>,
        rti: Index,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn EvalPlanQualFetchRowMark(
        epqstate: PgPtr<EPQState>,
        rti: Index,
        slot: PgPtr<TupleTableSlot>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn EvalPlanQualNext(epqstate: PgPtr<EPQState>) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn EvalPlanQualBegin(epqstate: PgPtr<EPQState>);
}
#[pg_guard]
extern "C" {
    pub fn EvalPlanQualEnd(epqstate: PgPtr<EPQState>);
}
#[pg_guard]
extern "C" {
    pub fn ExecInitNode(
        node: PgPtr<Plan>,
        estate: PgPtr<EState>,
        eflags: ::std::os::raw::c_int,
    ) -> PgPtr<PlanState>;
}
#[pg_guard]
extern "C" {
    pub fn ExecSetExecProcNode(node: PgPtr<PlanState>, function: ExecProcNodeMtd);
}
#[pg_guard]
extern "C" {
    pub fn MultiExecProcNode(node: PgPtr<PlanState>) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn ExecEndNode(node: PgPtr<PlanState>);
}
#[pg_guard]
extern "C" {
    pub fn ExecShutdownNode(node: PgPtr<PlanState>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecSetTupleBound(tuples_needed: int64, child_node: PgPtr<PlanState>);
}
#[pg_guard]
extern "C" {
    pub fn ExecInitExpr(node: PgPtr<Expr>, parent: PgPtr<PlanState>) -> PgPtr<ExprState>;
}
#[pg_guard]
extern "C" {
    pub fn ExecInitExprWithParams(
        node: PgPtr<Expr>,
        ext_params: PgPtr<ParamListInfoData>,
    ) -> PgPtr<ExprState>;
}
#[pg_guard]
extern "C" {
    pub fn ExecInitQual(qual: PgPtr<List>, parent: PgPtr<PlanState>) -> PgPtr<ExprState>;
}
#[pg_guard]
extern "C" {
    pub fn ExecInitCheck(qual: PgPtr<List>, parent: PgPtr<PlanState>) -> PgPtr<ExprState>;
}
#[pg_guard]
extern "C" {
    pub fn ExecInitExprList(nodes: PgPtr<List>, parent: PgPtr<PlanState>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn ExecBuildAggTrans(
        aggstate: PgPtr<AggState>,
        phase: PgPtr<AggStatePerPhaseData>,
        doSort: bool,
        doHash: bool,
    ) -> PgPtr<ExprState>;
}
#[pg_guard]
extern "C" {
    pub fn ExecBuildGroupingEqual(
        ldesc: PgPtr<TupleDescData>,
        rdesc: PgPtr<TupleDescData>,
        lops: PgPtr<TupleTableSlotOps>,
        rops: PgPtr<TupleTableSlotOps>,
        numCols: ::std::os::raw::c_int,
        keyColIdx: PgPtr<AttrNumber>,
        eqfunctions: PgPtr<Oid>,
        collations: PgPtr<Oid>,
        parent: PgPtr<PlanState>,
    ) -> PgPtr<ExprState>;
}
#[pg_guard]
extern "C" {
    pub fn ExecBuildProjectionInfo(
        targetList: PgPtr<List>,
        econtext: PgPtr<ExprContext>,
        slot: PgPtr<TupleTableSlot>,
        parent: PgPtr<PlanState>,
        inputDesc: PgPtr<TupleDescData>,
    ) -> PgPtr<ProjectionInfo>;
}
#[pg_guard]
extern "C" {
    pub fn ExecPrepareExpr(node: PgPtr<Expr>, estate: PgPtr<EState>) -> PgPtr<ExprState>;
}
#[pg_guard]
extern "C" {
    pub fn ExecPrepareQual(qual: PgPtr<List>, estate: PgPtr<EState>) -> PgPtr<ExprState>;
}
#[pg_guard]
extern "C" {
    pub fn ExecPrepareCheck(qual: PgPtr<List>, estate: PgPtr<EState>) -> PgPtr<ExprState>;
}
#[pg_guard]
extern "C" {
    pub fn ExecPrepareExprList(nodes: PgPtr<List>, estate: PgPtr<EState>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn ExecCheck(state: PgPtr<ExprState>, context: PgPtr<ExprContext>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecInitTableFunctionResult(
        expr: PgPtr<Expr>,
        econtext: PgPtr<ExprContext>,
        parent: PgPtr<PlanState>,
    ) -> PgPtr<SetExprState>;
}
#[pg_guard]
extern "C" {
    pub fn ExecMakeTableFunctionResult(
        setexpr: PgPtr<SetExprState>,
        econtext: PgPtr<ExprContext>,
        argContext: PgPtr<MemoryContextData>,
        expectedDesc: PgPtr<TupleDescData>,
        randomAccess: bool,
    ) -> PgPtr<Tuplestorestate>;
}
#[pg_guard]
extern "C" {
    pub fn ExecInitFunctionResultSet(
        expr: PgPtr<Expr>,
        econtext: PgPtr<ExprContext>,
        parent: PgPtr<PlanState>,
    ) -> PgPtr<SetExprState>;
}
#[pg_guard]
extern "C" {
    pub fn ExecMakeFunctionResultSet(
        fcache: PgPtr<SetExprState>,
        econtext: PgPtr<ExprContext>,
        argContext: PgPtr<MemoryContextData>,
        isNull: PgPtr<bool>,
        isDone: PgPtr<ExprDoneCond>,
    ) -> Datum;
}
pub type ExecScanAccessMtd =
    ::std::option::Option<unsafe extern "C" fn(node: PgPtr<ScanState>) -> PgPtr<TupleTableSlot>>;
pub type ExecScanRecheckMtd = ::std::option::Option<
    unsafe extern "C" fn(node: PgPtr<ScanState>, slot: PgPtr<TupleTableSlot>) -> bool,
>;
#[pg_guard]
extern "C" {
    pub fn ExecScan(
        node: PgPtr<ScanState>,
        accessMtd: ExecScanAccessMtd,
        recheckMtd: ExecScanRecheckMtd,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecAssignScanProjectionInfo(node: PgPtr<ScanState>);
}
#[pg_guard]
extern "C" {
    pub fn ExecAssignScanProjectionInfoWithVarno(node: PgPtr<ScanState>, varno: Index);
}
#[pg_guard]
extern "C" {
    pub fn ExecScanReScan(node: PgPtr<ScanState>);
}
#[pg_guard]
extern "C" {
    pub fn ExecInitResultTypeTL(planstate: PgPtr<PlanState>);
}
#[pg_guard]
extern "C" {
    pub fn ExecInitResultSlot(planstate: PgPtr<PlanState>, tts_ops: PgPtr<TupleTableSlotOps>);
}
#[pg_guard]
extern "C" {
    pub fn ExecInitResultTupleSlotTL(
        planstate: PgPtr<PlanState>,
        tts_ops: PgPtr<TupleTableSlotOps>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecInitScanTupleSlot(
        estate: PgPtr<EState>,
        scanstate: PgPtr<ScanState>,
        tupleDesc: PgPtr<TupleDescData>,
        tts_ops: PgPtr<TupleTableSlotOps>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecInitExtraTupleSlot(
        estate: PgPtr<EState>,
        tupledesc: PgPtr<TupleDescData>,
        tts_ops: PgPtr<TupleTableSlotOps>,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecInitNullTupleSlot(
        estate: PgPtr<EState>,
        tupType: PgPtr<TupleDescData>,
        tts_ops: PgPtr<TupleTableSlotOps>,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecTypeFromTL(targetList: PgPtr<List>) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn ExecCleanTypeFromTL(targetList: PgPtr<List>) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn ExecTypeFromExprList(exprList: PgPtr<List>) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn ExecTypeSetColNames(typeInfo: PgPtr<TupleDescData>, namesList: PgPtr<List>);
}
#[pg_guard]
extern "C" {
    pub fn UpdateChangedParamSet(node: PgPtr<PlanState>, newchg: PgPtr<Bitmapset>);
}
#[repr(C)]
pub struct TupOutputState {
    pub slot: PgPtr<TupleTableSlot>,
    pub dest: PgPtr<DestReceiver>,
}
#[pg_guard]
extern "C" {
    pub fn begin_tup_output_tupdesc(
        dest: PgPtr<DestReceiver>,
        tupdesc: PgPtr<TupleDescData>,
        tts_ops: PgPtr<TupleTableSlotOps>,
    ) -> PgPtr<TupOutputState>;
}
#[pg_guard]
extern "C" {
    pub fn do_tup_output(tstate: PgPtr<TupOutputState>, values: PgPtr<Datum>, isnull: PgPtr<bool>);
}
#[pg_guard]
extern "C" {
    pub fn do_text_output_multiline(
        tstate: PgPtr<TupOutputState>,
        txt: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn end_tup_output(tstate: PgPtr<TupOutputState>);
}
#[pg_guard]
extern "C" {
    pub fn CreateExecutorState() -> PgPtr<EState>;
}
#[pg_guard]
extern "C" {
    pub fn FreeExecutorState(estate: PgPtr<EState>);
}
#[pg_guard]
extern "C" {
    pub fn CreateExprContext(estate: PgPtr<EState>) -> PgPtr<ExprContext>;
}
#[pg_guard]
extern "C" {
    pub fn CreateStandaloneExprContext() -> PgPtr<ExprContext>;
}
#[pg_guard]
extern "C" {
    pub fn FreeExprContext(econtext: PgPtr<ExprContext>, isCommit: bool);
}
#[pg_guard]
extern "C" {
    pub fn ReScanExprContext(econtext: PgPtr<ExprContext>);
}
#[pg_guard]
extern "C" {
    pub fn MakePerTupleExprContext(estate: PgPtr<EState>) -> PgPtr<ExprContext>;
}
#[pg_guard]
extern "C" {
    pub fn ExecAssignExprContext(estate: PgPtr<EState>, planstate: PgPtr<PlanState>);
}
#[pg_guard]
extern "C" {
    pub fn ExecGetResultType(planstate: PgPtr<PlanState>) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn ExecGetResultSlotOps(
        planstate: PgPtr<PlanState>,
        isfixed: PgPtr<bool>,
    ) -> PgPtr<TupleTableSlotOps>;
}
#[pg_guard]
extern "C" {
    pub fn ExecAssignProjectionInfo(planstate: PgPtr<PlanState>, inputDesc: PgPtr<TupleDescData>);
}
#[pg_guard]
extern "C" {
    pub fn ExecConditionalAssignProjectionInfo(
        planstate: PgPtr<PlanState>,
        inputDesc: PgPtr<TupleDescData>,
        varno: Index,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecFreeExprContext(planstate: PgPtr<PlanState>);
}
#[pg_guard]
extern "C" {
    pub fn ExecAssignScanType(scanstate: PgPtr<ScanState>, tupDesc: PgPtr<TupleDescData>);
}
#[pg_guard]
extern "C" {
    pub fn ExecCreateScanSlotFromOuterPlan(
        estate: PgPtr<EState>,
        scanstate: PgPtr<ScanState>,
        tts_ops: PgPtr<TupleTableSlotOps>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecRelationIsTargetRelation(estate: PgPtr<EState>, scanrelid: Index) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecOpenScanRelation(
        estate: PgPtr<EState>,
        scanrelid: Index,
        eflags: ::std::os::raw::c_int,
    ) -> PgPtr<RelationData>;
}
#[pg_guard]
extern "C" {
    pub fn ExecInitRangeTable(estate: PgPtr<EState>, rangeTable: PgPtr<List>);
}
#[pg_guard]
extern "C" {
    pub fn ExecGetRangeTableRelation(estate: PgPtr<EState>, rti: Index) -> PgPtr<RelationData>;
}
#[pg_guard]
extern "C" {
    pub fn executor_errposition(
        estate: PgPtr<EState>,
        location: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn RegisterExprContextCallback(
        econtext: PgPtr<ExprContext>,
        function: ExprContextCallbackFunction,
        arg: Datum,
    );
}
#[pg_guard]
extern "C" {
    pub fn UnregisterExprContextCallback(
        econtext: PgPtr<ExprContext>,
        function: ExprContextCallbackFunction,
        arg: Datum,
    );
}
#[pg_guard]
extern "C" {
    pub fn GetAttributeByName(
        tuple: PgPtr<HeapTupleHeaderData>,
        attname: PgPtr<::std::os::raw::c_char>,
        isNull: PgPtr<bool>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn GetAttributeByNum(
        tuple: PgPtr<HeapTupleHeaderData>,
        attrno: AttrNumber,
        isNull: PgPtr<bool>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ExecTargetListLength(targetlist: PgPtr<List>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ExecCleanTargetListLength(targetlist: PgPtr<List>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ExecGetTriggerOldSlot(
        estate: PgPtr<EState>,
        relInfo: PgPtr<ResultRelInfo>,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecGetTriggerNewSlot(
        estate: PgPtr<EState>,
        relInfo: PgPtr<ResultRelInfo>,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecGetReturningSlot(
        estate: PgPtr<EState>,
        relInfo: PgPtr<ResultRelInfo>,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn ExecOpenIndices(resultRelInfo: PgPtr<ResultRelInfo>, speculative: bool);
}
#[pg_guard]
extern "C" {
    pub fn ExecCloseIndices(resultRelInfo: PgPtr<ResultRelInfo>);
}
#[pg_guard]
extern "C" {
    pub fn ExecInsertIndexTuples(
        slot: PgPtr<TupleTableSlot>,
        estate: PgPtr<EState>,
        noDupErr: bool,
        specConflict: PgPtr<bool>,
        arbiterIndexes: PgPtr<List>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn ExecCheckIndexConstraints(
        slot: PgPtr<TupleTableSlot>,
        estate: PgPtr<EState>,
        conflictTid: PgPtr<ItemPointerData>,
        arbiterIndexes: PgPtr<List>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn check_exclusion_constraint(
        heap: PgPtr<RelationData>,
        index: PgPtr<RelationData>,
        indexInfo: PgPtr<IndexInfo>,
        tupleid: PgPtr<ItemPointerData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
        estate: PgPtr<EState>,
        newIndex: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn RelationFindReplTupleByIndex(
        rel: PgPtr<RelationData>,
        idxoid: Oid,
        lockmode: LockTupleMode,
        searchslot: PgPtr<TupleTableSlot>,
        outslot: PgPtr<TupleTableSlot>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn RelationFindReplTupleSeq(
        rel: PgPtr<RelationData>,
        lockmode: LockTupleMode,
        searchslot: PgPtr<TupleTableSlot>,
        outslot: PgPtr<TupleTableSlot>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecSimpleRelationInsert(estate: PgPtr<EState>, slot: PgPtr<TupleTableSlot>);
}
#[pg_guard]
extern "C" {
    pub fn ExecSimpleRelationUpdate(
        estate: PgPtr<EState>,
        epqstate: PgPtr<EPQState>,
        searchslot: PgPtr<TupleTableSlot>,
        slot: PgPtr<TupleTableSlot>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecSimpleRelationDelete(
        estate: PgPtr<EState>,
        epqstate: PgPtr<EPQState>,
        searchslot: PgPtr<TupleTableSlot>,
    );
}
#[pg_guard]
extern "C" {
    pub fn CheckCmdReplicaIdentity(rel: PgPtr<RelationData>, cmd: CmdType);
}
#[pg_guard]
extern "C" {
    pub fn CheckSubscriptionRelkind(
        relkind: ::std::os::raw::c_char,
        nspname: PgPtr<::std::os::raw::c_char>,
        relname: PgPtr<::std::os::raw::c_char>,
    );
}
#[repr(C)]
pub struct AttInMetadata {
    pub tupdesc: PgPtr<TupleDescData>,
    pub attinfuncs: PgPtr<FmgrInfo>,
    pub attioparams: PgPtr<Oid>,
    pub atttypmods: PgPtr<int32>,
}
#[repr(C)]
pub struct FuncCallContext {
    pub call_cntr: uint64,
    pub max_calls: uint64,
    pub user_fctx: PgPtr<::std::os::raw::c_void>,
    pub attinmeta: PgPtr<AttInMetadata>,
    pub multi_call_memory_ctx: PgPtr<MemoryContextData>,
    pub tuple_desc: PgPtr<TupleDescData>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum TypeFuncClass {
    TYPEFUNC_SCALAR = 0,
    TYPEFUNC_COMPOSITE = 1,
    TYPEFUNC_COMPOSITE_DOMAIN = 2,
    TYPEFUNC_RECORD = 3,
    TYPEFUNC_OTHER = 4,
}
#[pg_guard]
extern "C" {
    pub fn get_call_result_type(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
        resultTypeId: PgPtr<Oid>,
        resultTupleDesc: PgPtr<PgPtr<TupleDescData>>,
    ) -> TypeFuncClass;
}
#[pg_guard]
extern "C" {
    pub fn get_expr_result_type(
        expr: PgPtr<Node>,
        resultTypeId: PgPtr<Oid>,
        resultTupleDesc: PgPtr<PgPtr<TupleDescData>>,
    ) -> TypeFuncClass;
}
#[pg_guard]
extern "C" {
    pub fn get_func_result_type(
        functionId: Oid,
        resultTypeId: PgPtr<Oid>,
        resultTupleDesc: PgPtr<PgPtr<TupleDescData>>,
    ) -> TypeFuncClass;
}
#[pg_guard]
extern "C" {
    pub fn get_expr_result_tupdesc(expr: PgPtr<Node>, noError: bool) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn resolve_polymorphic_argtypes(
        numargs: ::std::os::raw::c_int,
        argtypes: PgPtr<Oid>,
        argmodes: PgPtr<::std::os::raw::c_char>,
        call_expr: PgPtr<Node>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_func_arg_info(
        procTup: PgPtr<HeapTupleData>,
        p_argtypes: PgPtr<PgPtr<Oid>>,
        p_argnames: PgPtr<PgPtr<PgPtr<::std::os::raw::c_char>>>,
        p_argmodes: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn get_func_input_arg_names(
        proargnames: Datum,
        proargmodes: Datum,
        arg_names: PgPtr<PgPtr<PgPtr<::std::os::raw::c_char>>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn get_func_trftypes(
        procTup: PgPtr<HeapTupleData>,
        p_trftypes: PgPtr<PgPtr<Oid>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn get_func_result_name(functionId: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn build_function_result_tupdesc_d(
        prokind: ::std::os::raw::c_char,
        proallargtypes: Datum,
        proargmodes: Datum,
        proargnames: Datum,
    ) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn build_function_result_tupdesc_t(procTuple: PgPtr<HeapTupleData>)
        -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn RelationNameGetTupleDesc(relname: PgPtr<::std::os::raw::c_char>)
        -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn TypeGetTupleDesc(typeoid: Oid, colaliases: PgPtr<List>) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn BlessTupleDesc(tupdesc: PgPtr<TupleDescData>) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn TupleDescGetAttInMetadata(tupdesc: PgPtr<TupleDescData>) -> PgPtr<AttInMetadata>;
}
#[pg_guard]
extern "C" {
    pub fn BuildTupleFromCStrings(
        attinmeta: PgPtr<AttInMetadata>,
        values: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn HeapTupleHeaderGetDatum(tuple: PgPtr<HeapTupleHeaderData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn init_MultiFuncCall(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> PgPtr<FuncCallContext>;
}
#[pg_guard]
extern "C" {
    pub fn per_MultiFuncCall(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> PgPtr<FuncCallContext>;
}
#[pg_guard]
extern "C" {
    pub fn end_MultiFuncCall(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
        funcctx: PgPtr<FuncCallContext>,
    );
}
#[pg_guard]
extern "C" {
    pub fn extract_variadic_args(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
        variadic_start: ::std::os::raw::c_int,
        convert_unknown: bool,
        values: PgPtr<PgPtr<Datum>>,
        types: PgPtr<PgPtr<Oid>>,
        nulls: PgPtr<PgPtr<bool>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static sys_signame: [*const ::std::os::raw::c_char; 32usize];
}
#[pg_guard]
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 32usize];
}
#[pg_guard]
extern "C" {
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn bsd_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
#[pg_guard]
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<sigset_t>,
        arg3: PgPtr<sigset_t>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<sigaction>,
        arg3: PgPtr<sigaction>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigaddset(arg1: PgPtr<sigset_t>, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigaltstack(arg1: PgPtr<stack_t>, arg2: PgPtr<stack_t>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigdelset(arg1: PgPtr<sigset_t>, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigemptyset(arg1: PgPtr<sigset_t>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigfillset(arg1: PgPtr<sigset_t>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sighold(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigignore(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn siginterrupt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigismember(arg1: PgPtr<sigset_t>, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigpending(arg1: PgPtr<sigset_t>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<sigset_t>,
        arg3: PgPtr<sigset_t>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigrelse(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigset(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
#[pg_guard]
extern "C" {
    pub fn sigsuspend(arg1: PgPtr<sigset_t>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigwait(
        arg1: PgPtr<sigset_t>,
        arg2: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn psignal(arg1: ::std::os::raw::c_uint, arg2: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn sigblock(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigsetmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn sigvec(
        arg1: ::std::os::raw::c_int,
        arg2: PgPtr<sigvec>,
        arg3: PgPtr<sigvec>,
    ) -> ::std::os::raw::c_int;
}
pub type pg_time_t = int64;
#[repr(C)]
pub struct pg_tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct pg_tz {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct pg_tzenum {
    _unused: [u8; 0],
}
#[pg_guard]
extern "C" {
    pub fn pg_localtime(timep: PgPtr<pg_time_t>, tz: PgPtr<pg_tz>) -> PgPtr<pg_tm>;
}
#[pg_guard]
extern "C" {
    pub fn pg_gmtime(timep: PgPtr<pg_time_t>) -> PgPtr<pg_tm>;
}
#[pg_guard]
extern "C" {
    pub fn pg_next_dst_boundary(
        timep: PgPtr<pg_time_t>,
        before_gmtoff: PgPtr<::std::os::raw::c_long>,
        before_isdst: PgPtr<::std::os::raw::c_int>,
        boundary: PgPtr<pg_time_t>,
        after_gmtoff: PgPtr<::std::os::raw::c_long>,
        after_isdst: PgPtr<::std::os::raw::c_int>,
        tz: PgPtr<pg_tz>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_interpret_timezone_abbrev(
        abbrev: PgPtr<::std::os::raw::c_char>,
        timep: PgPtr<pg_time_t>,
        gmtoff: PgPtr<::std::os::raw::c_long>,
        isdst: PgPtr<::std::os::raw::c_int>,
        tz: PgPtr<pg_tz>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_timezone_offset(tz: PgPtr<pg_tz>, gmtoff: PgPtr<::std::os::raw::c_long>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_timezone_name(tz: PgPtr<pg_tz>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pg_tz_acceptable(tz: PgPtr<pg_tz>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_strftime(
        s: PgPtr<::std::os::raw::c_char>,
        max: usize,
        format: PgPtr<::std::os::raw::c_char>,
        tm: PgPtr<pg_tm>,
    ) -> usize;
}
#[pg_guard]
extern "C" {
    pub static mut session_timezone: PgPtr<pg_tz>;
}
#[pg_guard]
extern "C" {
    pub static mut log_timezone: PgPtr<pg_tz>;
}
#[pg_guard]
extern "C" {
    pub fn pg_timezone_initialize();
}
#[pg_guard]
extern "C" {
    pub fn pg_tzset(tzname: PgPtr<::std::os::raw::c_char>) -> PgPtr<pg_tz>;
}
#[pg_guard]
extern "C" {
    pub fn pg_tzset_offset(gmtoffset: ::std::os::raw::c_long) -> PgPtr<pg_tz>;
}
#[pg_guard]
extern "C" {
    pub fn pg_tzenumerate_start() -> PgPtr<pg_tzenum>;
}
#[pg_guard]
extern "C" {
    pub fn pg_tzenumerate_next(dir: PgPtr<pg_tzenum>) -> PgPtr<pg_tz>;
}
#[pg_guard]
extern "C" {
    pub fn pg_tzenumerate_end(dir: PgPtr<pg_tzenum>);
}
#[pg_guard]
extern "C" {
    pub static mut InterruptPending: sig_atomic_t;
}
#[pg_guard]
extern "C" {
    pub static mut QueryCancelPending: sig_atomic_t;
}
#[pg_guard]
extern "C" {
    pub static mut ProcDiePending: sig_atomic_t;
}
#[pg_guard]
extern "C" {
    pub static mut IdleInTransactionSessionTimeoutPending: sig_atomic_t;
}
#[pg_guard]
extern "C" {
    pub static mut ConfigReloadPending: sig_atomic_t;
}
#[pg_guard]
extern "C" {
    pub static mut ClientConnectionLost: sig_atomic_t;
}
#[pg_guard]
extern "C" {
    pub static mut InterruptHoldoffCount: uint32;
}
#[pg_guard]
extern "C" {
    pub static mut QueryCancelHoldoffCount: uint32;
}
#[pg_guard]
extern "C" {
    pub static mut CritSectionCount: uint32;
}
#[pg_guard]
extern "C" {
    pub fn ProcessInterrupts();
}
#[pg_guard]
extern "C" {
    pub static mut PostmasterPid: pid_t;
}
#[pg_guard]
extern "C" {
    pub static mut IsPostmasterEnvironment: bool;
}
#[pg_guard]
extern "C" {
    pub static mut IsUnderPostmaster: bool;
}
#[pg_guard]
extern "C" {
    pub static mut IsBackgroundWorker: bool;
}
#[pg_guard]
extern "C" {
    pub static mut IsBinaryUpgrade: bool;
}
#[pg_guard]
extern "C" {
    pub static mut ExitOnAnyError: bool;
}
#[pg_guard]
extern "C" {
    pub static mut DataDir: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut data_directory_mode: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut NBuffers: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut MaxBackends: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut MaxConnections: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut max_worker_processes: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut max_parallel_workers: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut MyProcPid: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut MyStartTime: pg_time_t;
}
#[pg_guard]
extern "C" {
    pub static mut MyStartTimestamp: TimestampTz;
}
#[repr(C)]
pub struct Port {
    _unused: [u8; 0],
}
#[pg_guard]
extern "C" {
    pub static mut MyProcPort: PgPtr<Port>;
}
#[pg_guard]
extern "C" {
    pub static mut MyLatch: PgPtr<Latch>;
}
#[pg_guard]
extern "C" {
    pub static mut MyCancelKey: int32;
}
#[pg_guard]
extern "C" {
    pub static mut MyPMChildSlot: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut OutputFileName: [::std::os::raw::c_char; 0usize];
}
#[pg_guard]
extern "C" {
    pub static mut my_exec_path: [::std::os::raw::c_char; 0usize];
}
#[pg_guard]
extern "C" {
    pub static mut pkglib_path: [::std::os::raw::c_char; 0usize];
}
#[pg_guard]
extern "C" {
    pub static mut MyDatabaseId: Oid;
}
#[pg_guard]
extern "C" {
    pub static mut MyDatabaseTableSpace: Oid;
}
#[pg_guard]
extern "C" {
    pub static mut DateStyle: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut DateOrder: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut IntervalStyle: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut enableFsync: bool;
}
#[pg_guard]
extern "C" {
    pub static mut allowSystemTableMods: bool;
}
#[pg_guard]
extern "C" {
    pub static mut work_mem: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut maintenance_work_mem: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut max_parallel_maintenance_workers: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut VacuumCostPageHit: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut VacuumCostPageMiss: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut VacuumCostPageDirty: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut VacuumCostLimit: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut VacuumCostDelay: f64;
}
#[pg_guard]
extern "C" {
    pub static mut VacuumPageHit: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut VacuumPageMiss: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut VacuumPageDirty: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut VacuumCostBalance: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut VacuumCostActive: bool;
}
#[pg_guard]
extern "C" {
    pub static mut vacuum_cleanup_index_scale_factor: f64;
}
pub type pg_stack_base_t = PgPtr<::std::os::raw::c_char>;
#[pg_guard]
extern "C" {
    pub fn set_stack_base() -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn restore_stack_base(base: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn check_stack_depth();
}
#[pg_guard]
extern "C" {
    pub fn stack_is_too_deep() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn PostgresSigHupHandler(postgres_signal_arg: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn PreventCommandIfReadOnly(cmdname: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn PreventCommandIfParallelMode(cmdname: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn PreventCommandDuringRecovery(cmdname: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub static mut trace_recovery_messages: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn trace_recovery(trace_level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut DatabasePath: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn InitPostmasterChild();
}
#[pg_guard]
extern "C" {
    pub fn InitStandaloneProcess(argv0: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn SetDatabasePath(path: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn GetUserNameFromId(roleid: Oid, noerr: bool) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn GetUserId() -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn GetOuterUserId() -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn GetSessionUserId() -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn GetAuthenticatedUserId() -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn GetUserIdAndSecContext(userid: PgPtr<Oid>, sec_context: PgPtr<::std::os::raw::c_int>);
}
#[pg_guard]
extern "C" {
    pub fn SetUserIdAndSecContext(userid: Oid, sec_context: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn InLocalUserIdChange() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn InSecurityRestrictedOperation() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn InNoForceRLSOperation() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetUserIdAndContext(userid: PgPtr<Oid>, sec_def_context: PgPtr<bool>);
}
#[pg_guard]
extern "C" {
    pub fn SetUserIdAndContext(userid: Oid, sec_def_context: bool);
}
#[pg_guard]
extern "C" {
    pub fn InitializeSessionUserId(rolename: PgPtr<::std::os::raw::c_char>, useroid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn InitializeSessionUserIdStandalone();
}
#[pg_guard]
extern "C" {
    pub fn SetSessionAuthorization(userid: Oid, is_superuser: bool);
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentRoleId() -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn SetCurrentRoleId(roleid: Oid, is_superuser: bool);
}
#[pg_guard]
extern "C" {
    pub fn checkDataDir();
}
#[pg_guard]
extern "C" {
    pub fn SetDataDir(dir: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn ChangeToDataDir();
}
#[pg_guard]
extern "C" {
    pub fn SwitchToSharedLatch();
}
#[pg_guard]
extern "C" {
    pub fn SwitchBackToLocalLatch();
}
#[pg_guard]
extern "C" {
    pub fn superuser() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn superuser_arg(roleid: Oid) -> bool;
}
#[repr(u32)]
#[doc = "\t  pmod.h --\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *"]
#[doc = "\t\t\tPOSTGRES processing mode definitions.                            *"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ProcessingMode {
    BootstrapProcessing = 0,
    InitProcessing = 1,
    NormalProcessing = 2,
}
#[pg_guard]
extern "C" {
    pub static mut Mode: ProcessingMode;
}
#[repr(i32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum AuxProcType {
    NotAnAuxProcess = -1,
    CheckerProcess = 0,
    BootstrapProcess = 1,
    StartupProcess = 2,
    BgWriterProcess = 3,
    CheckpointerProcess = 4,
    WalWriterProcess = 5,
    WalReceiverProcess = 6,
    NUM_AUXPROCTYPES = 7,
}
#[pg_guard]
extern "C" {
    pub static mut MyAuxProcType: AuxProcType;
}
#[pg_guard]
extern "C" {
    #[doc = "\t  pinit.h --\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *"]
    #[doc = "\t\t\tPOSTGRES initialization and cleanup definitions.                 *"]
    pub fn pg_split_opts(
        argv: PgPtr<PgPtr<::std::os::raw::c_char>>,
        argcp: PgPtr<::std::os::raw::c_int>,
        optstr: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn InitializeMaxBackends();
}
#[pg_guard]
extern "C" {
    pub fn InitPostgres(
        in_dbname: PgPtr<::std::os::raw::c_char>,
        dboid: Oid,
        username: PgPtr<::std::os::raw::c_char>,
        useroid: Oid,
        out_dbname: PgPtr<::std::os::raw::c_char>,
        override_allow_connections: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn BaseInit();
}
#[pg_guard]
extern "C" {
    pub static mut IgnoreSystemIndexes: bool;
}
#[pg_guard]
extern "C" {
    pub static mut process_shared_preload_libraries_in_progress: bool;
}
#[pg_guard]
extern "C" {
    pub static mut session_preload_libraries_string: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut shared_preload_libraries_string: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut local_preload_libraries_string: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn CreateDataDirLockFile(amPostmaster: bool);
}
#[pg_guard]
extern "C" {
    pub fn CreateSocketLockFile(
        socketfile: PgPtr<::std::os::raw::c_char>,
        amPostmaster: bool,
        socketDir: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn TouchSocketLockFiles();
}
#[pg_guard]
extern "C" {
    pub fn AddToDataDirLockFile(
        target_line: ::std::os::raw::c_int,
        str_: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn RecheckDataDirLockFile() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ValidatePgVersion(path: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn process_shared_preload_libraries();
}
#[pg_guard]
extern "C" {
    pub fn process_session_preload_libraries();
}
#[pg_guard]
extern "C" {
    pub fn pg_bindtextdomain(domain: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn has_rolreplication(roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn BackupInProgress() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn CancelBackup();
}
#[repr(C)]
pub struct sockaddr_un {
    pub sun_len: ::std::os::raw::c_uchar,
    pub sun_family: sa_family_t,
    pub sun_path: [::std::os::raw::c_char; 104usize],
}
#[repr(C)]
pub struct SockAddr {
    pub addr: sockaddr_storage,
    pub salen: socklen_t,
}
pub type ProtocolVersion = uint32;
pub type MsgType = ProtocolVersion;
pub type PacketLen = uint32;
#[repr(C)]
pub struct StartupPacket {
    pub protoVersion: ProtocolVersion,
    pub database: [::std::os::raw::c_char; 64usize],
    pub user: [::std::os::raw::c_char; 32usize],
    pub options: [::std::os::raw::c_char; 64usize],
    pub unused: [::std::os::raw::c_char; 64usize],
    pub tty: [::std::os::raw::c_char; 64usize],
}
#[pg_guard]
extern "C" {
    pub static mut Db_user_namespace: bool;
}
pub type AuthRequest = uint32;
#[repr(C)]
pub struct CancelRequestPacket {
    pub cancelRequestCode: MsgType,
    pub backendPID: uint32,
    pub cancelAuthCode: uint32,
}
#[pg_guard]
extern "C" {
    pub fn pgarch_start() -> ::std::os::raw::c_int;
}
pub type RmgrId = uint8;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum RmgrIds {
    RM_XLOG_ID = 0,
    RM_XACT_ID = 1,
    RM_SMGR_ID = 2,
    RM_CLOG_ID = 3,
    RM_DBASE_ID = 4,
    RM_TBLSPC_ID = 5,
    RM_MULTIXACT_ID = 6,
    RM_RELMAP_ID = 7,
    RM_STANDBY_ID = 8,
    RM_HEAP2_ID = 9,
    RM_HEAP_ID = 10,
    RM_BTREE_ID = 11,
    RM_HASH_ID = 12,
    RM_GIN_ID = 13,
    RM_GIST_ID = 14,
    RM_SEQ_ID = 15,
    RM_SPGIST_ID = 16,
    RM_BRIN_ID = 17,
    RM_COMMIT_TS_ID = 18,
    RM_REPLORIGIN_ID = 19,
    RM_GENERIC_ID = 20,
    RM_LOGICALMSG_ID = 21,
    RM_NEXT_ID = 22,
}
pub type pg_crc32c = uint32;
#[pg_guard]
extern "C" {
    pub fn pg_comp_crc32c_sb8(
        crc: pg_crc32c,
        data: PgPtr<::std::os::raw::c_void>,
        len: usize,
    ) -> pg_crc32c;
}
#[pg_guard]
extern "C" {
    pub static mut pg_comp_crc32c: ::std::option::Option<
        unsafe extern "C" fn(
            crc: pg_crc32c,
            data: PgPtr<::std::os::raw::c_void>,
            len: usize,
        ) -> pg_crc32c,
    >;
}
#[pg_guard]
extern "C" {
    pub fn pg_comp_crc32c_sse42(
        crc: pg_crc32c,
        data: PgPtr<::std::os::raw::c_void>,
        len: usize,
    ) -> pg_crc32c;
}
#[repr(i32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ForkNumber {
    InvalidForkNumber = -1,
    MAIN_FORKNUM = 0,
    FSM_FORKNUM = 1,
    VISIBILITYMAP_FORKNUM = 2,
    INIT_FORKNUM = 3,
}
#[pg_guard]
extern "C" {
    pub static mut forkNames: [*const ::std::os::raw::c_char; 0usize];
}
#[pg_guard]
extern "C" {
    pub fn forkname_to_number(forkName: PgPtr<::std::os::raw::c_char>) -> ForkNumber;
}
#[pg_guard]
extern "C" {
    pub fn forkname_chars(
        str_: PgPtr<::std::os::raw::c_char>,
        fork: PgPtr<ForkNumber>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn GetDatabasePath(dbNode: Oid, spcNode: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn GetRelationPath(
        dbNode: Oid,
        spcNode: Oid,
        relNode: Oid,
        backendId: ::std::os::raw::c_int,
        forkNumber: ForkNumber,
    ) -> PgPtr<::std::os::raw::c_char>;
}
pub type BackendId = ::std::os::raw::c_int;
#[pg_guard]
extern "C" {
    pub static mut MyBackendId: BackendId;
}
#[pg_guard]
extern "C" {
    pub static mut ParallelMasterBackendId: BackendId;
}
#[repr(C)]
pub struct RelFileNode {
    pub spcNode: Oid,
    pub dbNode: Oid,
    pub relNode: Oid,
}
#[repr(C)]
pub struct RelFileNodeBackend {
    pub node: RelFileNode,
    pub backend: BackendId,
}
#[repr(C)]
pub struct XLogRecord {
    pub xl_tot_len: uint32,
    pub xl_xid: TransactionId,
    pub xl_prev: XLogRecPtr,
    pub xl_info: uint8,
    pub xl_rmid: RmgrId,
    pub xl_crc: pg_crc32c,
}
#[repr(C)]
pub struct XLogRecordBlockHeader {
    pub id: uint8,
    pub fork_flags: uint8,
    pub data_length: uint16,
}
#[repr(C)]
pub struct XLogRecordBlockImageHeader {
    pub length: uint16,
    pub hole_offset: uint16,
    pub bimg_info: uint8,
}
#[repr(C)]
pub struct XLogRecordBlockCompressHeader {
    pub hole_length: uint16,
}
#[repr(C)]
pub struct XLogRecordDataHeaderShort {
    pub id: uint8,
    pub data_length: uint8,
}
#[repr(C)]
pub struct XLogRecordDataHeaderLong {
    pub id: uint8,
}
pub type XLogPageReadCB = ::std::option::Option<
    unsafe extern "C" fn(
        xlogreader: PgPtr<XLogReaderState>,
        targetPagePtr: XLogRecPtr,
        reqLen: ::std::os::raw::c_int,
        targetRecPtr: XLogRecPtr,
        readBuf: PgPtr<::std::os::raw::c_char>,
        pageTLI: PgPtr<TimeLineID>,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
pub struct DecodedBkpBlock {
    pub in_use: bool,
    pub rnode: RelFileNode,
    pub forknum: ForkNumber,
    pub blkno: BlockNumber,
    pub flags: uint8,
    pub has_image: bool,
    pub apply_image: bool,
    pub bkp_image: PgPtr<::std::os::raw::c_char>,
    pub hole_offset: uint16,
    pub hole_length: uint16,
    pub bimg_len: uint16,
    pub bimg_info: uint8,
    pub has_data: bool,
    pub data: PgPtr<::std::os::raw::c_char>,
    pub data_len: uint16,
    pub data_bufsz: uint16,
}
#[repr(C)]
pub struct XLogReaderState {
    pub wal_segment_size: ::std::os::raw::c_int,
    pub read_page: XLogPageReadCB,
    pub system_identifier: uint64,
    pub private_data: PgPtr<::std::os::raw::c_void>,
    pub ReadRecPtr: XLogRecPtr,
    pub EndRecPtr: XLogRecPtr,
    pub decoded_record: PgPtr<XLogRecord>,
    pub main_data: PgPtr<::std::os::raw::c_char>,
    pub main_data_len: uint32,
    pub main_data_bufsz: uint32,
    pub record_origin: RepOriginId,
    pub blocks: [DecodedBkpBlock; 33usize],
    pub max_block_id: ::std::os::raw::c_int,
    pub readBuf: PgPtr<::std::os::raw::c_char>,
    pub readLen: uint32,
    pub readSegNo: XLogSegNo,
    pub readOff: uint32,
    pub readPageTLI: TimeLineID,
    pub latestPagePtr: XLogRecPtr,
    pub latestPageTLI: TimeLineID,
    pub currRecPtr: XLogRecPtr,
    pub currTLI: TimeLineID,
    pub currTLIValidUntil: XLogRecPtr,
    pub nextTLI: TimeLineID,
    pub readRecordBuf: PgPtr<::std::os::raw::c_char>,
    pub readRecordBufSize: uint32,
    pub errormsg_buf: PgPtr<::std::os::raw::c_char>,
}
#[pg_guard]
extern "C" {
    pub fn XLogReaderAllocate(
        wal_segment_size: ::std::os::raw::c_int,
        pagereadfunc: XLogPageReadCB,
        private_data: PgPtr<::std::os::raw::c_void>,
    ) -> PgPtr<XLogReaderState>;
}
#[pg_guard]
extern "C" {
    pub fn XLogReaderFree(state: PgPtr<XLogReaderState>);
}
#[pg_guard]
extern "C" {
    pub fn XLogReadRecord(
        state: PgPtr<XLogReaderState>,
        recptr: XLogRecPtr,
        errormsg: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> PgPtr<XLogRecord>;
}
#[pg_guard]
extern "C" {
    pub fn XLogReaderValidatePageHeader(
        state: PgPtr<XLogReaderState>,
        recptr: XLogRecPtr,
        phdr: PgPtr<::std::os::raw::c_char>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn XLogReaderInvalReadState(state: PgPtr<XLogReaderState>);
}
#[pg_guard]
extern "C" {
    pub fn DecodeXLogRecord(
        state: PgPtr<XLogReaderState>,
        record: PgPtr<XLogRecord>,
        errmsg: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn RestoreBlockImage(
        recoder: PgPtr<XLogReaderState>,
        block_id: uint8,
        dst: PgPtr<::std::os::raw::c_char>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn XLogRecGetBlockData(
        record: PgPtr<XLogReaderState>,
        block_id: uint8,
        len: PgPtr<Size>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn XLogRecGetBlockTag(
        record: PgPtr<XLogReaderState>,
        block_id: uint8,
        rnode: PgPtr<RelFileNode>,
        forknum: PgPtr<ForkNumber>,
        blknum: PgPtr<BlockNumber>,
    ) -> bool;
}
pub type XidStatus = ::std::os::raw::c_int;
#[repr(C)]
pub struct xl_clog_truncate {
    pub pageno: ::std::os::raw::c_int,
    pub oldestXact: TransactionId,
    pub oldestXactDb: Oid,
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdSetTreeStatus(
        xid: TransactionId,
        nsubxids: ::std::os::raw::c_int,
        subxids: PgPtr<TransactionId>,
        status: XidStatus,
        lsn: XLogRecPtr,
    );
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdGetStatus(xid: TransactionId, lsn: PgPtr<XLogRecPtr>) -> XidStatus;
}
#[pg_guard]
extern "C" {
    pub fn CLOGShmemBuffers() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn CLOGShmemSize() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn CLOGShmemInit();
}
#[pg_guard]
extern "C" {
    pub fn BootStrapCLOG();
}
#[pg_guard]
extern "C" {
    pub fn StartupCLOG();
}
#[pg_guard]
extern "C" {
    pub fn TrimCLOG();
}
#[pg_guard]
extern "C" {
    pub fn ShutdownCLOG();
}
#[pg_guard]
extern "C" {
    pub fn CheckPointCLOG();
}
#[pg_guard]
extern "C" {
    pub fn ExtendCLOG(newestXact: TransactionId);
}
#[pg_guard]
extern "C" {
    pub fn TruncateCLOG(oldestXact: TransactionId, oldestxid_datoid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn clog_redo(record: PgPtr<XLogReaderState>);
}
#[pg_guard]
extern "C" {
    pub fn clog_desc(buf: PgPtr<StringInfoData>, record: PgPtr<XLogReaderState>);
}
#[pg_guard]
extern "C" {
    pub fn clog_identify(info: uint8) -> PgPtr<::std::os::raw::c_char>;
}
#[repr(C)]
pub struct dlist_node {
    pub prev: PgPtr<dlist_node>,
    pub next: PgPtr<dlist_node>,
}
#[repr(C)]
pub struct dlist_head {
    pub head: dlist_node,
}
#[repr(C)]
pub struct dlist_iter {
    pub cur: PgPtr<dlist_node>,
    pub end: PgPtr<dlist_node>,
}
#[repr(C)]
pub struct dlist_mutable_iter {
    pub cur: PgPtr<dlist_node>,
    pub next: PgPtr<dlist_node>,
    pub end: PgPtr<dlist_node>,
}
#[repr(C)]
pub struct slist_node {
    pub next: PgPtr<slist_node>,
}
#[repr(C)]
pub struct slist_head {
    pub head: slist_node,
}
#[repr(C)]
pub struct slist_iter {
    pub cur: PgPtr<slist_node>,
}
#[repr(C)]
pub struct slist_mutable_iter {
    pub cur: PgPtr<slist_node>,
    pub next: PgPtr<slist_node>,
    pub prev: PgPtr<slist_node>,
}
#[pg_guard]
extern "C" {
    pub fn slist_delete(head: PgPtr<slist_head>, node: PgPtr<slist_node>);
}
#[repr(C)]
pub struct Latch {
    pub is_set: sig_atomic_t,
    pub is_shared: bool,
    pub owner_pid: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct WaitEvent {
    pub pos: ::std::os::raw::c_int,
    pub events: uint32,
    pub fd: pgsocket,
    pub user_data: PgPtr<::std::os::raw::c_void>,
}
#[repr(C)]
pub struct WaitEventSet {
    _unused: [u8; 0],
}
#[pg_guard]
extern "C" {
    pub fn InitializeLatchSupport();
}
#[pg_guard]
extern "C" {
    pub fn InitLatch(latch: PgPtr<Latch>);
}
#[pg_guard]
extern "C" {
    pub fn InitSharedLatch(latch: PgPtr<Latch>);
}
#[pg_guard]
extern "C" {
    pub fn OwnLatch(latch: PgPtr<Latch>);
}
#[pg_guard]
extern "C" {
    pub fn DisownLatch(latch: PgPtr<Latch>);
}
#[pg_guard]
extern "C" {
    pub fn SetLatch(latch: PgPtr<Latch>);
}
#[pg_guard]
extern "C" {
    pub fn ResetLatch(latch: PgPtr<Latch>);
}
#[pg_guard]
extern "C" {
    pub fn CreateWaitEventSet(
        context: PgPtr<MemoryContextData>,
        nevents: ::std::os::raw::c_int,
    ) -> PgPtr<WaitEventSet>;
}
#[pg_guard]
extern "C" {
    pub fn FreeWaitEventSet(set: PgPtr<WaitEventSet>);
}
#[pg_guard]
extern "C" {
    pub fn AddWaitEventToSet(
        set: PgPtr<WaitEventSet>,
        events: uint32,
        fd: pgsocket,
        latch: PgPtr<Latch>,
        user_data: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ModifyWaitEvent(
        set: PgPtr<WaitEventSet>,
        pos: ::std::os::raw::c_int,
        events: uint32,
        latch: PgPtr<Latch>,
    );
}
#[pg_guard]
extern "C" {
    pub fn WaitEventSetWait(
        set: PgPtr<WaitEventSet>,
        timeout: ::std::os::raw::c_long,
        occurred_events: PgPtr<WaitEvent>,
        nevents: ::std::os::raw::c_int,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn WaitLatch(
        latch: PgPtr<Latch>,
        wakeEvents: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_long,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn WaitLatchOrSocket(
        latch: PgPtr<Latch>,
        wakeEvents: ::std::os::raw::c_int,
        sock: pgsocket,
        timeout: ::std::os::raw::c_long,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn latch_sigusr1_handler();
}
pub type LOCKMASK = ::std::os::raw::c_int;
pub type LOCKMODE = ::std::os::raw::c_int;
#[repr(C)]
pub struct xl_standby_lock {
    pub xid: TransactionId,
    pub dbOid: Oid,
    pub relOid: Oid,
}
#[repr(C)]
pub struct LWLock {
    pub tranche: uint16,
    pub state: pg_atomic_uint32,
    pub waiters: proclist_head,
}
#[repr(C)]
pub struct LWLockPadded {
    pub lock: __BindgenUnionField<LWLock>,
    pub pad: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub bindgen_union_field: [u32; 32usize],
}
#[repr(C)]
pub struct LWLockMinimallyPadded {
    pub lock: __BindgenUnionField<LWLock>,
    pub pad: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub bindgen_union_field: [u32; 8usize],
}
#[pg_guard]
extern "C" {
    pub static mut MainLWLockArray: PgPtr<LWLockPadded>;
}
#[pg_guard]
extern "C" {
    pub static mut MainLWLockNames: [*const ::std::os::raw::c_char; 0usize];
}
#[repr(C)]
pub struct NamedLWLockTranche {
    pub trancheId: ::std::os::raw::c_int,
    pub trancheName: PgPtr<::std::os::raw::c_char>,
}
#[pg_guard]
extern "C" {
    pub static mut NamedLWLockTrancheArray: PgPtr<NamedLWLockTranche>;
}
#[pg_guard]
extern "C" {
    pub static mut NamedLWLockTrancheRequests: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum LWLockMode {
    LW_EXCLUSIVE = 0,
    LW_SHARED = 1,
    LW_WAIT_UNTIL_FREE = 2,
}
#[pg_guard]
extern "C" {
    pub fn LWLockAcquire(lock: PgPtr<LWLock>, mode: LWLockMode) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn LWLockConditionalAcquire(lock: PgPtr<LWLock>, mode: LWLockMode) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn LWLockAcquireOrWait(lock: PgPtr<LWLock>, mode: LWLockMode) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn LWLockRelease(lock: PgPtr<LWLock>);
}
#[pg_guard]
extern "C" {
    pub fn LWLockReleaseClearVar(lock: PgPtr<LWLock>, valptr: PgPtr<uint64>, val: uint64);
}
#[pg_guard]
extern "C" {
    pub fn LWLockReleaseAll();
}
#[pg_guard]
extern "C" {
    pub fn LWLockHeldByMe(lock: PgPtr<LWLock>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn LWLockHeldByMeInMode(lock: PgPtr<LWLock>, mode: LWLockMode) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn LWLockWaitForVar(
        lock: PgPtr<LWLock>,
        valptr: PgPtr<uint64>,
        oldval: uint64,
        newval: PgPtr<uint64>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn LWLockUpdateVar(lock: PgPtr<LWLock>, valptr: PgPtr<uint64>, value: uint64);
}
#[pg_guard]
extern "C" {
    pub fn LWLockShmemSize() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn CreateLWLocks();
}
#[pg_guard]
extern "C" {
    pub fn InitLWLockAccess();
}
#[pg_guard]
extern "C" {
    pub fn GetLWLockIdentifier(classId: uint32, eventId: uint16) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn RequestNamedLWLockTranche(
        tranche_name: PgPtr<::std::os::raw::c_char>,
        num_lwlocks: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn GetNamedLWLockTranche(
        tranche_name: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<LWLockPadded>;
}
#[pg_guard]
extern "C" {
    pub fn LWLockNewTrancheId() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn LWLockRegisterTranche(
        tranche_id: ::std::os::raw::c_int,
        tranche_name: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn LWLockInitialize(lock: PgPtr<LWLock>, tranche_id: ::std::os::raw::c_int);
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum BuiltinTrancheIds {
    LWTRANCHE_CLOG_BUFFERS = 45,
    LWTRANCHE_COMMITTS_BUFFERS = 46,
    LWTRANCHE_SUBTRANS_BUFFERS = 47,
    LWTRANCHE_MXACTOFFSET_BUFFERS = 48,
    LWTRANCHE_MXACTMEMBER_BUFFERS = 49,
    LWTRANCHE_ASYNC_BUFFERS = 50,
    LWTRANCHE_OLDSERXID_BUFFERS = 51,
    LWTRANCHE_WAL_INSERT = 52,
    LWTRANCHE_BUFFER_CONTENT = 53,
    LWTRANCHE_BUFFER_IO_IN_PROGRESS = 54,
    LWTRANCHE_REPLICATION_ORIGIN = 55,
    LWTRANCHE_REPLICATION_SLOT_IO_IN_PROGRESS = 56,
    LWTRANCHE_PROC = 57,
    LWTRANCHE_BUFFER_MAPPING = 58,
    LWTRANCHE_LOCK_MANAGER = 59,
    LWTRANCHE_PREDICATE_LOCK_MANAGER = 60,
    LWTRANCHE_PARALLEL_HASH_JOIN = 61,
    LWTRANCHE_PARALLEL_QUERY_DSA = 62,
    LWTRANCHE_SESSION_DSA = 63,
    LWTRANCHE_SESSION_RECORD_TABLE = 64,
    LWTRANCHE_SESSION_TYPMOD_TABLE = 65,
    LWTRANCHE_SHARED_TUPLESTORE = 66,
    LWTRANCHE_TBM = 67,
    LWTRANCHE_PARALLEL_APPEND = 68,
    LWTRANCHE_SXACT = 69,
    LWTRANCHE_FIRST_USER_DEFINED = 70,
}
pub type LWLockId = PgPtr<LWLock>;
#[repr(C)]
pub struct SHM_QUEUE {
    pub prev: PgPtr<SHM_QUEUE>,
    pub next: PgPtr<SHM_QUEUE>,
}
#[pg_guard]
extern "C" {
    pub fn InitShmemAccess(seghdr: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn InitShmemAllocation();
}
#[pg_guard]
extern "C" {
    pub fn ShmemAlloc(size: Size) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn ShmemAllocNoError(size: Size) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn ShmemAllocUnlocked(size: Size) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn ShmemAddrIsValid(addr: PgPtr<::std::os::raw::c_void>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn InitShmemIndex();
}
#[pg_guard]
extern "C" {
    pub fn ShmemInitHash(
        name: PgPtr<::std::os::raw::c_char>,
        init_size: ::std::os::raw::c_long,
        max_size: ::std::os::raw::c_long,
        infoP: PgPtr<HASHCTL>,
        hash_flags: ::std::os::raw::c_int,
    ) -> PgPtr<HTAB>;
}
#[pg_guard]
extern "C" {
    pub fn ShmemInitStruct(
        name: PgPtr<::std::os::raw::c_char>,
        size: Size,
        foundPtr: PgPtr<bool>,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn add_size(s1: Size, s2: Size) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn mul_size(s1: Size, s2: Size) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn RequestAddinShmemSpace(size: Size);
}
#[repr(C)]
pub struct ShmemIndexEnt {
    pub key: [::std::os::raw::c_char; 48usize],
    pub location: PgPtr<::std::os::raw::c_void>,
    pub size: Size,
}
#[pg_guard]
extern "C" {
    pub fn SHMQueueInit(queue: PgPtr<SHM_QUEUE>);
}
#[pg_guard]
extern "C" {
    pub fn SHMQueueElemInit(queue: PgPtr<SHM_QUEUE>);
}
#[pg_guard]
extern "C" {
    pub fn SHMQueueDelete(queue: PgPtr<SHM_QUEUE>);
}
#[pg_guard]
extern "C" {
    pub fn SHMQueueInsertBefore(queue: PgPtr<SHM_QUEUE>, elem: PgPtr<SHM_QUEUE>);
}
#[pg_guard]
extern "C" {
    pub fn SHMQueueInsertAfter(queue: PgPtr<SHM_QUEUE>, elem: PgPtr<SHM_QUEUE>);
}
#[pg_guard]
extern "C" {
    pub fn SHMQueueNext(
        queue: PgPtr<SHM_QUEUE>,
        curElem: PgPtr<SHM_QUEUE>,
        linkOffset: Size,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn SHMQueuePrev(
        queue: PgPtr<SHM_QUEUE>,
        curElem: PgPtr<SHM_QUEUE>,
        linkOffset: Size,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn SHMQueueEmpty(queue: PgPtr<SHM_QUEUE>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn SHMQueueIsDetached(queue: PgPtr<SHM_QUEUE>) -> bool;
}
#[repr(C)]
pub struct PROC_QUEUE {
    pub links: SHM_QUEUE,
    pub size: ::std::os::raw::c_int,
}
#[pg_guard]
extern "C" {
    pub static mut max_locks_per_xact: ::std::os::raw::c_int;
}
#[repr(C)]
pub struct VirtualTransactionId {
    pub backendId: BackendId,
    pub localTransactionId: LocalTransactionId,
}
#[repr(C)]
pub struct LockMethodData {
    pub numLockModes: ::std::os::raw::c_int,
    pub conflictTab: PgPtr<LOCKMASK>,
    pub lockModeNames: PgPtr<PgPtr<::std::os::raw::c_char>>,
    pub trace_flag: PgPtr<bool>,
}
pub type LockMethod = PgPtr<LockMethodData>;
pub type LOCKMETHODID = uint16;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum LockTagType {
    LOCKTAG_RELATION = 0,
    LOCKTAG_RELATION_EXTEND = 1,
    LOCKTAG_PAGE = 2,
    LOCKTAG_TUPLE = 3,
    LOCKTAG_TRANSACTION = 4,
    LOCKTAG_VIRTUALTRANSACTION = 5,
    LOCKTAG_SPECULATIVE_TOKEN = 6,
    LOCKTAG_OBJECT = 7,
    LOCKTAG_USERLOCK = 8,
    LOCKTAG_ADVISORY = 9,
}
#[pg_guard]
extern "C" {
    pub static mut LockTagTypeNames: [*const ::std::os::raw::c_char; 0usize];
}
#[repr(C)]
pub struct LOCKTAG {
    pub locktag_field1: uint32,
    pub locktag_field2: uint32,
    pub locktag_field3: uint32,
    pub locktag_field4: uint16,
    pub locktag_type: uint8,
    pub locktag_lockmethodid: uint8,
}
#[repr(C)]
pub struct LOCK {
    pub tag: LOCKTAG,
    pub grantMask: LOCKMASK,
    pub waitMask: LOCKMASK,
    pub procLocks: SHM_QUEUE,
    pub waitProcs: PROC_QUEUE,
    pub requested: [::std::os::raw::c_int; 10usize],
    pub nRequested: ::std::os::raw::c_int,
    pub granted: [::std::os::raw::c_int; 10usize],
    pub nGranted: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct PROCLOCKTAG {
    pub myLock: PgPtr<LOCK>,
    pub myProc: PgPtr<PGPROC>,
}
#[repr(C)]
pub struct PROCLOCK {
    pub tag: PROCLOCKTAG,
    pub groupLeader: PgPtr<PGPROC>,
    pub holdMask: LOCKMASK,
    pub releaseMask: LOCKMASK,
    pub lockLink: SHM_QUEUE,
    pub procLink: SHM_QUEUE,
}
#[repr(C)]
pub struct LOCALLOCKTAG {
    pub lock: LOCKTAG,
    pub mode: LOCKMODE,
}
#[repr(C)]
pub struct LOCALLOCKOWNER {
    pub owner: PgPtr<ResourceOwnerData>,
    pub nLocks: int64,
}
#[repr(C)]
pub struct LOCALLOCK {
    pub tag: LOCALLOCKTAG,
    pub hashcode: uint32,
    pub lock: PgPtr<LOCK>,
    pub proclock: PgPtr<PROCLOCK>,
    pub nLocks: int64,
    pub numLockOwners: ::std::os::raw::c_int,
    pub maxLockOwners: ::std::os::raw::c_int,
    pub lockOwners: PgPtr<LOCALLOCKOWNER>,
    pub holdsStrongLockCount: bool,
    pub lockCleared: bool,
}
#[repr(C)]
pub struct LockInstanceData {
    pub locktag: LOCKTAG,
    pub holdMask: LOCKMASK,
    pub waitLockMode: LOCKMODE,
    pub backend: BackendId,
    pub lxid: LocalTransactionId,
    pub pid: ::std::os::raw::c_int,
    pub leaderPid: ::std::os::raw::c_int,
    pub fastpath: bool,
}
#[repr(C)]
pub struct LockData {
    pub nelements: ::std::os::raw::c_int,
    pub locks: PgPtr<LockInstanceData>,
}
#[repr(C)]
pub struct BlockedProcData {
    pub pid: ::std::os::raw::c_int,
    pub first_lock: ::std::os::raw::c_int,
    pub num_locks: ::std::os::raw::c_int,
    pub first_waiter: ::std::os::raw::c_int,
    pub num_waiters: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct BlockedProcsData {
    pub procs: PgPtr<BlockedProcData>,
    pub locks: PgPtr<LockInstanceData>,
    pub waiter_pids: PgPtr<::std::os::raw::c_int>,
    pub nprocs: ::std::os::raw::c_int,
    pub maxprocs: ::std::os::raw::c_int,
    pub nlocks: ::std::os::raw::c_int,
    pub maxlocks: ::std::os::raw::c_int,
    pub npids: ::std::os::raw::c_int,
    pub maxpids: ::std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum LockAcquireResult {
    LOCKACQUIRE_NOT_AVAIL = 0,
    LOCKACQUIRE_OK = 1,
    LOCKACQUIRE_ALREADY_HELD = 2,
    LOCKACQUIRE_ALREADY_CLEAR = 3,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum DeadLockState {
    DS_NOT_YET_CHECKED = 0,
    DS_NO_DEADLOCK = 1,
    DS_SOFT_DEADLOCK = 2,
    DS_HARD_DEADLOCK = 3,
    DS_BLOCKED_BY_AUTOVACUUM = 4,
}
#[pg_guard]
extern "C" {
    pub fn InitLocks();
}
#[pg_guard]
extern "C" {
    pub fn GetLocksMethodTable(lock: PgPtr<LOCK>) -> PgPtr<LockMethodData>;
}
#[pg_guard]
extern "C" {
    pub fn GetLockTagsMethodTable(locktag: PgPtr<LOCKTAG>) -> PgPtr<LockMethodData>;
}
#[pg_guard]
extern "C" {
    pub fn LockTagHashCode(locktag: PgPtr<LOCKTAG>) -> uint32;
}
#[pg_guard]
extern "C" {
    pub fn DoLockModesConflict(mode1: LOCKMODE, mode2: LOCKMODE) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn LockAcquire(
        locktag: PgPtr<LOCKTAG>,
        lockmode: LOCKMODE,
        sessionLock: bool,
        dontWait: bool,
    ) -> LockAcquireResult;
}
#[pg_guard]
extern "C" {
    pub fn LockAcquireExtended(
        locktag: PgPtr<LOCKTAG>,
        lockmode: LOCKMODE,
        sessionLock: bool,
        dontWait: bool,
        reportMemoryError: bool,
        locallockp: PgPtr<PgPtr<LOCALLOCK>>,
    ) -> LockAcquireResult;
}
#[pg_guard]
extern "C" {
    pub fn AbortStrongLockAcquire();
}
#[pg_guard]
extern "C" {
    pub fn MarkLockClear(locallock: PgPtr<LOCALLOCK>);
}
#[pg_guard]
extern "C" {
    pub fn LockRelease(locktag: PgPtr<LOCKTAG>, lockmode: LOCKMODE, sessionLock: bool) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn LockReleaseAll(lockmethodid: LOCKMETHODID, allLocks: bool);
}
#[pg_guard]
extern "C" {
    pub fn LockReleaseSession(lockmethodid: LOCKMETHODID);
}
#[pg_guard]
extern "C" {
    pub fn LockReleaseCurrentOwner(
        locallocks: PgPtr<PgPtr<LOCALLOCK>>,
        nlocks: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn LockReassignCurrentOwner(
        locallocks: PgPtr<PgPtr<LOCALLOCK>>,
        nlocks: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn LockHeldByMe(locktag: PgPtr<LOCKTAG>, lockmode: LOCKMODE) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn LockHasWaiters(locktag: PgPtr<LOCKTAG>, lockmode: LOCKMODE, sessionLock: bool) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetLockConflicts(
        locktag: PgPtr<LOCKTAG>,
        lockmode: LOCKMODE,
        countp: PgPtr<::std::os::raw::c_int>,
    ) -> PgPtr<VirtualTransactionId>;
}
#[pg_guard]
extern "C" {
    pub fn AtPrepare_Locks();
}
#[pg_guard]
extern "C" {
    pub fn PostPrepare_Locks(xid: TransactionId);
}
#[pg_guard]
extern "C" {
    pub fn LockCheckConflicts(
        lockMethodTable: PgPtr<LockMethodData>,
        lockmode: LOCKMODE,
        lock: PgPtr<LOCK>,
        proclock: PgPtr<PROCLOCK>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn GrantLock(lock: PgPtr<LOCK>, proclock: PgPtr<PROCLOCK>, lockmode: LOCKMODE);
}
#[pg_guard]
extern "C" {
    pub fn GrantAwaitedLock();
}
#[pg_guard]
extern "C" {
    pub fn RemoveFromWaitQueue(proc_: PgPtr<PGPROC>, hashcode: uint32);
}
#[pg_guard]
extern "C" {
    pub fn LockShmemSize() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn GetLockStatusData() -> PgPtr<LockData>;
}
#[pg_guard]
extern "C" {
    pub fn GetBlockerStatusData(blocked_pid: ::std::os::raw::c_int) -> PgPtr<BlockedProcsData>;
}
#[pg_guard]
extern "C" {
    pub fn GetRunningTransactionLocks(
        nlocks: PgPtr<::std::os::raw::c_int>,
    ) -> PgPtr<xl_standby_lock>;
}
#[pg_guard]
extern "C" {
    pub fn GetLockmodeName(
        lockmethodid: LOCKMETHODID,
        mode: LOCKMODE,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn lock_twophase_recover(
        xid: TransactionId,
        info: uint16,
        recdata: PgPtr<::std::os::raw::c_void>,
        len: uint32,
    );
}
#[pg_guard]
extern "C" {
    pub fn lock_twophase_postcommit(
        xid: TransactionId,
        info: uint16,
        recdata: PgPtr<::std::os::raw::c_void>,
        len: uint32,
    );
}
#[pg_guard]
extern "C" {
    pub fn lock_twophase_postabort(
        xid: TransactionId,
        info: uint16,
        recdata: PgPtr<::std::os::raw::c_void>,
        len: uint32,
    );
}
#[pg_guard]
extern "C" {
    pub fn lock_twophase_standby_recover(
        xid: TransactionId,
        info: uint16,
        recdata: PgPtr<::std::os::raw::c_void>,
        len: uint32,
    );
}
#[pg_guard]
extern "C" {
    pub fn DeadLockCheck(proc_: PgPtr<PGPROC>) -> DeadLockState;
}
#[pg_guard]
extern "C" {
    pub fn GetBlockingAutoVacuumPgproc() -> PgPtr<PGPROC>;
}
#[pg_guard]
extern "C" {
    pub fn DeadLockReport();
}
#[pg_guard]
extern "C" {
    pub fn RememberSimpleDeadLock(
        proc1: PgPtr<PGPROC>,
        lockmode: LOCKMODE,
        lock: PgPtr<LOCK>,
        proc2: PgPtr<PGPROC>,
    );
}
#[pg_guard]
extern "C" {
    pub fn InitDeadLockChecking();
}
#[pg_guard]
extern "C" {
    pub fn LockWaiterCount(locktag: PgPtr<LOCKTAG>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn VirtualXactLockTableInsert(vxid: VirtualTransactionId);
}
#[pg_guard]
extern "C" {
    pub fn VirtualXactLockTableCleanup();
}
#[pg_guard]
extern "C" {
    pub fn VirtualXactLock(vxid: VirtualTransactionId, wait: bool) -> bool;
}
#[repr(C)]
pub struct PGSemaphoreData {
    _unused: [u8; 0],
}
pub type PGSemaphore = PgPtr<PGSemaphoreData>;
#[pg_guard]
extern "C" {
    pub fn PGSemaphoreShmemSize(maxSemas: ::std::os::raw::c_int) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn PGReserveSemaphores(maxSemas: ::std::os::raw::c_int, port: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn PGSemaphoreCreate() -> PgPtr<PGSemaphoreData>;
}
#[pg_guard]
extern "C" {
    pub fn PGSemaphoreReset(sema: PgPtr<PGSemaphoreData>);
}
#[pg_guard]
extern "C" {
    pub fn PGSemaphoreLock(sema: PgPtr<PGSemaphoreData>);
}
#[pg_guard]
extern "C" {
    pub fn PGSemaphoreUnlock(sema: PgPtr<PGSemaphoreData>);
}
#[pg_guard]
extern "C" {
    pub fn PGSemaphoreTryLock(sema: PgPtr<PGSemaphoreData>) -> bool;
}
#[repr(C)]
pub struct XidCache {
    pub xids: [TransactionId; 64usize],
}
#[repr(C)]
pub struct PGPROC {
    pub links: SHM_QUEUE,
    pub procgloballist: PgPtr<PgPtr<PGPROC>>,
    pub sem: PgPtr<PGSemaphoreData>,
    pub waitStatus: ::std::os::raw::c_int,
    pub procLatch: Latch,
    pub lxid: LocalTransactionId,
    pub pid: ::std::os::raw::c_int,
    pub pgprocno: ::std::os::raw::c_int,
    pub backendId: BackendId,
    pub databaseId: Oid,
    pub roleId: Oid,
    pub tempNamespaceId: Oid,
    pub isBackgroundWorker: bool,
    pub recoveryConflictPending: bool,
    pub lwWaiting: bool,
    pub lwWaitMode: uint8,
    pub lwWaitLink: proclist_node,
    pub cvWaitLink: proclist_node,
    pub waitLock: PgPtr<LOCK>,
    pub waitProcLock: PgPtr<PROCLOCK>,
    pub waitLockMode: LOCKMODE,
    pub heldLocks: LOCKMASK,
    pub waitLSN: XLogRecPtr,
    pub syncRepState: ::std::os::raw::c_int,
    pub syncRepLinks: SHM_QUEUE,
    pub myProcLocks: [SHM_QUEUE; 16usize],
    pub subxids: XidCache,
    pub procArrayGroupMember: bool,
    pub procArrayGroupNext: pg_atomic_uint32,
    pub procArrayGroupMemberXid: TransactionId,
    pub wait_event_info: uint32,
    pub clogGroupMember: bool,
    pub clogGroupNext: pg_atomic_uint32,
    pub clogGroupMemberXid: TransactionId,
    pub clogGroupMemberXidStatus: XidStatus,
    pub clogGroupMemberPage: ::std::os::raw::c_int,
    pub clogGroupMemberLsn: XLogRecPtr,
    pub backendLock: LWLock,
    pub fpLockBits: uint64,
    pub fpRelId: [Oid; 16usize],
    pub fpVXIDLock: bool,
    pub fpLocalTransactionId: LocalTransactionId,
    pub lockGroupLeader: PgPtr<PGPROC>,
    pub lockGroupMembers: dlist_head,
    pub lockGroupLink: dlist_node,
}
#[pg_guard]
extern "C" {
    pub static mut MyProc: PgPtr<PGPROC>;
}
#[pg_guard]
extern "C" {
    pub static mut MyPgXact: PgPtr<PGXACT>;
}
#[repr(C)]
pub struct PGXACT {
    pub xid: TransactionId,
    pub xmin: TransactionId,
    pub vacuumFlags: uint8,
    pub overflowed: bool,
    pub delayChkpt: bool,
    pub nxids: uint8,
}
#[repr(C)]
pub struct PROC_HDR {
    pub allProcs: PgPtr<PGPROC>,
    pub allPgXact: PgPtr<PGXACT>,
    pub allProcCount: uint32,
    pub freeProcs: PgPtr<PGPROC>,
    pub autovacFreeProcs: PgPtr<PGPROC>,
    pub bgworkerFreeProcs: PgPtr<PGPROC>,
    pub walsenderFreeProcs: PgPtr<PGPROC>,
    pub procArrayGroupFirst: pg_atomic_uint32,
    pub clogGroupFirst: pg_atomic_uint32,
    pub walwriterLatch: PgPtr<Latch>,
    pub checkpointerLatch: PgPtr<Latch>,
    pub spins_per_delay: ::std::os::raw::c_int,
    pub startupProc: PgPtr<PGPROC>,
    pub startupProcPid: ::std::os::raw::c_int,
    pub startupBufferPinWaitBufId: ::std::os::raw::c_int,
}
#[pg_guard]
extern "C" {
    pub static mut ProcGlobal: PgPtr<PROC_HDR>;
}
#[pg_guard]
extern "C" {
    pub static mut PreparedXactProcs: PgPtr<PGPROC>;
}
#[pg_guard]
extern "C" {
    pub static mut DeadlockTimeout: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut StatementTimeout: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut LockTimeout: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut IdleInTransactionSessionTimeout: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut log_lock_waits: bool;
}
#[pg_guard]
extern "C" {
    pub fn ProcGlobalSemas() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ProcGlobalShmemSize() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn InitProcGlobal();
}
#[pg_guard]
extern "C" {
    pub fn InitProcess();
}
#[pg_guard]
extern "C" {
    pub fn InitProcessPhase2();
}
#[pg_guard]
extern "C" {
    pub fn InitAuxiliaryProcess();
}
#[pg_guard]
extern "C" {
    pub fn PublishStartupProcessInformation();
}
#[pg_guard]
extern "C" {
    pub fn SetStartupBufferPinWaitBufId(bufid: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn GetStartupBufferPinWaitBufId() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn HaveNFreeProcs(n: ::std::os::raw::c_int) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ProcReleaseLocks(isCommit: bool);
}
#[pg_guard]
extern "C" {
    pub fn ProcQueueInit(queue: PgPtr<PROC_QUEUE>);
}
#[pg_guard]
extern "C" {
    pub fn ProcSleep(
        locallock: PgPtr<LOCALLOCK>,
        lockMethodTable: PgPtr<LockMethodData>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ProcWakeup(proc_: PgPtr<PGPROC>, waitStatus: ::std::os::raw::c_int) -> PgPtr<PGPROC>;
}
#[pg_guard]
extern "C" {
    pub fn ProcLockWakeup(lockMethodTable: PgPtr<LockMethodData>, lock: PgPtr<LOCK>);
}
#[pg_guard]
extern "C" {
    pub fn CheckDeadLockAlert();
}
#[pg_guard]
extern "C" {
    pub fn IsWaitingForLock() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn LockErrorCleanup();
}
#[pg_guard]
extern "C" {
    pub fn ProcWaitForSignal(wait_event_info: uint32);
}
#[pg_guard]
extern "C" {
    pub fn ProcSendSignal(pid: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn AuxiliaryPidGetProc(pid: ::std::os::raw::c_int) -> PgPtr<PGPROC>;
}
#[pg_guard]
extern "C" {
    pub fn BecomeLockGroupLeader();
}
#[pg_guard]
extern "C" {
    pub fn BecomeLockGroupMember(leader: PgPtr<PGPROC>, pid: ::std::os::raw::c_int) -> bool;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum TrackFunctionsLevel {
    TRACK_FUNC_OFF = 0,
    TRACK_FUNC_PL = 1,
    TRACK_FUNC_ALL = 2,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum StatMsgType {
    PGSTAT_MTYPE_DUMMY = 0,
    PGSTAT_MTYPE_INQUIRY = 1,
    PGSTAT_MTYPE_TABSTAT = 2,
    PGSTAT_MTYPE_TABPURGE = 3,
    PGSTAT_MTYPE_DROPDB = 4,
    PGSTAT_MTYPE_RESETCOUNTER = 5,
    PGSTAT_MTYPE_RESETSHAREDCOUNTER = 6,
    PGSTAT_MTYPE_RESETSINGLECOUNTER = 7,
    PGSTAT_MTYPE_AUTOVAC_START = 8,
    PGSTAT_MTYPE_VACUUM = 9,
    PGSTAT_MTYPE_ANALYZE = 10,
    PGSTAT_MTYPE_ARCHIVER = 11,
    PGSTAT_MTYPE_BGWRITER = 12,
    PGSTAT_MTYPE_FUNCSTAT = 13,
    PGSTAT_MTYPE_FUNCPURGE = 14,
    PGSTAT_MTYPE_RECOVERYCONFLICT = 15,
    PGSTAT_MTYPE_TEMPFILE = 16,
    PGSTAT_MTYPE_DEADLOCK = 17,
    PGSTAT_MTYPE_CHECKSUMFAILURE = 18,
}
pub type PgStat_Counter = int64;
#[repr(C)]
pub struct PgStat_TableCounts {
    pub t_numscans: PgStat_Counter,
    pub t_tuples_returned: PgStat_Counter,
    pub t_tuples_fetched: PgStat_Counter,
    pub t_tuples_inserted: PgStat_Counter,
    pub t_tuples_updated: PgStat_Counter,
    pub t_tuples_deleted: PgStat_Counter,
    pub t_tuples_hot_updated: PgStat_Counter,
    pub t_truncated: bool,
    pub t_delta_live_tuples: PgStat_Counter,
    pub t_delta_dead_tuples: PgStat_Counter,
    pub t_changed_tuples: PgStat_Counter,
    pub t_blocks_fetched: PgStat_Counter,
    pub t_blocks_hit: PgStat_Counter,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum PgStat_Shared_Reset_Target {
    RESET_ARCHIVER = 0,
    RESET_BGWRITER = 1,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum PgStat_Single_Reset_Type {
    RESET_TABLE = 0,
    RESET_FUNCTION = 1,
}
#[repr(C)]
pub struct PgStat_TableStatus {
    pub t_id: Oid,
    pub t_shared: bool,
    pub trans: PgPtr<PgStat_TableXactStatus>,
    pub t_counts: PgStat_TableCounts,
}
#[repr(C)]
pub struct PgStat_TableXactStatus {
    pub tuples_inserted: PgStat_Counter,
    pub tuples_updated: PgStat_Counter,
    pub tuples_deleted: PgStat_Counter,
    pub truncated: bool,
    pub inserted_pre_trunc: PgStat_Counter,
    pub updated_pre_trunc: PgStat_Counter,
    pub deleted_pre_trunc: PgStat_Counter,
    pub nest_level: ::std::os::raw::c_int,
    pub upper: PgPtr<PgStat_TableXactStatus>,
    pub parent: PgPtr<PgStat_TableStatus>,
    pub next: PgPtr<PgStat_TableXactStatus>,
}
#[repr(C)]
pub struct PgStat_MsgHdr {
    pub m_type: StatMsgType,
    pub m_size: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct PgStat_MsgDummy {
    pub m_hdr: PgStat_MsgHdr,
}
#[repr(C)]
pub struct PgStat_MsgInquiry {
    pub m_hdr: PgStat_MsgHdr,
    pub clock_time: TimestampTz,
    pub cutoff_time: TimestampTz,
    pub databaseid: Oid,
}
#[repr(C)]
pub struct PgStat_TableEntry {
    pub t_id: Oid,
    pub t_counts: PgStat_TableCounts,
}
#[repr(C)]
pub struct PgStat_MsgTabstat {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_nentries: ::std::os::raw::c_int,
    pub m_xact_commit: ::std::os::raw::c_int,
    pub m_xact_rollback: ::std::os::raw::c_int,
    pub m_block_read_time: PgStat_Counter,
    pub m_block_write_time: PgStat_Counter,
    pub m_entry: [PgStat_TableEntry; 8usize],
}
#[repr(C)]
pub struct PgStat_MsgTabpurge {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_nentries: ::std::os::raw::c_int,
    pub m_tableid: [Oid; 246usize],
}
#[repr(C)]
pub struct PgStat_MsgDropdb {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
}
#[repr(C)]
pub struct PgStat_MsgResetcounter {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
}
#[repr(C)]
pub struct PgStat_MsgResetsharedcounter {
    pub m_hdr: PgStat_MsgHdr,
    pub m_resettarget: PgStat_Shared_Reset_Target,
}
#[repr(C)]
pub struct PgStat_MsgResetsinglecounter {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_resettype: PgStat_Single_Reset_Type,
    pub m_objectid: Oid,
}
#[repr(C)]
pub struct PgStat_MsgAutovacStart {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_start_time: TimestampTz,
}
#[repr(C)]
pub struct PgStat_MsgVacuum {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_tableoid: Oid,
    pub m_autovacuum: bool,
    pub m_vacuumtime: TimestampTz,
    pub m_live_tuples: PgStat_Counter,
    pub m_dead_tuples: PgStat_Counter,
}
#[repr(C)]
pub struct PgStat_MsgAnalyze {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_tableoid: Oid,
    pub m_autovacuum: bool,
    pub m_resetcounter: bool,
    pub m_analyzetime: TimestampTz,
    pub m_live_tuples: PgStat_Counter,
    pub m_dead_tuples: PgStat_Counter,
}
#[repr(C)]
pub struct PgStat_MsgArchiver {
    pub m_hdr: PgStat_MsgHdr,
    pub m_failed: bool,
    pub m_xlog: [::std::os::raw::c_char; 41usize],
    pub m_timestamp: TimestampTz,
}
#[repr(C)]
pub struct PgStat_MsgBgWriter {
    pub m_hdr: PgStat_MsgHdr,
    pub m_timed_checkpoints: PgStat_Counter,
    pub m_requested_checkpoints: PgStat_Counter,
    pub m_buf_written_checkpoints: PgStat_Counter,
    pub m_buf_written_clean: PgStat_Counter,
    pub m_maxwritten_clean: PgStat_Counter,
    pub m_buf_written_backend: PgStat_Counter,
    pub m_buf_fsync_backend: PgStat_Counter,
    pub m_buf_alloc: PgStat_Counter,
    pub m_checkpoint_write_time: PgStat_Counter,
    pub m_checkpoint_sync_time: PgStat_Counter,
}
#[repr(C)]
pub struct PgStat_MsgRecoveryConflict {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_reason: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct PgStat_MsgTempFile {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_filesize: usize,
}
#[repr(C)]
pub struct PgStat_FunctionCounts {
    pub f_numcalls: PgStat_Counter,
    pub f_total_time: instr_time,
    pub f_self_time: instr_time,
}
#[repr(C)]
pub struct PgStat_BackendFunctionEntry {
    pub f_id: Oid,
    pub f_counts: PgStat_FunctionCounts,
}
#[repr(C)]
pub struct PgStat_FunctionEntry {
    pub f_id: Oid,
    pub f_numcalls: PgStat_Counter,
    pub f_total_time: PgStat_Counter,
    pub f_self_time: PgStat_Counter,
}
#[repr(C)]
pub struct PgStat_MsgFuncstat {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_nentries: ::std::os::raw::c_int,
    pub m_entry: [PgStat_FunctionEntry; 30usize],
}
#[repr(C)]
pub struct PgStat_MsgFuncpurge {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_nentries: ::std::os::raw::c_int,
    pub m_functionid: [Oid; 246usize],
}
#[repr(C)]
pub struct PgStat_MsgDeadlock {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
}
#[repr(C)]
pub struct PgStat_MsgChecksumFailure {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_failurecount: ::std::os::raw::c_int,
    pub m_failure_time: TimestampTz,
}
#[repr(C)]
pub struct PgStat_Msg {
    pub msg_hdr: __BindgenUnionField<PgStat_MsgHdr>,
    pub msg_dummy: __BindgenUnionField<PgStat_MsgDummy>,
    pub msg_inquiry: __BindgenUnionField<PgStat_MsgInquiry>,
    pub msg_tabstat: __BindgenUnionField<PgStat_MsgTabstat>,
    pub msg_tabpurge: __BindgenUnionField<PgStat_MsgTabpurge>,
    pub msg_dropdb: __BindgenUnionField<PgStat_MsgDropdb>,
    pub msg_resetcounter: __BindgenUnionField<PgStat_MsgResetcounter>,
    pub msg_resetsharedcounter: __BindgenUnionField<PgStat_MsgResetsharedcounter>,
    pub msg_resetsinglecounter: __BindgenUnionField<PgStat_MsgResetsinglecounter>,
    pub msg_autovacuum_start: __BindgenUnionField<PgStat_MsgAutovacStart>,
    pub msg_vacuum: __BindgenUnionField<PgStat_MsgVacuum>,
    pub msg_analyze: __BindgenUnionField<PgStat_MsgAnalyze>,
    pub msg_archiver: __BindgenUnionField<PgStat_MsgArchiver>,
    pub msg_bgwriter: __BindgenUnionField<PgStat_MsgBgWriter>,
    pub msg_funcstat: __BindgenUnionField<PgStat_MsgFuncstat>,
    pub msg_funcpurge: __BindgenUnionField<PgStat_MsgFuncpurge>,
    pub msg_recoveryconflict: __BindgenUnionField<PgStat_MsgRecoveryConflict>,
    pub msg_deadlock: __BindgenUnionField<PgStat_MsgDeadlock>,
    pub msg_tempfile: __BindgenUnionField<PgStat_MsgTempFile>,
    pub msg_checksumfailure: __BindgenUnionField<PgStat_MsgChecksumFailure>,
    pub bindgen_union_field: [u64; 125usize],
}
#[repr(C)]
pub struct PgStat_StatDBEntry {
    pub databaseid: Oid,
    pub n_xact_commit: PgStat_Counter,
    pub n_xact_rollback: PgStat_Counter,
    pub n_blocks_fetched: PgStat_Counter,
    pub n_blocks_hit: PgStat_Counter,
    pub n_tuples_returned: PgStat_Counter,
    pub n_tuples_fetched: PgStat_Counter,
    pub n_tuples_inserted: PgStat_Counter,
    pub n_tuples_updated: PgStat_Counter,
    pub n_tuples_deleted: PgStat_Counter,
    pub last_autovac_time: TimestampTz,
    pub n_conflict_tablespace: PgStat_Counter,
    pub n_conflict_lock: PgStat_Counter,
    pub n_conflict_snapshot: PgStat_Counter,
    pub n_conflict_bufferpin: PgStat_Counter,
    pub n_conflict_startup_deadlock: PgStat_Counter,
    pub n_temp_files: PgStat_Counter,
    pub n_temp_bytes: PgStat_Counter,
    pub n_deadlocks: PgStat_Counter,
    pub n_checksum_failures: PgStat_Counter,
    pub last_checksum_failure: TimestampTz,
    pub n_block_read_time: PgStat_Counter,
    pub n_block_write_time: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
    pub stats_timestamp: TimestampTz,
    pub tables: PgPtr<HTAB>,
    pub functions: PgPtr<HTAB>,
}
#[repr(C)]
pub struct PgStat_StatTabEntry {
    pub tableid: Oid,
    pub numscans: PgStat_Counter,
    pub tuples_returned: PgStat_Counter,
    pub tuples_fetched: PgStat_Counter,
    pub tuples_inserted: PgStat_Counter,
    pub tuples_updated: PgStat_Counter,
    pub tuples_deleted: PgStat_Counter,
    pub tuples_hot_updated: PgStat_Counter,
    pub n_live_tuples: PgStat_Counter,
    pub n_dead_tuples: PgStat_Counter,
    pub changes_since_analyze: PgStat_Counter,
    pub blocks_fetched: PgStat_Counter,
    pub blocks_hit: PgStat_Counter,
    pub vacuum_timestamp: TimestampTz,
    pub vacuum_count: PgStat_Counter,
    pub autovac_vacuum_timestamp: TimestampTz,
    pub autovac_vacuum_count: PgStat_Counter,
    pub analyze_timestamp: TimestampTz,
    pub analyze_count: PgStat_Counter,
    pub autovac_analyze_timestamp: TimestampTz,
    pub autovac_analyze_count: PgStat_Counter,
}
#[repr(C)]
pub struct PgStat_StatFuncEntry {
    pub functionid: Oid,
    pub f_numcalls: PgStat_Counter,
    pub f_total_time: PgStat_Counter,
    pub f_self_time: PgStat_Counter,
}
#[repr(C)]
pub struct PgStat_ArchiverStats {
    pub archived_count: PgStat_Counter,
    pub last_archived_wal: [::std::os::raw::c_char; 41usize],
    pub last_archived_timestamp: TimestampTz,
    pub failed_count: PgStat_Counter,
    pub last_failed_wal: [::std::os::raw::c_char; 41usize],
    pub last_failed_timestamp: TimestampTz,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
pub struct PgStat_GlobalStats {
    pub stats_timestamp: TimestampTz,
    pub timed_checkpoints: PgStat_Counter,
    pub requested_checkpoints: PgStat_Counter,
    pub checkpoint_write_time: PgStat_Counter,
    pub checkpoint_sync_time: PgStat_Counter,
    pub buf_written_checkpoints: PgStat_Counter,
    pub buf_written_clean: PgStat_Counter,
    pub maxwritten_clean: PgStat_Counter,
    pub buf_written_backend: PgStat_Counter,
    pub buf_fsync_backend: PgStat_Counter,
    pub buf_alloc: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum BackendType {
    B_AUTOVAC_LAUNCHER = 0,
    B_AUTOVAC_WORKER = 1,
    B_BACKEND = 2,
    B_BG_WORKER = 3,
    B_BG_WRITER = 4,
    B_CHECKPOINTER = 5,
    B_STARTUP = 6,
    B_WAL_RECEIVER = 7,
    B_WAL_SENDER = 8,
    B_WAL_WRITER = 9,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum BackendState {
    STATE_UNDEFINED = 0,
    STATE_IDLE = 1,
    STATE_RUNNING = 2,
    STATE_IDLEINTRANSACTION = 3,
    STATE_FASTPATH = 4,
    STATE_IDLEINTRANSACTION_ABORTED = 5,
    STATE_DISABLED = 6,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum WaitEventActivity {
    WAIT_EVENT_ARCHIVER_MAIN = 83886080,
    WAIT_EVENT_AUTOVACUUM_MAIN = 83886081,
    WAIT_EVENT_BGWRITER_HIBERNATE = 83886082,
    WAIT_EVENT_BGWRITER_MAIN = 83886083,
    WAIT_EVENT_CHECKPOINTER_MAIN = 83886084,
    WAIT_EVENT_LOGICAL_APPLY_MAIN = 83886085,
    WAIT_EVENT_LOGICAL_LAUNCHER_MAIN = 83886086,
    WAIT_EVENT_PGSTAT_MAIN = 83886087,
    WAIT_EVENT_RECOVERY_WAL_ALL = 83886088,
    WAIT_EVENT_RECOVERY_WAL_STREAM = 83886089,
    WAIT_EVENT_SYSLOGGER_MAIN = 83886090,
    WAIT_EVENT_WAL_RECEIVER_MAIN = 83886091,
    WAIT_EVENT_WAL_SENDER_MAIN = 83886092,
    WAIT_EVENT_WAL_WRITER_MAIN = 83886093,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum WaitEventClient {
    WAIT_EVENT_CLIENT_READ = 100663296,
    WAIT_EVENT_CLIENT_WRITE = 100663297,
    WAIT_EVENT_LIBPQWALRECEIVER_CONNECT = 100663298,
    WAIT_EVENT_LIBPQWALRECEIVER_RECEIVE = 100663299,
    WAIT_EVENT_SSL_OPEN_SERVER = 100663300,
    WAIT_EVENT_WAL_RECEIVER_WAIT_START = 100663301,
    WAIT_EVENT_WAL_SENDER_WAIT_WAL = 100663302,
    WAIT_EVENT_WAL_SENDER_WRITE_DATA = 100663303,
    WAIT_EVENT_GSS_OPEN_SERVER = 100663304,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum WaitEventIPC {
    WAIT_EVENT_BGWORKER_SHUTDOWN = 134217728,
    WAIT_EVENT_BGWORKER_STARTUP = 134217729,
    WAIT_EVENT_BTREE_PAGE = 134217730,
    WAIT_EVENT_CLOG_GROUP_UPDATE = 134217731,
    WAIT_EVENT_CHECKPOINT_DONE = 134217732,
    WAIT_EVENT_CHECKPOINT_START = 134217733,
    WAIT_EVENT_EXECUTE_GATHER = 134217734,
    WAIT_EVENT_HASH_BATCH_ALLOCATING = 134217735,
    WAIT_EVENT_HASH_BATCH_ELECTING = 134217736,
    WAIT_EVENT_HASH_BATCH_LOADING = 134217737,
    WAIT_EVENT_HASH_BUILD_ALLOCATING = 134217738,
    WAIT_EVENT_HASH_BUILD_ELECTING = 134217739,
    WAIT_EVENT_HASH_BUILD_HASHING_INNER = 134217740,
    WAIT_EVENT_HASH_BUILD_HASHING_OUTER = 134217741,
    WAIT_EVENT_HASH_GROW_BATCHES_ALLOCATING = 134217742,
    WAIT_EVENT_HASH_GROW_BATCHES_DECIDING = 134217743,
    WAIT_EVENT_HASH_GROW_BATCHES_ELECTING = 134217744,
    WAIT_EVENT_HASH_GROW_BATCHES_FINISHING = 134217745,
    WAIT_EVENT_HASH_GROW_BATCHES_REPARTITIONING = 134217746,
    WAIT_EVENT_HASH_GROW_BUCKETS_ALLOCATING = 134217747,
    WAIT_EVENT_HASH_GROW_BUCKETS_ELECTING = 134217748,
    WAIT_EVENT_HASH_GROW_BUCKETS_REINSERTING = 134217749,
    WAIT_EVENT_LOGICAL_SYNC_DATA = 134217750,
    WAIT_EVENT_LOGICAL_SYNC_STATE_CHANGE = 134217751,
    WAIT_EVENT_MQ_INTERNAL = 134217752,
    WAIT_EVENT_MQ_PUT_MESSAGE = 134217753,
    WAIT_EVENT_MQ_RECEIVE = 134217754,
    WAIT_EVENT_MQ_SEND = 134217755,
    WAIT_EVENT_PARALLEL_BITMAP_SCAN = 134217756,
    WAIT_EVENT_PARALLEL_CREATE_INDEX_SCAN = 134217757,
    WAIT_EVENT_PARALLEL_FINISH = 134217758,
    WAIT_EVENT_PROCARRAY_GROUP_UPDATE = 134217759,
    WAIT_EVENT_PROMOTE = 134217760,
    WAIT_EVENT_REPLICATION_ORIGIN_DROP = 134217761,
    WAIT_EVENT_REPLICATION_SLOT_DROP = 134217762,
    WAIT_EVENT_SAFE_SNAPSHOT = 134217763,
    WAIT_EVENT_SYNC_REP = 134217764,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum WaitEventTimeout {
    WAIT_EVENT_BASE_BACKUP_THROTTLE = 150994944,
    WAIT_EVENT_PG_SLEEP = 150994945,
    WAIT_EVENT_RECOVERY_APPLY_DELAY = 150994946,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum WaitEventIO {
    WAIT_EVENT_BUFFILE_READ = 167772160,
    WAIT_EVENT_BUFFILE_WRITE = 167772161,
    WAIT_EVENT_CONTROL_FILE_READ = 167772162,
    WAIT_EVENT_CONTROL_FILE_SYNC = 167772163,
    WAIT_EVENT_CONTROL_FILE_SYNC_UPDATE = 167772164,
    WAIT_EVENT_CONTROL_FILE_WRITE = 167772165,
    WAIT_EVENT_CONTROL_FILE_WRITE_UPDATE = 167772166,
    WAIT_EVENT_COPY_FILE_READ = 167772167,
    WAIT_EVENT_COPY_FILE_WRITE = 167772168,
    WAIT_EVENT_DATA_FILE_EXTEND = 167772169,
    WAIT_EVENT_DATA_FILE_FLUSH = 167772170,
    WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC = 167772171,
    WAIT_EVENT_DATA_FILE_PREFETCH = 167772172,
    WAIT_EVENT_DATA_FILE_READ = 167772173,
    WAIT_EVENT_DATA_FILE_SYNC = 167772174,
    WAIT_EVENT_DATA_FILE_TRUNCATE = 167772175,
    WAIT_EVENT_DATA_FILE_WRITE = 167772176,
    WAIT_EVENT_DSM_FILL_ZERO_WRITE = 167772177,
    WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ = 167772178,
    WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC = 167772179,
    WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE = 167772180,
    WAIT_EVENT_LOCK_FILE_CREATE_READ = 167772181,
    WAIT_EVENT_LOCK_FILE_CREATE_SYNC = 167772182,
    WAIT_EVENT_LOCK_FILE_CREATE_WRITE = 167772183,
    WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ = 167772184,
    WAIT_EVENT_LOGICAL_REWRITE_CHECKPOINT_SYNC = 167772185,
    WAIT_EVENT_LOGICAL_REWRITE_MAPPING_SYNC = 167772186,
    WAIT_EVENT_LOGICAL_REWRITE_MAPPING_WRITE = 167772187,
    WAIT_EVENT_LOGICAL_REWRITE_SYNC = 167772188,
    WAIT_EVENT_LOGICAL_REWRITE_TRUNCATE = 167772189,
    WAIT_EVENT_LOGICAL_REWRITE_WRITE = 167772190,
    WAIT_EVENT_RELATION_MAP_READ = 167772191,
    WAIT_EVENT_RELATION_MAP_SYNC = 167772192,
    WAIT_EVENT_RELATION_MAP_WRITE = 167772193,
    WAIT_EVENT_REORDER_BUFFER_READ = 167772194,
    WAIT_EVENT_REORDER_BUFFER_WRITE = 167772195,
    WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ = 167772196,
    WAIT_EVENT_REPLICATION_SLOT_READ = 167772197,
    WAIT_EVENT_REPLICATION_SLOT_RESTORE_SYNC = 167772198,
    WAIT_EVENT_REPLICATION_SLOT_SYNC = 167772199,
    WAIT_EVENT_REPLICATION_SLOT_WRITE = 167772200,
    WAIT_EVENT_SLRU_FLUSH_SYNC = 167772201,
    WAIT_EVENT_SLRU_READ = 167772202,
    WAIT_EVENT_SLRU_SYNC = 167772203,
    WAIT_EVENT_SLRU_WRITE = 167772204,
    WAIT_EVENT_SNAPBUILD_READ = 167772205,
    WAIT_EVENT_SNAPBUILD_SYNC = 167772206,
    WAIT_EVENT_SNAPBUILD_WRITE = 167772207,
    WAIT_EVENT_TIMELINE_HISTORY_FILE_SYNC = 167772208,
    WAIT_EVENT_TIMELINE_HISTORY_FILE_WRITE = 167772209,
    WAIT_EVENT_TIMELINE_HISTORY_READ = 167772210,
    WAIT_EVENT_TIMELINE_HISTORY_SYNC = 167772211,
    WAIT_EVENT_TIMELINE_HISTORY_WRITE = 167772212,
    WAIT_EVENT_TWOPHASE_FILE_READ = 167772213,
    WAIT_EVENT_TWOPHASE_FILE_SYNC = 167772214,
    WAIT_EVENT_TWOPHASE_FILE_WRITE = 167772215,
    WAIT_EVENT_WALSENDER_TIMELINE_HISTORY_READ = 167772216,
    WAIT_EVENT_WAL_BOOTSTRAP_SYNC = 167772217,
    WAIT_EVENT_WAL_BOOTSTRAP_WRITE = 167772218,
    WAIT_EVENT_WAL_COPY_READ = 167772219,
    WAIT_EVENT_WAL_COPY_SYNC = 167772220,
    WAIT_EVENT_WAL_COPY_WRITE = 167772221,
    WAIT_EVENT_WAL_INIT_SYNC = 167772222,
    WAIT_EVENT_WAL_INIT_WRITE = 167772223,
    WAIT_EVENT_WAL_READ = 167772224,
    WAIT_EVENT_WAL_SYNC = 167772225,
    WAIT_EVENT_WAL_SYNC_METHOD_ASSIGN = 167772226,
    WAIT_EVENT_WAL_WRITE = 167772227,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ProgressCommandType {
    PROGRESS_COMMAND_INVALID = 0,
    PROGRESS_COMMAND_VACUUM = 1,
    PROGRESS_COMMAND_CLUSTER = 2,
    PROGRESS_COMMAND_CREATE_INDEX = 3,
}
#[repr(C)]
pub struct PgBackendSSLStatus {
    pub ssl_bits: ::std::os::raw::c_int,
    pub ssl_compression: bool,
    pub ssl_version: [::std::os::raw::c_char; 64usize],
    pub ssl_cipher: [::std::os::raw::c_char; 64usize],
    pub ssl_client_dn: [::std::os::raw::c_char; 64usize],
    pub ssl_client_serial: [::std::os::raw::c_char; 64usize],
    pub ssl_issuer_dn: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
pub struct PgBackendGSSStatus {
    pub gss_princ: [::std::os::raw::c_char; 64usize],
    pub gss_auth: bool,
    pub gss_enc: bool,
}
#[repr(C)]
pub struct PgBackendStatus {
    pub st_changecount: ::std::os::raw::c_int,
    pub st_procpid: ::std::os::raw::c_int,
    pub st_backendType: BackendType,
    pub st_proc_start_timestamp: TimestampTz,
    pub st_xact_start_timestamp: TimestampTz,
    pub st_activity_start_timestamp: TimestampTz,
    pub st_state_start_timestamp: TimestampTz,
    pub st_databaseid: Oid,
    pub st_userid: Oid,
    pub st_clientaddr: SockAddr,
    pub st_clienthostname: PgPtr<::std::os::raw::c_char>,
    pub st_ssl: bool,
    pub st_sslstatus: PgPtr<PgBackendSSLStatus>,
    pub st_gss: bool,
    pub st_gssstatus: PgPtr<PgBackendGSSStatus>,
    pub st_state: BackendState,
    pub st_appname: PgPtr<::std::os::raw::c_char>,
    pub st_activity_raw: PgPtr<::std::os::raw::c_char>,
    pub st_progress_command: ProgressCommandType,
    pub st_progress_command_target: Oid,
    pub st_progress_param: [int64; 20usize],
}
#[repr(C)]
pub struct LocalPgBackendStatus {
    pub backendStatus: PgBackendStatus,
    pub backend_xid: TransactionId,
    pub backend_xmin: TransactionId,
}
#[repr(C)]
pub struct PgStat_FunctionCallUsage {
    pub fs: PgPtr<PgStat_FunctionCounts>,
    pub save_f_total_time: instr_time,
    pub save_total: instr_time,
    pub f_start: instr_time,
}
#[pg_guard]
extern "C" {
    pub static mut pgstat_track_activities: bool;
}
#[pg_guard]
extern "C" {
    pub static mut pgstat_track_counts: bool;
}
#[pg_guard]
extern "C" {
    pub static mut pgstat_track_functions: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut pgstat_track_activity_query_size: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut pgstat_stat_directory: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut pgstat_stat_tmpname: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut pgstat_stat_filename: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut BgWriterStats: PgStat_MsgBgWriter;
}
#[pg_guard]
extern "C" {
    pub static mut pgStatBlockReadTime: PgStat_Counter;
}
#[pg_guard]
extern "C" {
    pub static mut pgStatBlockWriteTime: PgStat_Counter;
}
#[pg_guard]
extern "C" {
    pub fn BackendStatusShmemSize() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn CreateSharedBackendStatus();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_init();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_start() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_reset_all();
}
#[pg_guard]
extern "C" {
    pub fn allow_immediate_pgstat_restart();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_ping();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_report_stat(force: bool);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_vacuum_stat();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_drop_database(databaseid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_clear_snapshot();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_reset_counters();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_reset_shared_counters(arg1: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_reset_single_counter(objectid: Oid, type_: PgStat_Single_Reset_Type);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_report_autovac(dboid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_report_vacuum(
        tableoid: Oid,
        shared: bool,
        livetuples: PgStat_Counter,
        deadtuples: PgStat_Counter,
    );
}
#[pg_guard]
extern "C" {
    pub fn pgstat_report_analyze(
        rel: PgPtr<RelationData>,
        livetuples: PgStat_Counter,
        deadtuples: PgStat_Counter,
        resetcounter: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn pgstat_report_recovery_conflict(reason: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_report_deadlock();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_report_checksum_failures_in_db(dboid: Oid, failurecount: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_report_checksum_failure();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_initialize();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_bestart();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_report_activity(state: BackendState, cmd_str: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_report_tempfile(filesize: usize);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_report_appname(appname: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_report_xact_timestamp(tstamp: TimestampTz);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_get_wait_event(wait_event_info: uint32) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_get_wait_event_type(wait_event_info: uint32) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_get_backend_current_activity(
        pid: ::std::os::raw::c_int,
        checkUser: bool,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_get_crashed_backend_activity(
        pid: ::std::os::raw::c_int,
        buffer: PgPtr<::std::os::raw::c_char>,
        buflen: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_get_backend_desc(backendType: BackendType) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_progress_start_command(cmdtype: ProgressCommandType, relid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_progress_update_param(index: ::std::os::raw::c_int, val: int64);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_progress_update_multi_param(
        nparam: ::std::os::raw::c_int,
        index: PgPtr<::std::os::raw::c_int>,
        val: PgPtr<int64>,
    );
}
#[pg_guard]
extern "C" {
    pub fn pgstat_progress_end_command();
}
#[pg_guard]
extern "C" {
    pub fn find_tabstat_entry(rel_id: Oid) -> PgPtr<PgStat_TableStatus>;
}
#[pg_guard]
extern "C" {
    pub fn find_funcstat_entry(func_id: Oid) -> PgPtr<PgStat_BackendFunctionEntry>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_initstats(rel: PgPtr<RelationData>);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_clip_activity(
        raw_activity: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_count_heap_insert(rel: PgPtr<RelationData>, n: PgStat_Counter);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_count_heap_update(rel: PgPtr<RelationData>, hot: bool);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_count_heap_delete(rel: PgPtr<RelationData>);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_count_truncate(rel: PgPtr<RelationData>);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_update_heap_dead_tuples(rel: PgPtr<RelationData>, delta: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_init_function_usage(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
        fcu: PgPtr<PgStat_FunctionCallUsage>,
    );
}
#[pg_guard]
extern "C" {
    pub fn pgstat_end_function_usage(fcu: PgPtr<PgStat_FunctionCallUsage>, finalize: bool);
}
#[pg_guard]
extern "C" {
    pub fn AtEOXact_PgStat(isCommit: bool, parallel: bool);
}
#[pg_guard]
extern "C" {
    pub fn AtEOSubXact_PgStat(isCommit: bool, nestDepth: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn AtPrepare_PgStat();
}
#[pg_guard]
extern "C" {
    pub fn PostPrepare_PgStat();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_twophase_postcommit(
        xid: TransactionId,
        info: uint16,
        recdata: PgPtr<::std::os::raw::c_void>,
        len: uint32,
    );
}
#[pg_guard]
extern "C" {
    pub fn pgstat_twophase_postabort(
        xid: TransactionId,
        info: uint16,
        recdata: PgPtr<::std::os::raw::c_void>,
        len: uint32,
    );
}
#[pg_guard]
extern "C" {
    pub fn pgstat_send_archiver(xlog: PgPtr<::std::os::raw::c_char>, failed: bool);
}
#[pg_guard]
extern "C" {
    pub fn pgstat_send_bgwriter();
}
#[pg_guard]
extern "C" {
    pub fn pgstat_fetch_stat_dbentry(dbid: Oid) -> PgPtr<PgStat_StatDBEntry>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_fetch_stat_tabentry(relid: Oid) -> PgPtr<PgStat_StatTabEntry>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_fetch_stat_beentry(beid: ::std::os::raw::c_int) -> PgPtr<PgBackendStatus>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_fetch_stat_local_beentry(
        beid: ::std::os::raw::c_int,
    ) -> PgPtr<LocalPgBackendStatus>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_fetch_stat_funcentry(funcid: Oid) -> PgPtr<PgStat_StatFuncEntry>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_fetch_stat_numbackends() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_fetch_stat_archiver() -> PgPtr<PgStat_ArchiverStats>;
}
#[pg_guard]
extern "C" {
    pub fn pgstat_fetch_global() -> PgPtr<PgStat_GlobalStats>;
}
#[repr(C)]
pub struct ScanKeyData {
    pub sk_flags: ::std::os::raw::c_int,
    pub sk_attno: AttrNumber,
    pub sk_strategy: StrategyNumber,
    pub sk_subtype: Oid,
    pub sk_collation: Oid,
    pub sk_func: FmgrInfo,
    pub sk_argument: Datum,
}
pub type ScanKey = PgPtr<ScanKeyData>;
#[pg_guard]
extern "C" {
    pub fn ScanKeyInit(
        entry: PgPtr<ScanKeyData>,
        attributeNumber: AttrNumber,
        strategy: StrategyNumber,
        procedure: RegProcedure,
        argument: Datum,
    );
}
#[pg_guard]
extern "C" {
    pub fn ScanKeyEntryInitialize(
        entry: PgPtr<ScanKeyData>,
        flags: ::std::os::raw::c_int,
        attributeNumber: AttrNumber,
        strategy: StrategyNumber,
        subtype: Oid,
        collation: Oid,
        procedure: RegProcedure,
        argument: Datum,
    );
}
#[pg_guard]
extern "C" {
    pub fn ScanKeyEntryInitializeWithInfo(
        entry: PgPtr<ScanKeyData>,
        flags: ::std::os::raw::c_int,
        attributeNumber: AttrNumber,
        strategy: StrategyNumber,
        subtype: Oid,
        collation: Oid,
        finfo: PgPtr<FmgrInfo>,
        argument: Datum,
    );
}
#[repr(C)]
pub struct IndexBuildResult {
    pub heap_tuples: f64,
    pub index_tuples: f64,
}
#[repr(C)]
pub struct IndexVacuumInfo {
    pub index: PgPtr<RelationData>,
    pub analyze_only: bool,
    pub report_progress: bool,
    pub estimated_count: bool,
    pub message_level: ::std::os::raw::c_int,
    pub num_heap_tuples: f64,
    pub strategy: PgPtr<BufferAccessStrategyData>,
}
#[repr(C)]
pub struct IndexBulkDeleteResult {
    pub num_pages: BlockNumber,
    pub pages_removed: BlockNumber,
    pub estimated_count: bool,
    pub num_index_tuples: f64,
    pub tuples_removed: f64,
    pub pages_deleted: BlockNumber,
    pub pages_free: BlockNumber,
}
pub type IndexBulkDeleteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        itemptr: PgPtr<ItemPointerData>,
        state: PgPtr<::std::os::raw::c_void>,
    ) -> bool,
>;
pub type IndexScanDesc = PgPtr<IndexScanDescData>;
pub type SysScanDesc = PgPtr<SysScanDescData>;
pub type ParallelIndexScanDesc = PgPtr<ParallelIndexScanDescData>;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum IndexUniqueCheck {
    UNIQUE_CHECK_NO = 0,
    UNIQUE_CHECK_YES = 1,
    UNIQUE_CHECK_PARTIAL = 2,
    UNIQUE_CHECK_EXISTING = 3,
}
#[repr(C)]
pub struct IndexOrderByDistance {
    pub value: f64,
    pub isnull: bool,
}
#[pg_guard]
extern "C" {
    pub fn index_open(relationId: Oid, lockmode: LOCKMODE) -> PgPtr<RelationData>;
}
#[pg_guard]
extern "C" {
    pub fn index_close(relation: PgPtr<RelationData>, lockmode: LOCKMODE);
}
#[pg_guard]
extern "C" {
    pub fn index_insert(
        indexRelation: PgPtr<RelationData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
        heap_t_ctid: PgPtr<ItemPointerData>,
        heapRelation: PgPtr<RelationData>,
        checkUnique: IndexUniqueCheck,
        indexInfo: PgPtr<IndexInfo>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn index_beginscan(
        heapRelation: PgPtr<RelationData>,
        indexRelation: PgPtr<RelationData>,
        snapshot: PgPtr<SnapshotData>,
        nkeys: ::std::os::raw::c_int,
        norderbys: ::std::os::raw::c_int,
    ) -> PgPtr<IndexScanDescData>;
}
#[pg_guard]
extern "C" {
    pub fn index_beginscan_bitmap(
        indexRelation: PgPtr<RelationData>,
        snapshot: PgPtr<SnapshotData>,
        nkeys: ::std::os::raw::c_int,
    ) -> PgPtr<IndexScanDescData>;
}
#[pg_guard]
extern "C" {
    pub fn index_rescan(
        scan: PgPtr<IndexScanDescData>,
        keys: PgPtr<ScanKeyData>,
        nkeys: ::std::os::raw::c_int,
        orderbys: PgPtr<ScanKeyData>,
        norderbys: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn index_endscan(scan: PgPtr<IndexScanDescData>);
}
#[pg_guard]
extern "C" {
    pub fn index_markpos(scan: PgPtr<IndexScanDescData>);
}
#[pg_guard]
extern "C" {
    pub fn index_restrpos(scan: PgPtr<IndexScanDescData>);
}
#[pg_guard]
extern "C" {
    pub fn index_parallelscan_estimate(
        indexrel: PgPtr<RelationData>,
        snapshot: PgPtr<SnapshotData>,
    ) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn index_parallelscan_initialize(
        heaprel: PgPtr<RelationData>,
        indexrel: PgPtr<RelationData>,
        snapshot: PgPtr<SnapshotData>,
        target: PgPtr<ParallelIndexScanDescData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn index_parallelrescan(scan: PgPtr<IndexScanDescData>);
}
#[pg_guard]
extern "C" {
    pub fn index_beginscan_parallel(
        heaprel: PgPtr<RelationData>,
        indexrel: PgPtr<RelationData>,
        nkeys: ::std::os::raw::c_int,
        norderbys: ::std::os::raw::c_int,
        pscan: PgPtr<ParallelIndexScanDescData>,
    ) -> PgPtr<IndexScanDescData>;
}
#[pg_guard]
extern "C" {
    pub fn index_getnext_tid(
        scan: PgPtr<IndexScanDescData>,
        direction: ScanDirection,
    ) -> PgPtr<ItemPointerData>;
}
#[pg_guard]
extern "C" {
    pub fn index_fetch_heap(scan: PgPtr<IndexScanDescData>, slot: PgPtr<TupleTableSlot>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn index_getnext_slot(
        scan: PgPtr<IndexScanDescData>,
        direction: ScanDirection,
        slot: PgPtr<TupleTableSlot>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn index_getbitmap(scan: PgPtr<IndexScanDescData>, bitmap: PgPtr<TIDBitmap>) -> int64;
}
#[pg_guard]
extern "C" {
    pub fn index_bulk_delete(
        info: PgPtr<IndexVacuumInfo>,
        stats: PgPtr<IndexBulkDeleteResult>,
        callback: IndexBulkDeleteCallback,
        callback_state: PgPtr<::std::os::raw::c_void>,
    ) -> PgPtr<IndexBulkDeleteResult>;
}
#[pg_guard]
extern "C" {
    pub fn index_vacuum_cleanup(
        info: PgPtr<IndexVacuumInfo>,
        stats: PgPtr<IndexBulkDeleteResult>,
    ) -> PgPtr<IndexBulkDeleteResult>;
}
#[pg_guard]
extern "C" {
    pub fn index_can_return(
        indexRelation: PgPtr<RelationData>,
        attno: ::std::os::raw::c_int,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn index_getprocid(
        irel: PgPtr<RelationData>,
        attnum: AttrNumber,
        procnum: uint16,
    ) -> RegProcedure;
}
#[pg_guard]
extern "C" {
    pub fn index_getprocinfo(
        irel: PgPtr<RelationData>,
        attnum: AttrNumber,
        procnum: uint16,
    ) -> PgPtr<FmgrInfo>;
}
#[pg_guard]
extern "C" {
    pub fn index_store_float8_orderby_distances(
        scan: PgPtr<IndexScanDescData>,
        orderByTypes: PgPtr<Oid>,
        distances: PgPtr<IndexOrderByDistance>,
        recheckOrderBy: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn RelationGetIndexScan(
        indexRelation: PgPtr<RelationData>,
        nkeys: ::std::os::raw::c_int,
        norderbys: ::std::os::raw::c_int,
    ) -> PgPtr<IndexScanDescData>;
}
#[pg_guard]
extern "C" {
    pub fn IndexScanEnd(scan: PgPtr<IndexScanDescData>);
}
#[pg_guard]
extern "C" {
    pub fn BuildIndexValueDescription(
        indexRelation: PgPtr<RelationData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn index_compute_xid_horizon_for_tuples(
        irel: PgPtr<RelationData>,
        hrel: PgPtr<RelationData>,
        ibuf: Buffer,
        itemnos: PgPtr<OffsetNumber>,
        nitems: ::std::os::raw::c_int,
    ) -> TransactionId;
}
#[pg_guard]
extern "C" {
    pub fn systable_beginscan(
        heapRelation: PgPtr<RelationData>,
        indexId: Oid,
        indexOK: bool,
        snapshot: PgPtr<SnapshotData>,
        nkeys: ::std::os::raw::c_int,
        key: PgPtr<ScanKeyData>,
    ) -> PgPtr<SysScanDescData>;
}
#[pg_guard]
extern "C" {
    pub fn systable_getnext(sysscan: PgPtr<SysScanDescData>) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn systable_recheck_tuple(
        sysscan: PgPtr<SysScanDescData>,
        tup: PgPtr<HeapTupleData>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn systable_endscan(sysscan: PgPtr<SysScanDescData>);
}
#[pg_guard]
extern "C" {
    pub fn systable_beginscan_ordered(
        heapRelation: PgPtr<RelationData>,
        indexRelation: PgPtr<RelationData>,
        snapshot: PgPtr<SnapshotData>,
        nkeys: ::std::os::raw::c_int,
        key: PgPtr<ScanKeyData>,
    ) -> PgPtr<SysScanDescData>;
}
#[pg_guard]
extern "C" {
    pub fn systable_getnext_ordered(
        sysscan: PgPtr<SysScanDescData>,
        direction: ScanDirection,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn systable_endscan_ordered(sysscan: PgPtr<SysScanDescData>);
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum IndexAMProperty {
    AMPROP_UNKNOWN = 0,
    AMPROP_ASC = 1,
    AMPROP_DESC = 2,
    AMPROP_NULLS_FIRST = 3,
    AMPROP_NULLS_LAST = 4,
    AMPROP_ORDERABLE = 5,
    AMPROP_DISTANCE_ORDERABLE = 6,
    AMPROP_RETURNABLE = 7,
    AMPROP_SEARCH_ARRAY = 8,
    AMPROP_SEARCH_NULLS = 9,
    AMPROP_CLUSTERABLE = 10,
    AMPROP_INDEX_SCAN = 11,
    AMPROP_BITMAP_SCAN = 12,
    AMPROP_BACKWARD_SCAN = 13,
    AMPROP_CAN_ORDER = 14,
    AMPROP_CAN_UNIQUE = 15,
    AMPROP_CAN_MULTI_COL = 16,
    AMPROP_CAN_EXCLUDE = 17,
    AMPROP_CAN_INCLUDE = 18,
}
pub type ambuild_function = ::std::option::Option<
    unsafe extern "C" fn(
        heapRelation: PgPtr<RelationData>,
        indexRelation: PgPtr<RelationData>,
        indexInfo: PgPtr<IndexInfo>,
    ) -> PgPtr<IndexBuildResult>,
>;
pub type ambuildempty_function =
    ::std::option::Option<unsafe extern "C" fn(indexRelation: PgPtr<RelationData>)>;
pub type aminsert_function = ::std::option::Option<
    unsafe extern "C" fn(
        indexRelation: PgPtr<RelationData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
        heap_tid: PgPtr<ItemPointerData>,
        heapRelation: PgPtr<RelationData>,
        checkUnique: IndexUniqueCheck,
        indexInfo: PgPtr<IndexInfo>,
    ) -> bool,
>;
pub type ambulkdelete_function = ::std::option::Option<
    unsafe extern "C" fn(
        info: PgPtr<IndexVacuumInfo>,
        stats: PgPtr<IndexBulkDeleteResult>,
        callback: IndexBulkDeleteCallback,
        callback_state: PgPtr<::std::os::raw::c_void>,
    ) -> PgPtr<IndexBulkDeleteResult>,
>;
pub type amvacuumcleanup_function = ::std::option::Option<
    unsafe extern "C" fn(
        info: PgPtr<IndexVacuumInfo>,
        stats: PgPtr<IndexBulkDeleteResult>,
    ) -> PgPtr<IndexBulkDeleteResult>,
>;
pub type amcanreturn_function = ::std::option::Option<
    unsafe extern "C" fn(indexRelation: PgPtr<RelationData>, attno: ::std::os::raw::c_int) -> bool,
>;
pub type amcostestimate_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        path: PgPtr<IndexPath>,
        loop_count: f64,
        indexStartupCost: PgPtr<Cost>,
        indexTotalCost: PgPtr<Cost>,
        indexSelectivity: PgPtr<Selectivity>,
        indexCorrelation: PgPtr<f64>,
        indexPages: PgPtr<f64>,
    ),
>;
pub type amoptions_function =
    ::std::option::Option<unsafe extern "C" fn(reloptions: Datum, validate: bool) -> PgPtr<bytea>>;
pub type amproperty_function = ::std::option::Option<
    unsafe extern "C" fn(
        index_oid: Oid,
        attno: ::std::os::raw::c_int,
        prop: IndexAMProperty,
        propname: PgPtr<::std::os::raw::c_char>,
        res: PgPtr<bool>,
        isnull: PgPtr<bool>,
    ) -> bool,
>;
pub type ambuildphasename_function =
    ::std::option::Option<unsafe extern "C" fn(phasenum: int64) -> PgPtr<::std::os::raw::c_char>>;
pub type amvalidate_function = ::std::option::Option<unsafe extern "C" fn(opclassoid: Oid) -> bool>;
pub type ambeginscan_function = ::std::option::Option<
    unsafe extern "C" fn(
        indexRelation: PgPtr<RelationData>,
        nkeys: ::std::os::raw::c_int,
        norderbys: ::std::os::raw::c_int,
    ) -> PgPtr<IndexScanDescData>,
>;
pub type amrescan_function = ::std::option::Option<
    unsafe extern "C" fn(
        scan: PgPtr<IndexScanDescData>,
        keys: PgPtr<ScanKeyData>,
        nkeys: ::std::os::raw::c_int,
        orderbys: PgPtr<ScanKeyData>,
        norderbys: ::std::os::raw::c_int,
    ),
>;
pub type amgettuple_function = ::std::option::Option<
    unsafe extern "C" fn(scan: PgPtr<IndexScanDescData>, direction: ScanDirection) -> bool,
>;
pub type amgetbitmap_function = ::std::option::Option<
    unsafe extern "C" fn(scan: PgPtr<IndexScanDescData>, tbm: PgPtr<TIDBitmap>) -> int64,
>;
pub type amendscan_function =
    ::std::option::Option<unsafe extern "C" fn(scan: PgPtr<IndexScanDescData>)>;
pub type ammarkpos_function =
    ::std::option::Option<unsafe extern "C" fn(scan: PgPtr<IndexScanDescData>)>;
pub type amrestrpos_function =
    ::std::option::Option<unsafe extern "C" fn(scan: PgPtr<IndexScanDescData>)>;
pub type amestimateparallelscan_function = ::std::option::Option<unsafe extern "C" fn() -> Size>;
pub type aminitparallelscan_function =
    ::std::option::Option<unsafe extern "C" fn(target: PgPtr<::std::os::raw::c_void>)>;
pub type amparallelrescan_function =
    ::std::option::Option<unsafe extern "C" fn(scan: PgPtr<IndexScanDescData>)>;
#[repr(C)]
pub struct IndexAmRoutine {
    pub type_: NodeTag,
    pub amstrategies: uint16,
    pub amsupport: uint16,
    pub amcanorder: bool,
    pub amcanorderbyop: bool,
    pub amcanbackward: bool,
    pub amcanunique: bool,
    pub amcanmulticol: bool,
    pub amoptionalkey: bool,
    pub amsearcharray: bool,
    pub amsearchnulls: bool,
    pub amstorage: bool,
    pub amclusterable: bool,
    pub ampredlocks: bool,
    pub amcanparallel: bool,
    pub amcaninclude: bool,
    pub amkeytype: Oid,
    pub ambuild: ambuild_function,
    pub ambuildempty: ambuildempty_function,
    pub aminsert: aminsert_function,
    pub ambulkdelete: ambulkdelete_function,
    pub amvacuumcleanup: amvacuumcleanup_function,
    pub amcanreturn: amcanreturn_function,
    pub amcostestimate: amcostestimate_function,
    pub amoptions: amoptions_function,
    pub amproperty: amproperty_function,
    pub ambuildphasename: ambuildphasename_function,
    pub amvalidate: amvalidate_function,
    pub ambeginscan: ambeginscan_function,
    pub amrescan: amrescan_function,
    pub amgettuple: amgettuple_function,
    pub amgetbitmap: amgetbitmap_function,
    pub amendscan: amendscan_function,
    pub ammarkpos: ammarkpos_function,
    pub amrestrpos: amrestrpos_function,
    pub amestimateparallelscan: amestimateparallelscan_function,
    pub aminitparallelscan: aminitparallelscan_function,
    pub amparallelrescan: amparallelrescan_function,
}
#[pg_guard]
extern "C" {
    pub fn GetIndexAmRoutine(amhandler: Oid) -> PgPtr<IndexAmRoutine>;
}
#[pg_guard]
extern "C" {
    pub fn GetIndexAmRoutineByAmId(amoid: Oid, noerror: bool) -> PgPtr<IndexAmRoutine>;
}
#[pg_guard]
extern "C" {
    pub fn relation_open(relationId: Oid, lockmode: LOCKMODE) -> PgPtr<RelationData>;
}
#[pg_guard]
extern "C" {
    pub fn try_relation_open(relationId: Oid, lockmode: LOCKMODE) -> PgPtr<RelationData>;
}
#[pg_guard]
extern "C" {
    pub fn relation_openrv(relation: PgPtr<RangeVar>, lockmode: LOCKMODE) -> PgPtr<RelationData>;
}
#[pg_guard]
extern "C" {
    pub fn relation_openrv_extended(
        relation: PgPtr<RangeVar>,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> PgPtr<RelationData>;
}
#[pg_guard]
extern "C" {
    pub fn relation_close(relation: PgPtr<RelationData>, lockmode: LOCKMODE);
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum relopt_type {
    RELOPT_TYPE_BOOL = 0,
    RELOPT_TYPE_INT = 1,
    RELOPT_TYPE_REAL = 2,
    RELOPT_TYPE_STRING = 3,
}
impl relopt_kind {
    pub const RELOPT_KIND_LAST_DEFAULT: relopt_kind = relopt_kind::RELOPT_KIND_PARTITIONED;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum relopt_kind {
    RELOPT_KIND_HEAP = 1,
    RELOPT_KIND_TOAST = 2,
    RELOPT_KIND_BTREE = 4,
    RELOPT_KIND_HASH = 8,
    RELOPT_KIND_GIN = 16,
    RELOPT_KIND_GIST = 32,
    RELOPT_KIND_ATTRIBUTE = 64,
    RELOPT_KIND_TABLESPACE = 128,
    RELOPT_KIND_SPGIST = 256,
    RELOPT_KIND_VIEW = 512,
    RELOPT_KIND_BRIN = 1024,
    RELOPT_KIND_PARTITIONED = 2048,
    RELOPT_KIND_MAX = 1073741824,
}
#[repr(C)]
pub struct relopt_gen {
    pub name: PgPtr<::std::os::raw::c_char>,
    pub desc: PgPtr<::std::os::raw::c_char>,
    pub kinds: bits32,
    pub lockmode: LOCKMODE,
    pub namelen: ::std::os::raw::c_int,
    pub type_: relopt_type,
}
#[repr(C)]
pub struct relopt_value {
    pub gen: PgPtr<relopt_gen>,
    pub isset: bool,
    pub values: relopt_value__bindgen_ty_1,
}
#[repr(C)]
pub struct relopt_value__bindgen_ty_1 {
    pub bool_val: __BindgenUnionField<bool>,
    pub int_val: __BindgenUnionField<::std::os::raw::c_int>,
    pub real_val: __BindgenUnionField<f64>,
    pub string_val: __BindgenUnionField<PgPtr<::std::os::raw::c_char>>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
pub struct relopt_bool {
    pub gen: relopt_gen,
    pub default_val: bool,
}
#[repr(C)]
pub struct relopt_int {
    pub gen: relopt_gen,
    pub default_val: ::std::os::raw::c_int,
    pub min: ::std::os::raw::c_int,
    pub max: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct relopt_real {
    pub gen: relopt_gen,
    pub default_val: f64,
    pub min: f64,
    pub max: f64,
}
pub type validate_string_relopt =
    ::std::option::Option<unsafe extern "C" fn(value: PgPtr<::std::os::raw::c_char>)>;
#[repr(C)]
pub struct relopt_string {
    pub gen: relopt_gen,
    pub default_len: ::std::os::raw::c_int,
    pub default_isnull: bool,
    pub validate_cb: validate_string_relopt,
    pub default_val: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct relopt_parse_elt {
    pub optname: PgPtr<::std::os::raw::c_char>,
    pub opttype: relopt_type,
    pub offset: ::std::os::raw::c_int,
}
#[pg_guard]
extern "C" {
    pub fn add_reloption_kind() -> relopt_kind;
}
#[pg_guard]
extern "C" {
    pub fn add_bool_reloption(
        kinds: bits32,
        name: PgPtr<::std::os::raw::c_char>,
        desc: PgPtr<::std::os::raw::c_char>,
        default_val: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn add_int_reloption(
        kinds: bits32,
        name: PgPtr<::std::os::raw::c_char>,
        desc: PgPtr<::std::os::raw::c_char>,
        default_val: ::std::os::raw::c_int,
        min_val: ::std::os::raw::c_int,
        max_val: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn add_real_reloption(
        kinds: bits32,
        name: PgPtr<::std::os::raw::c_char>,
        desc: PgPtr<::std::os::raw::c_char>,
        default_val: f64,
        min_val: f64,
        max_val: f64,
    );
}
#[pg_guard]
extern "C" {
    pub fn add_string_reloption(
        kinds: bits32,
        name: PgPtr<::std::os::raw::c_char>,
        desc: PgPtr<::std::os::raw::c_char>,
        default_val: PgPtr<::std::os::raw::c_char>,
        validator: validate_string_relopt,
    );
}
#[pg_guard]
extern "C" {
    pub fn transformRelOptions(
        oldOptions: Datum,
        defList: PgPtr<List>,
        namspace: PgPtr<::std::os::raw::c_char>,
        validnsps: PgPtr<PgPtr<::std::os::raw::c_char>>,
        acceptOidsOff: bool,
        isReset: bool,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn untransformRelOptions(options: Datum) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn extractRelOptions(
        tuple: PgPtr<HeapTupleData>,
        tupdesc: PgPtr<TupleDescData>,
        amoptions: amoptions_function,
    ) -> PgPtr<bytea>;
}
#[pg_guard]
extern "C" {
    pub fn parseRelOptions(
        options: Datum,
        validate: bool,
        kind: relopt_kind,
        numrelopts: PgPtr<::std::os::raw::c_int>,
    ) -> PgPtr<relopt_value>;
}
#[pg_guard]
extern "C" {
    pub fn allocateReloptStruct(
        base: Size,
        options: PgPtr<relopt_value>,
        numoptions: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn fillRelOptions(
        rdopts: PgPtr<::std::os::raw::c_void>,
        basesize: Size,
        options: PgPtr<relopt_value>,
        numoptions: ::std::os::raw::c_int,
        validate: bool,
        elems: PgPtr<relopt_parse_elt>,
        nelems: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn default_reloptions(reloptions: Datum, validate: bool, kind: relopt_kind)
        -> PgPtr<bytea>;
}
#[pg_guard]
extern "C" {
    pub fn heap_reloptions(
        relkind: ::std::os::raw::c_char,
        reloptions: Datum,
        validate: bool,
    ) -> PgPtr<bytea>;
}
#[pg_guard]
extern "C" {
    pub fn view_reloptions(reloptions: Datum, validate: bool) -> PgPtr<bytea>;
}
#[pg_guard]
extern "C" {
    pub fn index_reloptions(
        amoptions: amoptions_function,
        reloptions: Datum,
        validate: bool,
    ) -> PgPtr<bytea>;
}
#[pg_guard]
extern "C" {
    pub fn attribute_reloptions(reloptions: Datum, validate: bool) -> PgPtr<bytea>;
}
#[pg_guard]
extern "C" {
    pub fn tablespace_reloptions(reloptions: Datum, validate: bool) -> PgPtr<bytea>;
}
#[pg_guard]
extern "C" {
    pub fn AlterTableGetRelOptionsLockLevel(defList: PgPtr<List>) -> LOCKMODE;
}
#[repr(C)]
pub struct TableScanDescData {
    pub rs_rd: PgPtr<RelationData>,
    pub rs_snapshot: PgPtr<SnapshotData>,
    pub rs_nkeys: ::std::os::raw::c_int,
    pub rs_key: PgPtr<ScanKeyData>,
    pub rs_flags: uint32,
    pub rs_parallel: PgPtr<ParallelTableScanDescData>,
}
pub type TableScanDesc = PgPtr<TableScanDescData>;
#[repr(C)]
pub struct ParallelTableScanDescData {
    pub phs_relid: Oid,
    pub phs_syncscan: bool,
    pub phs_snapshot_any: bool,
    pub phs_snapshot_off: Size,
}
pub type ParallelTableScanDesc = PgPtr<ParallelTableScanDescData>;
#[repr(C)]
pub struct ParallelBlockTableScanDescData {
    pub base: ParallelTableScanDescData,
    pub phs_nblocks: BlockNumber,
    pub phs_mutex: slock_t,
    pub phs_startblock: BlockNumber,
    pub phs_nallocated: pg_atomic_uint64,
}
pub type ParallelBlockTableScanDesc = PgPtr<ParallelBlockTableScanDescData>;
#[repr(C)]
pub struct IndexFetchTableData {
    pub rel: PgPtr<RelationData>,
}
#[repr(C)]
pub struct IndexScanDescData {
    pub heapRelation: PgPtr<RelationData>,
    pub indexRelation: PgPtr<RelationData>,
    pub xs_snapshot: PgPtr<SnapshotData>,
    pub numberOfKeys: ::std::os::raw::c_int,
    pub numberOfOrderBys: ::std::os::raw::c_int,
    pub keyData: PgPtr<ScanKeyData>,
    pub orderByData: PgPtr<ScanKeyData>,
    pub xs_want_itup: bool,
    pub xs_temp_snap: bool,
    pub kill_prior_tuple: bool,
    pub ignore_killed_tuples: bool,
    pub xactStartedInRecovery: bool,
    pub opaque: PgPtr<::std::os::raw::c_void>,
    pub xs_itup: PgPtr<IndexTupleData>,
    pub xs_itupdesc: PgPtr<TupleDescData>,
    pub xs_hitup: PgPtr<HeapTupleData>,
    pub xs_hitupdesc: PgPtr<TupleDescData>,
    pub xs_heaptid: ItemPointerData,
    pub xs_heap_continue: bool,
    pub xs_heapfetch: PgPtr<IndexFetchTableData>,
    pub xs_recheck: bool,
    pub xs_orderbyvals: PgPtr<Datum>,
    pub xs_orderbynulls: PgPtr<bool>,
    pub xs_recheckorderby: bool,
    pub parallel_scan: PgPtr<ParallelIndexScanDescData>,
}
#[repr(C)]
pub struct ParallelIndexScanDescData {
    pub ps_relid: Oid,
    pub ps_indexid: Oid,
    pub ps_offset: Size,
    pub ps_snapshot_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct SysScanDescData {
    pub heap_rel: PgPtr<RelationData>,
    pub irel: PgPtr<RelationData>,
    pub scan: PgPtr<TableScanDescData>,
    pub iscan: PgPtr<IndexScanDescData>,
    pub snapshot: PgPtr<SnapshotData>,
    pub slot: PgPtr<TupleTableSlot>,
}
pub type EOM_get_flat_size_method =
    ::std::option::Option<unsafe extern "C" fn(eohptr: PgPtr<ExpandedObjectHeader>) -> Size>;
pub type EOM_flatten_into_method = ::std::option::Option<
    unsafe extern "C" fn(
        eohptr: PgPtr<ExpandedObjectHeader>,
        result: PgPtr<::std::os::raw::c_void>,
        allocated_size: Size,
    ),
>;
#[repr(C)]
pub struct ExpandedObjectMethods {
    pub get_flat_size: EOM_get_flat_size_method,
    pub flatten_into: EOM_flatten_into_method,
}
#[repr(C)]
pub struct ExpandedObjectHeader {
    pub vl_len_: int32,
    pub eoh_methods: PgPtr<ExpandedObjectMethods>,
    pub eoh_context: PgPtr<MemoryContextData>,
    pub eoh_rw_ptr: [::std::os::raw::c_char; 10usize],
    pub eoh_ro_ptr: [::std::os::raw::c_char; 10usize],
}
#[pg_guard]
extern "C" {
    pub fn DatumGetEOHP(d: Datum) -> PgPtr<ExpandedObjectHeader>;
}
#[pg_guard]
extern "C" {
    pub fn EOH_init_header(
        eohptr: PgPtr<ExpandedObjectHeader>,
        methods: PgPtr<ExpandedObjectMethods>,
        obj_context: PgPtr<MemoryContextData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn EOH_get_flat_size(eohptr: PgPtr<ExpandedObjectHeader>) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn EOH_flatten_into(
        eohptr: PgPtr<ExpandedObjectHeader>,
        result: PgPtr<::std::os::raw::c_void>,
        allocated_size: Size,
    );
}
#[pg_guard]
extern "C" {
    pub fn MakeExpandedObjectReadOnlyInternal(d: Datum) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn TransferExpandedObject(d: Datum, new_parent: PgPtr<MemoryContextData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn DeleteExpandedObject(d: Datum);
}
#[repr(C)]
pub struct ArrayType {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
}
#[repr(C)]
pub struct ExpandedArrayHeader {
    pub hdr: ExpandedObjectHeader,
    pub ea_magic: ::std::os::raw::c_int,
    pub ndims: ::std::os::raw::c_int,
    pub dims: PgPtr<::std::os::raw::c_int>,
    pub lbound: PgPtr<::std::os::raw::c_int>,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub dvalues: PgPtr<Datum>,
    pub dnulls: PgPtr<bool>,
    pub dvalueslen: ::std::os::raw::c_int,
    pub nelems: ::std::os::raw::c_int,
    pub flat_size: Size,
    pub fvalue: PgPtr<ArrayType>,
    pub fstartptr: PgPtr<::std::os::raw::c_char>,
    pub fendptr: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct AnyArrayType {
    pub flt: __BindgenUnionField<ArrayType>,
    pub xpn: __BindgenUnionField<ExpandedArrayHeader>,
    pub bindgen_union_field: [u64; 17usize],
}
#[repr(C)]
pub struct ArrayBuildState {
    pub mcontext: PgPtr<MemoryContextData>,
    pub dvalues: PgPtr<Datum>,
    pub dnulls: PgPtr<bool>,
    pub alen: ::std::os::raw::c_int,
    pub nelems: ::std::os::raw::c_int,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub private_cxt: bool,
}
#[repr(C)]
pub struct ArrayBuildStateArr {
    pub mcontext: PgPtr<MemoryContextData>,
    pub data: PgPtr<::std::os::raw::c_char>,
    pub nullbitmap: PgPtr<bits8>,
    pub abytes: ::std::os::raw::c_int,
    pub nbytes: ::std::os::raw::c_int,
    pub aitems: ::std::os::raw::c_int,
    pub nitems: ::std::os::raw::c_int,
    pub ndims: ::std::os::raw::c_int,
    pub dims: [::std::os::raw::c_int; 6usize],
    pub lbs: [::std::os::raw::c_int; 6usize],
    pub array_type: Oid,
    pub element_type: Oid,
    pub private_cxt: bool,
}
#[repr(C)]
pub struct ArrayBuildStateAny {
    pub scalarstate: PgPtr<ArrayBuildState>,
    pub arraystate: PgPtr<ArrayBuildStateArr>,
}
#[repr(C)]
pub struct ArrayMetaState {
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub typdelim: ::std::os::raw::c_char,
    pub typioparam: Oid,
    pub typiofunc: Oid,
    pub proc_: FmgrInfo,
}
#[repr(C)]
pub struct ArrayMapState {
    pub inp_extra: ArrayMetaState,
    pub ret_extra: ArrayMetaState,
}
#[repr(C)]
pub struct ArrayIteratorData {
    _unused: [u8; 0],
}
pub type ArrayIterator = PgPtr<ArrayIteratorData>;
#[pg_guard]
extern "C" {
    pub static mut Array_nulls: bool;
}
#[pg_guard]
extern "C" {
    pub fn CopyArrayEls(
        array: PgPtr<ArrayType>,
        values: PgPtr<Datum>,
        nulls: PgPtr<bool>,
        nitems: ::std::os::raw::c_int,
        typlen: ::std::os::raw::c_int,
        typbyval: bool,
        typalign: ::std::os::raw::c_char,
        freedata: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn array_get_element(
        arraydatum: Datum,
        nSubscripts: ::std::os::raw::c_int,
        indx: PgPtr<::std::os::raw::c_int>,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
        isNull: PgPtr<bool>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_set_element(
        arraydatum: Datum,
        nSubscripts: ::std::os::raw::c_int,
        indx: PgPtr<::std::os::raw::c_int>,
        dataValue: Datum,
        isNull: bool,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_get_slice(
        arraydatum: Datum,
        nSubscripts: ::std::os::raw::c_int,
        upperIndx: PgPtr<::std::os::raw::c_int>,
        lowerIndx: PgPtr<::std::os::raw::c_int>,
        upperProvided: PgPtr<bool>,
        lowerProvided: PgPtr<bool>,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_set_slice(
        arraydatum: Datum,
        nSubscripts: ::std::os::raw::c_int,
        upperIndx: PgPtr<::std::os::raw::c_int>,
        lowerIndx: PgPtr<::std::os::raw::c_int>,
        upperProvided: PgPtr<bool>,
        lowerProvided: PgPtr<bool>,
        srcArrayDatum: Datum,
        isNull: bool,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_ref(
        array: PgPtr<ArrayType>,
        nSubscripts: ::std::os::raw::c_int,
        indx: PgPtr<::std::os::raw::c_int>,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
        isNull: PgPtr<bool>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_set(
        array: PgPtr<ArrayType>,
        nSubscripts: ::std::os::raw::c_int,
        indx: PgPtr<::std::os::raw::c_int>,
        dataValue: Datum,
        isNull: bool,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> PgPtr<ArrayType>;
}
#[pg_guard]
extern "C" {
    pub fn array_map(
        arrayd: Datum,
        exprstate: PgPtr<ExprState>,
        econtext: PgPtr<ExprContext>,
        retType: Oid,
        amstate: PgPtr<ArrayMapState>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_bitmap_copy(
        destbitmap: PgPtr<bits8>,
        destoffset: ::std::os::raw::c_int,
        srcbitmap: PgPtr<bits8>,
        srcoffset: ::std::os::raw::c_int,
        nitems: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn construct_array(
        elems: PgPtr<Datum>,
        nelems: ::std::os::raw::c_int,
        elmtype: Oid,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> PgPtr<ArrayType>;
}
#[pg_guard]
extern "C" {
    pub fn construct_md_array(
        elems: PgPtr<Datum>,
        nulls: PgPtr<bool>,
        ndims: ::std::os::raw::c_int,
        dims: PgPtr<::std::os::raw::c_int>,
        lbs: PgPtr<::std::os::raw::c_int>,
        elmtype: Oid,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> PgPtr<ArrayType>;
}
#[pg_guard]
extern "C" {
    pub fn construct_empty_array(elmtype: Oid) -> PgPtr<ArrayType>;
}
#[pg_guard]
extern "C" {
    pub fn construct_empty_expanded_array(
        element_type: Oid,
        parentcontext: PgPtr<MemoryContextData>,
        metacache: PgPtr<ArrayMetaState>,
    ) -> PgPtr<ExpandedArrayHeader>;
}
#[pg_guard]
extern "C" {
    pub fn deconstruct_array(
        array: PgPtr<ArrayType>,
        elmtype: Oid,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
        elemsp: PgPtr<PgPtr<Datum>>,
        nullsp: PgPtr<PgPtr<bool>>,
        nelemsp: PgPtr<::std::os::raw::c_int>,
    );
}
#[pg_guard]
extern "C" {
    pub fn array_contains_nulls(array: PgPtr<ArrayType>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn initArrayResult(
        element_type: Oid,
        rcontext: PgPtr<MemoryContextData>,
        subcontext: bool,
    ) -> PgPtr<ArrayBuildState>;
}
#[pg_guard]
extern "C" {
    pub fn accumArrayResult(
        astate: PgPtr<ArrayBuildState>,
        dvalue: Datum,
        disnull: bool,
        element_type: Oid,
        rcontext: PgPtr<MemoryContextData>,
    ) -> PgPtr<ArrayBuildState>;
}
#[pg_guard]
extern "C" {
    pub fn makeArrayResult(
        astate: PgPtr<ArrayBuildState>,
        rcontext: PgPtr<MemoryContextData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn makeMdArrayResult(
        astate: PgPtr<ArrayBuildState>,
        ndims: ::std::os::raw::c_int,
        dims: PgPtr<::std::os::raw::c_int>,
        lbs: PgPtr<::std::os::raw::c_int>,
        rcontext: PgPtr<MemoryContextData>,
        release: bool,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn initArrayResultArr(
        array_type: Oid,
        element_type: Oid,
        rcontext: PgPtr<MemoryContextData>,
        subcontext: bool,
    ) -> PgPtr<ArrayBuildStateArr>;
}
#[pg_guard]
extern "C" {
    pub fn accumArrayResultArr(
        astate: PgPtr<ArrayBuildStateArr>,
        dvalue: Datum,
        disnull: bool,
        array_type: Oid,
        rcontext: PgPtr<MemoryContextData>,
    ) -> PgPtr<ArrayBuildStateArr>;
}
#[pg_guard]
extern "C" {
    pub fn makeArrayResultArr(
        astate: PgPtr<ArrayBuildStateArr>,
        rcontext: PgPtr<MemoryContextData>,
        release: bool,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn initArrayResultAny(
        input_type: Oid,
        rcontext: PgPtr<MemoryContextData>,
        subcontext: bool,
    ) -> PgPtr<ArrayBuildStateAny>;
}
#[pg_guard]
extern "C" {
    pub fn accumArrayResultAny(
        astate: PgPtr<ArrayBuildStateAny>,
        dvalue: Datum,
        disnull: bool,
        input_type: Oid,
        rcontext: PgPtr<MemoryContextData>,
    ) -> PgPtr<ArrayBuildStateAny>;
}
#[pg_guard]
extern "C" {
    pub fn makeArrayResultAny(
        astate: PgPtr<ArrayBuildStateAny>,
        rcontext: PgPtr<MemoryContextData>,
        release: bool,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_create_iterator(
        arr: PgPtr<ArrayType>,
        slice_ndim: ::std::os::raw::c_int,
        mstate: PgPtr<ArrayMetaState>,
    ) -> PgPtr<ArrayIteratorData>;
}
#[pg_guard]
extern "C" {
    pub fn array_iterate(
        iterator: PgPtr<ArrayIteratorData>,
        value: PgPtr<Datum>,
        isnull: PgPtr<bool>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn array_free_iterator(iterator: PgPtr<ArrayIteratorData>);
}
#[pg_guard]
extern "C" {
    pub fn ArrayGetOffset(
        n: ::std::os::raw::c_int,
        dim: PgPtr<::std::os::raw::c_int>,
        lb: PgPtr<::std::os::raw::c_int>,
        indx: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ArrayGetOffset0(
        n: ::std::os::raw::c_int,
        tup: PgPtr<::std::os::raw::c_int>,
        scale: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ArrayGetNItems(
        ndim: ::std::os::raw::c_int,
        dims: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn mda_get_range(
        n: ::std::os::raw::c_int,
        span: PgPtr<::std::os::raw::c_int>,
        st: PgPtr<::std::os::raw::c_int>,
        endp: PgPtr<::std::os::raw::c_int>,
    );
}
#[pg_guard]
extern "C" {
    pub fn mda_get_prod(
        n: ::std::os::raw::c_int,
        range: PgPtr<::std::os::raw::c_int>,
        prod: PgPtr<::std::os::raw::c_int>,
    );
}
#[pg_guard]
extern "C" {
    pub fn mda_get_offset_values(
        n: ::std::os::raw::c_int,
        dist: PgPtr<::std::os::raw::c_int>,
        prod: PgPtr<::std::os::raw::c_int>,
        span: PgPtr<::std::os::raw::c_int>,
    );
}
#[pg_guard]
extern "C" {
    pub fn mda_next_tuple(
        n: ::std::os::raw::c_int,
        curr: PgPtr<::std::os::raw::c_int>,
        span: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ArrayGetIntegerTypmods(
        arr: PgPtr<ArrayType>,
        n: PgPtr<::std::os::raw::c_int>,
    ) -> PgPtr<int32>;
}
#[pg_guard]
extern "C" {
    pub fn expand_array(
        arraydatum: Datum,
        parentcontext: PgPtr<MemoryContextData>,
        metacache: PgPtr<ArrayMetaState>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn DatumGetExpandedArray(d: Datum) -> PgPtr<ExpandedArrayHeader>;
}
#[pg_guard]
extern "C" {
    pub fn DatumGetExpandedArrayX(
        d: Datum,
        metacache: PgPtr<ArrayMetaState>,
    ) -> PgPtr<ExpandedArrayHeader>;
}
#[pg_guard]
extern "C" {
    pub fn DatumGetAnyArrayP(d: Datum) -> PgPtr<AnyArrayType>;
}
#[pg_guard]
extern "C" {
    pub fn deconstruct_expanded_array(eah: PgPtr<ExpandedArrayHeader>);
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum GucContext {
    PGC_INTERNAL = 0,
    PGC_POSTMASTER = 1,
    PGC_SIGHUP = 2,
    PGC_SU_BACKEND = 3,
    PGC_BACKEND = 4,
    PGC_SUSET = 5,
    PGC_USERSET = 6,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum GucSource {
    PGC_S_DEFAULT = 0,
    PGC_S_DYNAMIC_DEFAULT = 1,
    PGC_S_ENV_VAR = 2,
    PGC_S_FILE = 3,
    PGC_S_ARGV = 4,
    PGC_S_GLOBAL = 5,
    PGC_S_DATABASE = 6,
    PGC_S_USER = 7,
    PGC_S_DATABASE_USER = 8,
    PGC_S_CLIENT = 9,
    PGC_S_OVERRIDE = 10,
    PGC_S_INTERACTIVE = 11,
    PGC_S_TEST = 12,
    PGC_S_SESSION = 13,
}
#[repr(C)]
pub struct ConfigVariable {
    pub name: PgPtr<::std::os::raw::c_char>,
    pub value: PgPtr<::std::os::raw::c_char>,
    pub errmsg: PgPtr<::std::os::raw::c_char>,
    pub filename: PgPtr<::std::os::raw::c_char>,
    pub sourceline: ::std::os::raw::c_int,
    pub ignore: bool,
    pub applied: bool,
    pub next: PgPtr<ConfigVariable>,
}
#[pg_guard]
extern "C" {
    pub fn ParseConfigFile(
        config_file: PgPtr<::std::os::raw::c_char>,
        strict: bool,
        calling_file: PgPtr<::std::os::raw::c_char>,
        calling_lineno: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        elevel: ::std::os::raw::c_int,
        head_p: PgPtr<PgPtr<ConfigVariable>>,
        tail_p: PgPtr<PgPtr<ConfigVariable>>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ParseConfigFp(
        fp: PgPtr<FILE>,
        config_file: PgPtr<::std::os::raw::c_char>,
        depth: ::std::os::raw::c_int,
        elevel: ::std::os::raw::c_int,
        head_p: PgPtr<PgPtr<ConfigVariable>>,
        tail_p: PgPtr<PgPtr<ConfigVariable>>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ParseConfigDirectory(
        includedir: PgPtr<::std::os::raw::c_char>,
        calling_file: PgPtr<::std::os::raw::c_char>,
        calling_lineno: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        elevel: ::std::os::raw::c_int,
        head_p: PgPtr<PgPtr<ConfigVariable>>,
        tail_p: PgPtr<PgPtr<ConfigVariable>>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn FreeConfigVariables(list: PgPtr<ConfigVariable>);
}
#[repr(C)]
pub struct config_enum_entry {
    pub name: PgPtr<::std::os::raw::c_char>,
    pub val: ::std::os::raw::c_int,
    pub hidden: bool,
}
pub type GucBoolCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: PgPtr<bool>,
        extra: PgPtr<PgPtr<::std::os::raw::c_void>>,
        source: GucSource,
    ) -> bool,
>;
pub type GucIntCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: PgPtr<::std::os::raw::c_int>,
        extra: PgPtr<PgPtr<::std::os::raw::c_void>>,
        source: GucSource,
    ) -> bool,
>;
pub type GucRealCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: PgPtr<f64>,
        extra: PgPtr<PgPtr<::std::os::raw::c_void>>,
        source: GucSource,
    ) -> bool,
>;
pub type GucStringCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: PgPtr<PgPtr<::std::os::raw::c_char>>,
        extra: PgPtr<PgPtr<::std::os::raw::c_void>>,
        source: GucSource,
    ) -> bool,
>;
pub type GucEnumCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: PgPtr<::std::os::raw::c_int>,
        extra: PgPtr<PgPtr<::std::os::raw::c_void>>,
        source: GucSource,
    ) -> bool,
>;
pub type GucBoolAssignHook =
    ::std::option::Option<unsafe extern "C" fn(newval: bool, extra: PgPtr<::std::os::raw::c_void>)>;
pub type GucIntAssignHook = ::std::option::Option<
    unsafe extern "C" fn(newval: ::std::os::raw::c_int, extra: PgPtr<::std::os::raw::c_void>),
>;
pub type GucRealAssignHook =
    ::std::option::Option<unsafe extern "C" fn(newval: f64, extra: PgPtr<::std::os::raw::c_void>)>;
pub type GucStringAssignHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: PgPtr<::std::os::raw::c_char>,
        extra: PgPtr<::std::os::raw::c_void>,
    ),
>;
pub type GucEnumAssignHook = ::std::option::Option<
    unsafe extern "C" fn(newval: ::std::os::raw::c_int, extra: PgPtr<::std::os::raw::c_void>),
>;
pub type GucShowHook =
    ::std::option::Option<unsafe extern "C" fn() -> PgPtr<::std::os::raw::c_char>>;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum GucAction {
    GUC_ACTION_SET = 0,
    GUC_ACTION_LOCAL = 1,
    GUC_ACTION_SAVE = 2,
}
#[pg_guard]
extern "C" {
    pub static mut log_duration: bool;
}
#[pg_guard]
extern "C" {
    pub static mut Debug_print_plan: bool;
}
#[pg_guard]
extern "C" {
    pub static mut Debug_print_parse: bool;
}
#[pg_guard]
extern "C" {
    pub static mut Debug_print_rewritten: bool;
}
#[pg_guard]
extern "C" {
    pub static mut Debug_pretty_print: bool;
}
#[pg_guard]
extern "C" {
    pub static mut log_parser_stats: bool;
}
#[pg_guard]
extern "C" {
    pub static mut log_planner_stats: bool;
}
#[pg_guard]
extern "C" {
    pub static mut log_executor_stats: bool;
}
#[pg_guard]
extern "C" {
    pub static mut log_statement_stats: bool;
}
#[pg_guard]
extern "C" {
    pub static mut log_btree_build_stats: bool;
}
#[pg_guard]
extern "C" {
    pub static mut check_function_bodies: bool;
}
#[pg_guard]
extern "C" {
    pub static mut session_auth_is_superuser: bool;
}
#[pg_guard]
extern "C" {
    pub static mut log_min_error_statement: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut log_min_messages: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut client_min_messages: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut log_min_duration_statement: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut log_temp_files: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut log_xact_sample_rate: f64;
}
#[pg_guard]
extern "C" {
    pub static mut temp_file_limit: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut num_temp_buffers: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut cluster_name: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut ConfigFileName: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut HbaFileName: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut IdentFileName: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut external_pid_file: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut application_name: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut tcp_keepalives_idle: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut tcp_keepalives_interval: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut tcp_keepalives_count: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut tcp_user_timeout: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut trace_sort: bool;
}
#[pg_guard]
extern "C" {
    pub fn SetConfigOption(
        name: PgPtr<::std::os::raw::c_char>,
        value: PgPtr<::std::os::raw::c_char>,
        context: GucContext,
        source: GucSource,
    );
}
#[pg_guard]
extern "C" {
    pub fn DefineCustomBoolVariable(
        name: PgPtr<::std::os::raw::c_char>,
        short_desc: PgPtr<::std::os::raw::c_char>,
        long_desc: PgPtr<::std::os::raw::c_char>,
        valueAddr: PgPtr<bool>,
        bootValue: bool,
        context: GucContext,
        flags: ::std::os::raw::c_int,
        check_hook: GucBoolCheckHook,
        assign_hook: GucBoolAssignHook,
        show_hook: GucShowHook,
    );
}
#[pg_guard]
extern "C" {
    pub fn DefineCustomIntVariable(
        name: PgPtr<::std::os::raw::c_char>,
        short_desc: PgPtr<::std::os::raw::c_char>,
        long_desc: PgPtr<::std::os::raw::c_char>,
        valueAddr: PgPtr<::std::os::raw::c_int>,
        bootValue: ::std::os::raw::c_int,
        minValue: ::std::os::raw::c_int,
        maxValue: ::std::os::raw::c_int,
        context: GucContext,
        flags: ::std::os::raw::c_int,
        check_hook: GucIntCheckHook,
        assign_hook: GucIntAssignHook,
        show_hook: GucShowHook,
    );
}
#[pg_guard]
extern "C" {
    pub fn DefineCustomRealVariable(
        name: PgPtr<::std::os::raw::c_char>,
        short_desc: PgPtr<::std::os::raw::c_char>,
        long_desc: PgPtr<::std::os::raw::c_char>,
        valueAddr: PgPtr<f64>,
        bootValue: f64,
        minValue: f64,
        maxValue: f64,
        context: GucContext,
        flags: ::std::os::raw::c_int,
        check_hook: GucRealCheckHook,
        assign_hook: GucRealAssignHook,
        show_hook: GucShowHook,
    );
}
#[pg_guard]
extern "C" {
    pub fn DefineCustomStringVariable(
        name: PgPtr<::std::os::raw::c_char>,
        short_desc: PgPtr<::std::os::raw::c_char>,
        long_desc: PgPtr<::std::os::raw::c_char>,
        valueAddr: PgPtr<PgPtr<::std::os::raw::c_char>>,
        bootValue: PgPtr<::std::os::raw::c_char>,
        context: GucContext,
        flags: ::std::os::raw::c_int,
        check_hook: GucStringCheckHook,
        assign_hook: GucStringAssignHook,
        show_hook: GucShowHook,
    );
}
#[pg_guard]
extern "C" {
    pub fn DefineCustomEnumVariable(
        name: PgPtr<::std::os::raw::c_char>,
        short_desc: PgPtr<::std::os::raw::c_char>,
        long_desc: PgPtr<::std::os::raw::c_char>,
        valueAddr: PgPtr<::std::os::raw::c_int>,
        bootValue: ::std::os::raw::c_int,
        options: PgPtr<config_enum_entry>,
        context: GucContext,
        flags: ::std::os::raw::c_int,
        check_hook: GucEnumCheckHook,
        assign_hook: GucEnumAssignHook,
        show_hook: GucShowHook,
    );
}
#[pg_guard]
extern "C" {
    pub fn EmitWarningsOnPlaceholders(className: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn GetConfigOption(
        name: PgPtr<::std::os::raw::c_char>,
        missing_ok: bool,
        restrict_privileged: bool,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn GetConfigOptionResetString(
        name: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn GetConfigOptionFlags(
        name: PgPtr<::std::os::raw::c_char>,
        missing_ok: bool,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ProcessConfigFile(context: GucContext);
}
#[pg_guard]
extern "C" {
    pub fn InitializeGUCOptions();
}
#[pg_guard]
extern "C" {
    pub fn SelectConfigFiles(
        userDoption: PgPtr<::std::os::raw::c_char>,
        progname: PgPtr<::std::os::raw::c_char>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ResetAllOptions();
}
#[pg_guard]
extern "C" {
    pub fn AtStart_GUC();
}
#[pg_guard]
extern "C" {
    pub fn NewGUCNestLevel() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn AtEOXact_GUC(isCommit: bool, nestLevel: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn BeginReportingGUCOptions();
}
#[pg_guard]
extern "C" {
    pub fn ParseLongOption(
        string: PgPtr<::std::os::raw::c_char>,
        name: PgPtr<PgPtr<::std::os::raw::c_char>>,
        value: PgPtr<PgPtr<::std::os::raw::c_char>>,
    );
}
#[pg_guard]
extern "C" {
    pub fn parse_int(
        value: PgPtr<::std::os::raw::c_char>,
        result: PgPtr<::std::os::raw::c_int>,
        flags: ::std::os::raw::c_int,
        hintmsg: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn parse_real(
        value: PgPtr<::std::os::raw::c_char>,
        result: PgPtr<f64>,
        flags: ::std::os::raw::c_int,
        hintmsg: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn set_config_option(
        name: PgPtr<::std::os::raw::c_char>,
        value: PgPtr<::std::os::raw::c_char>,
        context: GucContext,
        source: GucSource,
        action: GucAction,
        changeVal: bool,
        elevel: ::std::os::raw::c_int,
        is_reload: bool,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn AlterSystemSetConfigFile(setstmt: PgPtr<AlterSystemStmt>);
}
#[pg_guard]
extern "C" {
    pub fn GetConfigOptionByName(
        name: PgPtr<::std::os::raw::c_char>,
        varname: PgPtr<PgPtr<::std::os::raw::c_char>>,
        missing_ok: bool,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn GetConfigOptionByNum(
        varnum: ::std::os::raw::c_int,
        values: PgPtr<PgPtr<::std::os::raw::c_char>>,
        noshow: PgPtr<bool>,
    );
}
#[pg_guard]
extern "C" {
    pub fn GetNumConfigOptions() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SetPGVariable(name: PgPtr<::std::os::raw::c_char>, args: PgPtr<List>, is_local: bool);
}
#[pg_guard]
extern "C" {
    pub fn GetPGVariable(name: PgPtr<::std::os::raw::c_char>, dest: PgPtr<DestReceiver>);
}
#[pg_guard]
extern "C" {
    pub fn GetPGVariableResultDesc(name: PgPtr<::std::os::raw::c_char>) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn ExecSetVariableStmt(stmt: PgPtr<VariableSetStmt>, isTopLevel: bool);
}
#[pg_guard]
extern "C" {
    pub fn ExtractSetVariableArgs(stmt: PgPtr<VariableSetStmt>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn ProcessGUCArray(
        array: PgPtr<ArrayType>,
        context: GucContext,
        source: GucSource,
        action: GucAction,
    );
}
#[pg_guard]
extern "C" {
    pub fn GUCArrayAdd(
        array: PgPtr<ArrayType>,
        name: PgPtr<::std::os::raw::c_char>,
        value: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<ArrayType>;
}
#[pg_guard]
extern "C" {
    pub fn GUCArrayDelete(
        array: PgPtr<ArrayType>,
        name: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<ArrayType>;
}
#[pg_guard]
extern "C" {
    pub fn GUCArrayReset(array: PgPtr<ArrayType>) -> PgPtr<ArrayType>;
}
#[pg_guard]
extern "C" {
    pub fn EstimateGUCStateSpace() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn SerializeGUCState(maxsize: Size, start_address: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn RestoreGUCState(gucstate: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub static mut GUC_check_errmsg_string: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut GUC_check_errdetail_string: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut GUC_check_errhint_string: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn GUC_check_errcode(sqlerrcode: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn check_default_tablespace(
        newval: PgPtr<PgPtr<::std::os::raw::c_char>>,
        extra: PgPtr<PgPtr<::std::os::raw::c_void>>,
        source: GucSource,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn check_temp_tablespaces(
        newval: PgPtr<PgPtr<::std::os::raw::c_char>>,
        extra: PgPtr<PgPtr<::std::os::raw::c_void>>,
        source: GucSource,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn assign_temp_tablespaces(
        newval: PgPtr<::std::os::raw::c_char>,
        extra: PgPtr<::std::os::raw::c_void>,
    );
}
#[pg_guard]
extern "C" {
    pub fn check_search_path(
        newval: PgPtr<PgPtr<::std::os::raw::c_char>>,
        extra: PgPtr<PgPtr<::std::os::raw::c_void>>,
        source: GucSource,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn assign_search_path(
        newval: PgPtr<::std::os::raw::c_char>,
        extra: PgPtr<::std::os::raw::c_void>,
    );
}
#[pg_guard]
extern "C" {
    pub fn check_wal_buffers(
        newval: PgPtr<::std::os::raw::c_int>,
        extra: PgPtr<PgPtr<::std::os::raw::c_void>>,
        source: GucSource,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn assign_xlog_sync_method(
        new_sync_method: ::std::os::raw::c_int,
        extra: PgPtr<::std::os::raw::c_void>,
    );
}
#[pg_guard]
extern "C" {
    pub fn XLogBeginInsert();
}
#[pg_guard]
extern "C" {
    pub fn XLogSetRecordFlags(flags: uint8);
}
#[pg_guard]
extern "C" {
    pub fn XLogInsert(rmid: RmgrId, info: uint8) -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn XLogEnsureRecordSpace(nbuffers: ::std::os::raw::c_int, ndatas: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn XLogRegisterData(data: PgPtr<::std::os::raw::c_char>, len: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn XLogRegisterBuffer(block_id: uint8, buffer: Buffer, flags: uint8);
}
#[pg_guard]
extern "C" {
    pub fn XLogRegisterBlock(
        block_id: uint8,
        rnode: PgPtr<RelFileNode>,
        forknum: ForkNumber,
        blknum: BlockNumber,
        page: PgPtr<::std::os::raw::c_char>,
        flags: uint8,
    );
}
#[pg_guard]
extern "C" {
    pub fn XLogRegisterBufData(
        block_id: uint8,
        data: PgPtr<::std::os::raw::c_char>,
        len: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn XLogResetInsertion();
}
#[pg_guard]
extern "C" {
    pub fn XLogCheckBufferNeedsBackup(buffer: Buffer) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn log_newpage(
        rnode: PgPtr<RelFileNode>,
        forkNum: ForkNumber,
        blk: BlockNumber,
        page: PgPtr<::std::os::raw::c_char>,
        page_std: bool,
    ) -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn log_newpage_buffer(buffer: Buffer, page_std: bool) -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn log_newpage_range(
        rel: PgPtr<RelationData>,
        forkNum: ForkNumber,
        startblk: BlockNumber,
        endblk: BlockNumber,
        page_std: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn XLogSaveBufferForHint(buffer: Buffer, buffer_std: bool) -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn InitXLogInsert();
}
#[pg_guard]
extern "C" {
    pub static mut sync_method: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut ThisTimeLineID: TimeLineID;
}
#[pg_guard]
extern "C" {
    pub static mut InRecovery: bool;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum HotStandbyState {
    STANDBY_DISABLED = 0,
    STANDBY_INITIALIZED = 1,
    STANDBY_SNAPSHOT_PENDING = 2,
    STANDBY_SNAPSHOT_READY = 3,
}
#[pg_guard]
extern "C" {
    pub static mut standbyState: HotStandbyState;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum RecoveryTargetType {
    RECOVERY_TARGET_UNSET = 0,
    RECOVERY_TARGET_XID = 1,
    RECOVERY_TARGET_TIME = 2,
    RECOVERY_TARGET_NAME = 3,
    RECOVERY_TARGET_LSN = 4,
    RECOVERY_TARGET_IMMEDIATE = 5,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum RecoveryTargetTimeLineGoal {
    RECOVERY_TARGET_TIMELINE_CONTROLFILE = 0,
    RECOVERY_TARGET_TIMELINE_LATEST = 1,
    RECOVERY_TARGET_TIMELINE_NUMERIC = 2,
}
#[pg_guard]
extern "C" {
    pub static mut ProcLastRecPtr: XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub static mut XactLastRecEnd: XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub static mut XactLastCommitEnd: XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub static mut reachedConsistency: bool;
}
#[pg_guard]
extern "C" {
    pub static mut wal_segment_size: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut min_wal_size_mb: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut max_wal_size_mb: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut wal_keep_segments: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut XLOGbuffers: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut XLogArchiveTimeout: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut wal_retrieve_retry_interval: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut XLogArchiveCommand: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut EnableHotStandby: bool;
}
#[pg_guard]
extern "C" {
    pub static mut fullPageWrites: bool;
}
#[pg_guard]
extern "C" {
    pub static mut wal_log_hints: bool;
}
#[pg_guard]
extern "C" {
    pub static mut wal_compression: bool;
}
#[pg_guard]
extern "C" {
    pub static mut wal_init_zero: bool;
}
#[pg_guard]
extern "C" {
    pub static mut wal_recycle: bool;
}
#[pg_guard]
extern "C" {
    pub static mut wal_consistency_checking: PgPtr<bool>;
}
#[pg_guard]
extern "C" {
    pub static mut wal_consistency_checking_string: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut log_checkpoints: bool;
}
#[pg_guard]
extern "C" {
    pub static mut recoveryRestoreCommand: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut recoveryEndCommand: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut archiveCleanupCommand: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut recoveryTargetInclusive: bool;
}
#[pg_guard]
extern "C" {
    pub static mut recoveryTargetAction: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut recovery_min_apply_delay: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut PrimaryConnInfo: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut PrimarySlotName: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut recoveryTargetXid: TransactionId;
}
#[pg_guard]
extern "C" {
    pub static mut recovery_target_time_string: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut recoveryTargetName: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut recoveryTargetLSN: XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub static mut recoveryTarget: RecoveryTargetType;
}
#[pg_guard]
extern "C" {
    pub static mut PromoteTriggerFile: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut recoveryTargetTimeLineGoal: RecoveryTargetTimeLineGoal;
}
#[pg_guard]
extern "C" {
    pub static mut recoveryTargetTLIRequested: TimeLineID;
}
#[pg_guard]
extern "C" {
    pub static mut recoveryTargetTLI: TimeLineID;
}
#[pg_guard]
extern "C" {
    pub static mut CheckPointSegments: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut StandbyModeRequested: bool;
}
#[pg_guard]
extern "C" {
    pub static mut StandbyMode: bool;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ArchiveMode {
    ARCHIVE_MODE_OFF = 0,
    ARCHIVE_MODE_ON = 1,
    ARCHIVE_MODE_ALWAYS = 2,
}
#[pg_guard]
extern "C" {
    pub static mut XLogArchiveMode: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum WalLevel {
    WAL_LEVEL_MINIMAL = 0,
    WAL_LEVEL_REPLICA = 1,
    WAL_LEVEL_LOGICAL = 2,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum RecoveryState {
    RECOVERY_STATE_CRASH = 0,
    RECOVERY_STATE_ARCHIVE = 1,
    RECOVERY_STATE_DONE = 2,
}
#[pg_guard]
extern "C" {
    pub static mut wal_level: ::std::os::raw::c_int;
}
#[repr(C)]
pub struct CheckpointStatsData {
    pub ckpt_start_t: TimestampTz,
    pub ckpt_write_t: TimestampTz,
    pub ckpt_sync_t: TimestampTz,
    pub ckpt_sync_end_t: TimestampTz,
    pub ckpt_end_t: TimestampTz,
    pub ckpt_bufs_written: ::std::os::raw::c_int,
    pub ckpt_segs_added: ::std::os::raw::c_int,
    pub ckpt_segs_removed: ::std::os::raw::c_int,
    pub ckpt_segs_recycled: ::std::os::raw::c_int,
    pub ckpt_sync_rels: ::std::os::raw::c_int,
    pub ckpt_longest_sync: uint64,
    pub ckpt_agg_sync_time: uint64,
}
#[pg_guard]
extern "C" {
    pub static mut CheckpointStats: CheckpointStatsData;
}
#[repr(C)]
pub struct XLogRecData {
    _unused: [u8; 0],
}
#[pg_guard]
extern "C" {
    pub fn XLogInsertRecord(
        rdata: PgPtr<XLogRecData>,
        fpw_lsn: XLogRecPtr,
        flags: uint8,
    ) -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn XLogFlush(RecPtr: XLogRecPtr);
}
#[pg_guard]
extern "C" {
    pub fn XLogBackgroundFlush() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn XLogNeedsFlush(RecPtr: XLogRecPtr) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn XLogFileInit(
        segno: XLogSegNo,
        use_existent: PgPtr<bool>,
        use_lock: bool,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn XLogFileOpen(segno: XLogSegNo) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn CheckXLogRemoved(segno: XLogSegNo, tli: TimeLineID);
}
#[pg_guard]
extern "C" {
    pub fn XLogGetLastRemovedSegno() -> XLogSegNo;
}
#[pg_guard]
extern "C" {
    pub fn XLogSetAsyncXactLSN(record: XLogRecPtr);
}
#[pg_guard]
extern "C" {
    pub fn XLogSetReplicationSlotMinimumLSN(lsn: XLogRecPtr);
}
#[pg_guard]
extern "C" {
    pub fn xlog_redo(record: PgPtr<XLogReaderState>);
}
#[pg_guard]
extern "C" {
    pub fn xlog_desc(buf: PgPtr<StringInfoData>, record: PgPtr<XLogReaderState>);
}
#[pg_guard]
extern "C" {
    pub fn xlog_identify(info: uint8) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn issue_xlog_fsync(fd: ::std::os::raw::c_int, segno: XLogSegNo);
}
#[pg_guard]
extern "C" {
    pub fn RecoveryInProgress() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetRecoveryState() -> RecoveryState;
}
#[pg_guard]
extern "C" {
    pub fn HotStandbyActive() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn HotStandbyActiveInReplay() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn XLogInsertAllowed() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetXLogReceiptTime(rtime: PgPtr<TimestampTz>, fromStream: PgPtr<bool>);
}
#[pg_guard]
extern "C" {
    pub fn GetXLogReplayRecPtr(replayTLI: PgPtr<TimeLineID>) -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn GetXLogInsertRecPtr() -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn GetXLogWriteRecPtr() -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn RecoveryIsPaused() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn SetRecoveryPause(recoveryPause: bool);
}
#[pg_guard]
extern "C" {
    pub fn GetLatestXTime() -> TimestampTz;
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentChunkReplayStartTime() -> TimestampTz;
}
#[pg_guard]
extern "C" {
    pub fn XLogFileNameP(tli: TimeLineID, segno: XLogSegNo) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn UpdateControlFile();
}
#[pg_guard]
extern "C" {
    pub fn GetSystemIdentifier() -> uint64;
}
#[pg_guard]
extern "C" {
    pub fn GetMockAuthenticationNonce() -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn DataChecksumsEnabled() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetFakeLSNForUnloggedRel() -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn XLOGShmemSize() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn XLOGShmemInit();
}
#[pg_guard]
extern "C" {
    pub fn BootStrapXLOG();
}
#[pg_guard]
extern "C" {
    pub fn LocalProcessControlFile(reset: bool);
}
#[pg_guard]
extern "C" {
    pub fn StartupXLOG();
}
#[pg_guard]
extern "C" {
    pub fn ShutdownXLOG(code: ::std::os::raw::c_int, arg: Datum);
}
#[pg_guard]
extern "C" {
    pub fn InitXLOGAccess();
}
#[pg_guard]
extern "C" {
    pub fn CreateCheckPoint(flags: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn CreateRestartPoint(flags: ::std::os::raw::c_int) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn XLogPutNextOid(nextOid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn XLogRestorePoint(rpName: PgPtr<::std::os::raw::c_char>) -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn UpdateFullPageWrites();
}
#[pg_guard]
extern "C" {
    pub fn GetFullPageWriteInfo(RedoRecPtr_p: PgPtr<XLogRecPtr>, doPageWrites_p: PgPtr<bool>);
}
#[pg_guard]
extern "C" {
    pub fn GetRedoRecPtr() -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn GetInsertRecPtr() -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn GetFlushRecPtr() -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn GetLastImportantRecPtr() -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn RemovePromoteSignalFiles();
}
#[pg_guard]
extern "C" {
    pub fn CheckPromoteSignal() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn WakeupRecovery();
}
#[pg_guard]
extern "C" {
    pub fn SetWalWriterSleeping(sleeping: bool);
}
#[pg_guard]
extern "C" {
    pub fn XLogRequestWalReceiverReply();
}
#[pg_guard]
extern "C" {
    pub fn assign_max_wal_size(newval: ::std::os::raw::c_int, extra: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn assign_checkpoint_completion_target(newval: f64, extra: PgPtr<::std::os::raw::c_void>);
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SessionBackupState {
    SESSION_BACKUP_NONE = 0,
    SESSION_BACKUP_EXCLUSIVE = 1,
    SESSION_BACKUP_NON_EXCLUSIVE = 2,
}
#[pg_guard]
extern "C" {
    pub fn do_pg_start_backup(
        backupidstr: PgPtr<::std::os::raw::c_char>,
        fast: bool,
        starttli_p: PgPtr<TimeLineID>,
        labelfile: PgPtr<StringInfoData>,
        tablespaces: PgPtr<PgPtr<List>>,
        tblspcmapfile: PgPtr<StringInfoData>,
        infotbssize: bool,
        needtblspcmapfile: bool,
    ) -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn do_pg_stop_backup(
        labelfile: PgPtr<::std::os::raw::c_char>,
        waitforarchive: bool,
        stoptli_p: PgPtr<TimeLineID>,
    ) -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn do_pg_abort_backup(code: ::std::os::raw::c_int, arg: Datum);
}
#[pg_guard]
extern "C" {
    pub fn register_persistent_abort_backup_handler();
}
#[pg_guard]
extern "C" {
    pub fn get_backup_status() -> SessionBackupState;
}
#[repr(C)]
pub struct FormData_pg_class {
    pub oid: Oid,
    pub relname: NameData,
    pub relnamespace: Oid,
    pub reltype: Oid,
    pub reloftype: Oid,
    pub relowner: Oid,
    pub relam: Oid,
    pub relfilenode: Oid,
    pub reltablespace: Oid,
    pub relpages: int32,
    pub reltuples: float4,
    pub relallvisible: int32,
    pub reltoastrelid: Oid,
    pub relhasindex: bool,
    pub relisshared: bool,
    pub relpersistence: ::std::os::raw::c_char,
    pub relkind: ::std::os::raw::c_char,
    pub relnatts: int16,
    pub relchecks: int16,
    pub relhasrules: bool,
    pub relhastriggers: bool,
    pub relhassubclass: bool,
    pub relrowsecurity: bool,
    pub relforcerowsecurity: bool,
    pub relispopulated: bool,
    pub relreplident: ::std::os::raw::c_char,
    pub relispartition: bool,
    pub relrewrite: Oid,
    pub relfrozenxid: TransactionId,
    pub relminmxid: TransactionId,
}
pub type Form_pg_class = PgPtr<FormData_pg_class>;
#[repr(C)]
pub struct FormData_pg_index {
    pub indexrelid: Oid,
    pub indrelid: Oid,
    pub indnatts: int16,
    pub indnkeyatts: int16,
    pub indisunique: bool,
    pub indisprimary: bool,
    pub indisexclusion: bool,
    pub indimmediate: bool,
    pub indisclustered: bool,
    pub indisvalid: bool,
    pub indcheckxmin: bool,
    pub indisready: bool,
    pub indislive: bool,
    pub indisreplident: bool,
    pub indkey: int2vector,
}
pub type Form_pg_index = PgPtr<FormData_pg_index>;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ParseExprKind {
    EXPR_KIND_NONE = 0,
    EXPR_KIND_OTHER = 1,
    EXPR_KIND_JOIN_ON = 2,
    EXPR_KIND_JOIN_USING = 3,
    EXPR_KIND_FROM_SUBSELECT = 4,
    EXPR_KIND_FROM_FUNCTION = 5,
    EXPR_KIND_WHERE = 6,
    EXPR_KIND_HAVING = 7,
    EXPR_KIND_FILTER = 8,
    EXPR_KIND_WINDOW_PARTITION = 9,
    EXPR_KIND_WINDOW_ORDER = 10,
    EXPR_KIND_WINDOW_FRAME_RANGE = 11,
    EXPR_KIND_WINDOW_FRAME_ROWS = 12,
    EXPR_KIND_WINDOW_FRAME_GROUPS = 13,
    EXPR_KIND_SELECT_TARGET = 14,
    EXPR_KIND_INSERT_TARGET = 15,
    EXPR_KIND_UPDATE_SOURCE = 16,
    EXPR_KIND_UPDATE_TARGET = 17,
    EXPR_KIND_GROUP_BY = 18,
    EXPR_KIND_ORDER_BY = 19,
    EXPR_KIND_DISTINCT_ON = 20,
    EXPR_KIND_LIMIT = 21,
    EXPR_KIND_OFFSET = 22,
    EXPR_KIND_RETURNING = 23,
    EXPR_KIND_VALUES = 24,
    EXPR_KIND_VALUES_SINGLE = 25,
    EXPR_KIND_CHECK_CONSTRAINT = 26,
    EXPR_KIND_DOMAIN_CHECK = 27,
    EXPR_KIND_COLUMN_DEFAULT = 28,
    EXPR_KIND_FUNCTION_DEFAULT = 29,
    EXPR_KIND_INDEX_EXPRESSION = 30,
    EXPR_KIND_INDEX_PREDICATE = 31,
    EXPR_KIND_ALTER_COL_TRANSFORM = 32,
    EXPR_KIND_EXECUTE_PARAMETER = 33,
    EXPR_KIND_TRIGGER_WHEN = 34,
    EXPR_KIND_POLICY = 35,
    EXPR_KIND_PARTITION_BOUND = 36,
    EXPR_KIND_PARTITION_EXPRESSION = 37,
    EXPR_KIND_CALL_ARGUMENT = 38,
    EXPR_KIND_COPY_WHERE = 39,
    EXPR_KIND_GENERATED_COLUMN = 40,
}
pub type PreParseColumnRefHook = ::std::option::Option<
    unsafe extern "C" fn(pstate: PgPtr<ParseState>, cref: PgPtr<ColumnRef>) -> PgPtr<Node>,
>;
pub type PostParseColumnRefHook = ::std::option::Option<
    unsafe extern "C" fn(
        pstate: PgPtr<ParseState>,
        cref: PgPtr<ColumnRef>,
        var: PgPtr<Node>,
    ) -> PgPtr<Node>,
>;
pub type ParseParamRefHook = ::std::option::Option<
    unsafe extern "C" fn(pstate: PgPtr<ParseState>, pref: PgPtr<ParamRef>) -> PgPtr<Node>,
>;
pub type CoerceParamHook = ::std::option::Option<
    unsafe extern "C" fn(
        pstate: PgPtr<ParseState>,
        param: PgPtr<Param>,
        targetTypeId: Oid,
        targetTypeMod: int32,
        location: ::std::os::raw::c_int,
    ) -> PgPtr<Node>,
>;
#[repr(C)]
pub struct ParseState {
    pub parentParseState: PgPtr<ParseState>,
    pub p_sourcetext: PgPtr<::std::os::raw::c_char>,
    pub p_rtable: PgPtr<List>,
    pub p_joinexprs: PgPtr<List>,
    pub p_joinlist: PgPtr<List>,
    pub p_namespace: PgPtr<List>,
    pub p_lateral_active: bool,
    pub p_ctenamespace: PgPtr<List>,
    pub p_future_ctes: PgPtr<List>,
    pub p_parent_cte: PgPtr<CommonTableExpr>,
    pub p_target_relation: PgPtr<RelationData>,
    pub p_target_rangetblentry: PgPtr<RangeTblEntry>,
    pub p_is_insert: bool,
    pub p_windowdefs: PgPtr<List>,
    pub p_expr_kind: ParseExprKind,
    pub p_next_resno: ::std::os::raw::c_int,
    pub p_multiassign_exprs: PgPtr<List>,
    pub p_locking_clause: PgPtr<List>,
    pub p_locked_from_parent: bool,
    pub p_resolve_unknowns: bool,
    pub p_queryEnv: PgPtr<QueryEnvironment>,
    pub p_hasAggs: bool,
    pub p_hasWindowFuncs: bool,
    pub p_hasTargetSRFs: bool,
    pub p_hasSubLinks: bool,
    pub p_hasModifyingCTE: bool,
    pub p_last_srf: PgPtr<Node>,
    pub p_pre_columnref_hook: PreParseColumnRefHook,
    pub p_post_columnref_hook: PostParseColumnRefHook,
    pub p_paramref_hook: ParseParamRefHook,
    pub p_coerce_param_hook: CoerceParamHook,
    pub p_ref_hook_state: PgPtr<::std::os::raw::c_void>,
}
#[repr(C)]
pub struct ParseNamespaceItem {
    pub p_rte: PgPtr<RangeTblEntry>,
    pub p_rel_visible: bool,
    pub p_cols_visible: bool,
    pub p_lateral_only: bool,
    pub p_lateral_ok: bool,
}
#[repr(C)]
pub struct ParseCallbackState {
    pub pstate: PgPtr<ParseState>,
    pub location: ::std::os::raw::c_int,
    pub errcallback: ErrorContextCallback,
}
#[pg_guard]
extern "C" {
    pub fn make_parsestate(parentParseState: PgPtr<ParseState>) -> PgPtr<ParseState>;
}
#[pg_guard]
extern "C" {
    pub fn free_parsestate(pstate: PgPtr<ParseState>);
}
#[pg_guard]
extern "C" {
    pub fn parser_errposition(
        pstate: PgPtr<ParseState>,
        location: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn setup_parser_errposition_callback(
        pcbstate: PgPtr<ParseCallbackState>,
        pstate: PgPtr<ParseState>,
        location: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn cancel_parser_errposition_callback(pcbstate: PgPtr<ParseCallbackState>);
}
#[pg_guard]
extern "C" {
    pub fn make_var(
        pstate: PgPtr<ParseState>,
        rte: PgPtr<RangeTblEntry>,
        attrno: ::std::os::raw::c_int,
        location: ::std::os::raw::c_int,
    ) -> PgPtr<Var>;
}
#[pg_guard]
extern "C" {
    pub fn transformContainerType(containerType: PgPtr<Oid>, containerTypmod: PgPtr<int32>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn transformContainerSubscripts(
        pstate: PgPtr<ParseState>,
        containerBase: PgPtr<Node>,
        containerType: Oid,
        elementType: Oid,
        containerTypMod: int32,
        indirection: PgPtr<List>,
        assignFrom: PgPtr<Node>,
    ) -> PgPtr<SubscriptingRef>;
}
#[pg_guard]
extern "C" {
    pub fn make_const(
        pstate: PgPtr<ParseState>,
        value: PgPtr<Value>,
        location: ::std::os::raw::c_int,
    ) -> PgPtr<Const>;
}
#[repr(C)]
pub struct AclItem {
    pub ai_grantee: Oid,
    pub ai_grantor: Oid,
    pub ai_privs: AclMode,
}
pub type Acl = ArrayType;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum AclMaskHow {
    ACLMASK_ALL = 0,
    ACLMASK_ANY = 1,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum AclResult {
    ACLCHECK_OK = 0,
    ACLCHECK_NO_PRIV = 1,
    ACLCHECK_NOT_OWNER = 2,
}
#[pg_guard]
extern "C" {
    pub fn acldefault(objtype: ObjectType, ownerId: Oid) -> PgPtr<Acl>;
}
#[pg_guard]
extern "C" {
    pub fn get_user_default_acl(objtype: ObjectType, ownerId: Oid, nsp_oid: Oid) -> PgPtr<Acl>;
}
#[pg_guard]
extern "C" {
    pub fn recordDependencyOnNewAcl(
        classId: Oid,
        objectId: Oid,
        objsubId: int32,
        ownerId: Oid,
        acl: PgPtr<Acl>,
    );
}
#[pg_guard]
extern "C" {
    pub fn aclupdate(
        old_acl: PgPtr<Acl>,
        mod_aip: PgPtr<AclItem>,
        modechg: ::std::os::raw::c_int,
        ownerId: Oid,
        behavior: DropBehavior,
    ) -> PgPtr<Acl>;
}
#[pg_guard]
extern "C" {
    pub fn aclnewowner(old_acl: PgPtr<Acl>, oldOwnerId: Oid, newOwnerId: Oid) -> PgPtr<Acl>;
}
#[pg_guard]
extern "C" {
    pub fn make_empty_acl() -> PgPtr<Acl>;
}
#[pg_guard]
extern "C" {
    pub fn aclcopy(orig_acl: PgPtr<Acl>) -> PgPtr<Acl>;
}
#[pg_guard]
extern "C" {
    pub fn aclconcat(left_acl: PgPtr<Acl>, right_acl: PgPtr<Acl>) -> PgPtr<Acl>;
}
#[pg_guard]
extern "C" {
    pub fn aclmerge(left_acl: PgPtr<Acl>, right_acl: PgPtr<Acl>, ownerId: Oid) -> PgPtr<Acl>;
}
#[pg_guard]
extern "C" {
    pub fn aclitemsort(acl: PgPtr<Acl>);
}
#[pg_guard]
extern "C" {
    pub fn aclequal(left_acl: PgPtr<Acl>, right_acl: PgPtr<Acl>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn aclmask(
        acl: PgPtr<Acl>,
        roleid: Oid,
        ownerId: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
#[pg_guard]
extern "C" {
    pub fn aclmembers(acl: PgPtr<Acl>, roleids: PgPtr<PgPtr<Oid>>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn has_privs_of_role(member: Oid, role: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn is_member_of_role(member: Oid, role: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn is_member_of_role_nosuper(member: Oid, role: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn is_admin_of_role(member: Oid, role: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn check_is_member_of_role(member: Oid, role: Oid);
}
#[pg_guard]
extern "C" {
    pub fn get_role_oid(rolename: PgPtr<::std::os::raw::c_char>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_role_oid_or_public(rolename: PgPtr<::std::os::raw::c_char>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_rolespec_oid(role: PgPtr<RoleSpec>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn check_rolespec_name(role: PgPtr<RoleSpec>, detail_msg: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn get_rolespec_tuple(role: PgPtr<RoleSpec>) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn get_rolespec_name(role: PgPtr<RoleSpec>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn select_best_grantor(
        roleId: Oid,
        privileges: AclMode,
        acl: PgPtr<Acl>,
        ownerId: Oid,
        grantorId: PgPtr<Oid>,
        grantOptions: PgPtr<AclMode>,
    );
}
#[pg_guard]
extern "C" {
    pub fn initialize_acl();
}
#[pg_guard]
extern "C" {
    pub fn ExecuteGrantStmt(stmt: PgPtr<GrantStmt>);
}
#[pg_guard]
extern "C" {
    pub fn ExecAlterDefaultPrivilegesStmt(
        pstate: PgPtr<ParseState>,
        stmt: PgPtr<AlterDefaultPrivilegesStmt>,
    );
}
#[pg_guard]
extern "C" {
    pub fn RemoveRoleFromObjectACL(roleid: Oid, classid: Oid, objid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn RemoveDefaultACLById(defaclOid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn pg_attribute_aclmask(
        table_oid: Oid,
        attnum: AttrNumber,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
#[pg_guard]
extern "C" {
    pub fn pg_class_aclmask(table_oid: Oid, roleid: Oid, mask: AclMode, how: AclMaskHow)
        -> AclMode;
}
#[pg_guard]
extern "C" {
    pub fn pg_database_aclmask(db_oid: Oid, roleid: Oid, mask: AclMode, how: AclMaskHow)
        -> AclMode;
}
#[pg_guard]
extern "C" {
    pub fn pg_proc_aclmask(proc_oid: Oid, roleid: Oid, mask: AclMode, how: AclMaskHow) -> AclMode;
}
#[pg_guard]
extern "C" {
    pub fn pg_language_aclmask(
        lang_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
#[pg_guard]
extern "C" {
    pub fn pg_largeobject_aclmask_snapshot(
        lobj_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
        snapshot: PgPtr<SnapshotData>,
    ) -> AclMode;
}
#[pg_guard]
extern "C" {
    pub fn pg_namespace_aclmask(
        nsp_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
#[pg_guard]
extern "C" {
    pub fn pg_tablespace_aclmask(
        spc_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
#[pg_guard]
extern "C" {
    pub fn pg_foreign_data_wrapper_aclmask(
        fdw_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
#[pg_guard]
extern "C" {
    pub fn pg_foreign_server_aclmask(
        srv_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
#[pg_guard]
extern "C" {
    pub fn pg_type_aclmask(type_oid: Oid, roleid: Oid, mask: AclMode, how: AclMaskHow) -> AclMode;
}
#[pg_guard]
extern "C" {
    pub fn pg_attribute_aclcheck(
        table_oid: Oid,
        attnum: AttrNumber,
        roleid: Oid,
        mode: AclMode,
    ) -> AclResult;
}
#[pg_guard]
extern "C" {
    pub fn pg_attribute_aclcheck_all(
        table_oid: Oid,
        roleid: Oid,
        mode: AclMode,
        how: AclMaskHow,
    ) -> AclResult;
}
#[pg_guard]
extern "C" {
    pub fn pg_class_aclcheck(table_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
#[pg_guard]
extern "C" {
    pub fn pg_database_aclcheck(db_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
#[pg_guard]
extern "C" {
    pub fn pg_proc_aclcheck(proc_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
#[pg_guard]
extern "C" {
    pub fn pg_language_aclcheck(lang_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
#[pg_guard]
extern "C" {
    pub fn pg_largeobject_aclcheck_snapshot(
        lang_oid: Oid,
        roleid: Oid,
        mode: AclMode,
        snapshot: PgPtr<SnapshotData>,
    ) -> AclResult;
}
#[pg_guard]
extern "C" {
    pub fn pg_namespace_aclcheck(nsp_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
#[pg_guard]
extern "C" {
    pub fn pg_tablespace_aclcheck(spc_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
#[pg_guard]
extern "C" {
    pub fn pg_foreign_data_wrapper_aclcheck(fdw_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
#[pg_guard]
extern "C" {
    pub fn pg_foreign_server_aclcheck(srv_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
#[pg_guard]
extern "C" {
    pub fn pg_type_aclcheck(type_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
#[pg_guard]
extern "C" {
    pub fn aclcheck_error(
        aclerr: AclResult,
        objtype: ObjectType,
        objectname: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn aclcheck_error_col(
        aclerr: AclResult,
        objtype: ObjectType,
        objectname: PgPtr<::std::os::raw::c_char>,
        colname: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn aclcheck_error_type(aclerr: AclResult, typeOid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn recordExtObjInitPriv(objoid: Oid, classoid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn removeExtObjInitPriv(objoid: Oid, classoid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn pg_class_ownercheck(class_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_type_ownercheck(type_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_oper_ownercheck(oper_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_proc_ownercheck(proc_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_language_ownercheck(lan_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_largeobject_ownercheck(lobj_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_namespace_ownercheck(nsp_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_tablespace_ownercheck(spc_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_opclass_ownercheck(opc_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_opfamily_ownercheck(opf_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_database_ownercheck(db_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_collation_ownercheck(coll_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_conversion_ownercheck(conv_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_ts_dict_ownercheck(dict_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_ts_config_ownercheck(cfg_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_foreign_data_wrapper_ownercheck(srv_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_foreign_server_ownercheck(srv_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_event_trigger_ownercheck(et_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_extension_ownercheck(ext_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_publication_ownercheck(pub_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_subscription_ownercheck(sub_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn pg_statistics_object_ownercheck(stat_oid: Oid, roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn has_createrole_privilege(roleid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn has_bypassrls_privilege(roleid: Oid) -> bool;
}
#[repr(C)]
pub struct ObjectAddress {
    pub classId: Oid,
    pub objectId: Oid,
    pub objectSubId: int32,
}
#[pg_guard]
extern "C" {
    pub static InvalidObjectAddress: ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn get_object_address(
        objtype: ObjectType,
        object: PgPtr<Node>,
        relp: PgPtr<PgPtr<RelationData>>,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn get_object_address_rv(
        objtype: ObjectType,
        rel: PgPtr<RangeVar>,
        object: PgPtr<List>,
        relp: PgPtr<PgPtr<RelationData>>,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn check_object_ownership(
        roleid: Oid,
        objtype: ObjectType,
        address: ObjectAddress,
        object: PgPtr<Node>,
        relation: PgPtr<RelationData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_object_namespace(address: PgPtr<ObjectAddress>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn is_objectclass_supported(class_id: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_object_oid_index(class_id: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_object_catcache_oid(class_id: Oid) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn get_object_catcache_name(class_id: Oid) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn get_object_attnum_oid(class_id: Oid) -> AttrNumber;
}
#[pg_guard]
extern "C" {
    pub fn get_object_attnum_name(class_id: Oid) -> AttrNumber;
}
#[pg_guard]
extern "C" {
    pub fn get_object_attnum_namespace(class_id: Oid) -> AttrNumber;
}
#[pg_guard]
extern "C" {
    pub fn get_object_attnum_owner(class_id: Oid) -> AttrNumber;
}
#[pg_guard]
extern "C" {
    pub fn get_object_attnum_acl(class_id: Oid) -> AttrNumber;
}
#[pg_guard]
extern "C" {
    pub fn get_object_type(class_id: Oid, object_id: Oid) -> ObjectType;
}
#[pg_guard]
extern "C" {
    pub fn get_object_namensp_unique(class_id: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_catalog_object_by_oid(
        catalog: PgPtr<RelationData>,
        oidcol: AttrNumber,
        objectId: Oid,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn getObjectDescription(object: PgPtr<ObjectAddress>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn getObjectDescriptionOids(classid: Oid, objid: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn read_objtype_from_string(
        objtype: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn getObjectTypeDescription(object: PgPtr<ObjectAddress>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn getObjectIdentity(address: PgPtr<ObjectAddress>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn getObjectIdentityParts(
        address: PgPtr<ObjectAddress>,
        objname: PgPtr<PgPtr<List>>,
        objargs: PgPtr<PgPtr<List>>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn strlist_to_textarray(list: PgPtr<List>) -> PgPtr<ArrayType>;
}
#[pg_guard]
extern "C" {
    pub fn get_relkind_objtype(relkind: ::std::os::raw::c_char) -> ObjectType;
}
#[repr(C)]
pub struct FormData_pg_publication {
    pub oid: Oid,
    pub pubname: NameData,
    pub pubowner: Oid,
    pub puballtables: bool,
    pub pubinsert: bool,
    pub pubupdate: bool,
    pub pubdelete: bool,
    pub pubtruncate: bool,
}
pub type Form_pg_publication = PgPtr<FormData_pg_publication>;
#[repr(C)]
pub struct PublicationActions {
    pub pubinsert: bool,
    pub pubupdate: bool,
    pub pubdelete: bool,
    pub pubtruncate: bool,
}
#[repr(C)]
pub struct Publication {
    pub oid: Oid,
    pub name: PgPtr<::std::os::raw::c_char>,
    pub alltables: bool,
    pub pubactions: PublicationActions,
}
#[pg_guard]
extern "C" {
    pub fn GetPublication(pubid: Oid) -> PgPtr<Publication>;
}
#[pg_guard]
extern "C" {
    pub fn GetPublicationByName(
        pubname: PgPtr<::std::os::raw::c_char>,
        missing_ok: bool,
    ) -> PgPtr<Publication>;
}
#[pg_guard]
extern "C" {
    pub fn GetRelationPublications(relid: Oid) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn GetPublicationRelations(pubid: Oid) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn GetAllTablesPublications() -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn GetAllTablesPublicationRelations() -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn is_publishable_relation(rel: PgPtr<RelationData>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn publication_add_relation(
        pubid: Oid,
        targetrel: PgPtr<RelationData>,
        if_not_exists: bool,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn get_publication_oid(pubname: PgPtr<::std::os::raw::c_char>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_publication_name(pubid: Oid, missing_ok: bool) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_publication_tables(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[repr(C)]
pub struct RewriteRule {
    pub ruleId: Oid,
    pub event: CmdType,
    pub qual: PgPtr<Node>,
    pub actions: PgPtr<List>,
    pub enabled: ::std::os::raw::c_char,
    pub isInstead: bool,
}
#[repr(C)]
pub struct RuleLock {
    pub numLocks: ::std::os::raw::c_int,
    pub rules: PgPtr<PgPtr<RewriteRule>>,
}
#[repr(C)]
pub struct LockRelId {
    pub relId: Oid,
    pub dbId: Oid,
}
#[repr(C)]
pub struct LockInfoData {
    pub lockRelId: LockRelId,
}
pub type LockInfo = PgPtr<LockInfoData>;
#[repr(C)]
pub struct RelationData {
    pub rd_node: RelFileNode,
    pub rd_smgr: PgPtr<SMgrRelationData>,
    pub rd_refcnt: ::std::os::raw::c_int,
    pub rd_backend: BackendId,
    pub rd_islocaltemp: bool,
    pub rd_isnailed: bool,
    pub rd_isvalid: bool,
    pub rd_indexvalid: bool,
    pub rd_statvalid: bool,
    pub rd_createSubid: SubTransactionId,
    pub rd_newRelfilenodeSubid: SubTransactionId,
    pub rd_rel: PgPtr<FormData_pg_class>,
    pub rd_att: PgPtr<TupleDescData>,
    pub rd_id: Oid,
    pub rd_lockInfo: LockInfoData,
    pub rd_rules: PgPtr<RuleLock>,
    pub rd_rulescxt: PgPtr<MemoryContextData>,
    pub trigdesc: PgPtr<TriggerDesc>,
    pub rd_rsdesc: PgPtr<RowSecurityDesc>,
    pub rd_fkeylist: PgPtr<List>,
    pub rd_fkeyvalid: bool,
    pub rd_partkey: PgPtr<PartitionKeyData>,
    pub rd_partkeycxt: PgPtr<MemoryContextData>,
    pub rd_partdesc: PgPtr<PartitionDescData>,
    pub rd_pdcxt: PgPtr<MemoryContextData>,
    pub rd_partcheck: PgPtr<List>,
    pub rd_partcheckvalid: bool,
    pub rd_partcheckcxt: PgPtr<MemoryContextData>,
    pub rd_indexlist: PgPtr<List>,
    pub rd_pkindex: Oid,
    pub rd_replidindex: Oid,
    pub rd_statlist: PgPtr<List>,
    pub rd_indexattr: PgPtr<Bitmapset>,
    pub rd_keyattr: PgPtr<Bitmapset>,
    pub rd_pkattr: PgPtr<Bitmapset>,
    pub rd_idattr: PgPtr<Bitmapset>,
    pub rd_pubactions: PgPtr<PublicationActions>,
    pub rd_options: PgPtr<bytea>,
    pub rd_amhandler: Oid,
    pub rd_tableam: PgPtr<TableAmRoutine>,
    pub rd_index: PgPtr<FormData_pg_index>,
    pub rd_indextuple: PgPtr<HeapTupleData>,
    pub rd_indexcxt: PgPtr<MemoryContextData>,
    pub rd_indam: PgPtr<IndexAmRoutine>,
    pub rd_opfamily: PgPtr<Oid>,
    pub rd_opcintype: PgPtr<Oid>,
    pub rd_support: PgPtr<RegProcedure>,
    pub rd_supportinfo: PgPtr<FmgrInfo>,
    pub rd_indoption: PgPtr<int16>,
    pub rd_indexprs: PgPtr<List>,
    pub rd_indpred: PgPtr<List>,
    pub rd_exclops: PgPtr<Oid>,
    pub rd_exclprocs: PgPtr<Oid>,
    pub rd_exclstrats: PgPtr<uint16>,
    pub rd_indcollation: PgPtr<Oid>,
    pub rd_amcache: PgPtr<::std::os::raw::c_void>,
    pub rd_fdwroutine: PgPtr<FdwRoutine>,
    pub rd_toastoid: Oid,
    pub pgstat_info: PgPtr<PgStat_TableStatus>,
}
#[repr(C)]
pub struct ForeignKeyCacheInfo {
    pub type_: NodeTag,
    pub conoid: Oid,
    pub conrelid: Oid,
    pub confrelid: Oid,
    pub nkeys: ::std::os::raw::c_int,
    pub conkey: [AttrNumber; 32usize],
    pub confkey: [AttrNumber; 32usize],
    pub conpfeqop: [Oid; 32usize],
}
#[repr(C)]
pub struct AutoVacOpts {
    pub enabled: bool,
    pub vacuum_threshold: ::std::os::raw::c_int,
    pub analyze_threshold: ::std::os::raw::c_int,
    pub vacuum_cost_limit: ::std::os::raw::c_int,
    pub freeze_min_age: ::std::os::raw::c_int,
    pub freeze_max_age: ::std::os::raw::c_int,
    pub freeze_table_age: ::std::os::raw::c_int,
    pub multixact_freeze_min_age: ::std::os::raw::c_int,
    pub multixact_freeze_max_age: ::std::os::raw::c_int,
    pub multixact_freeze_table_age: ::std::os::raw::c_int,
    pub log_min_duration: ::std::os::raw::c_int,
    pub vacuum_cost_delay: float8,
    pub vacuum_scale_factor: float8,
    pub analyze_scale_factor: float8,
}
#[repr(C)]
pub struct StdRdOptions {
    pub vl_len_: int32,
    pub fillfactor: ::std::os::raw::c_int,
    pub vacuum_cleanup_index_scale_factor: float8,
    pub toast_tuple_target: ::std::os::raw::c_int,
    pub autovacuum: AutoVacOpts,
    pub user_catalog_table: bool,
    pub parallel_workers: ::std::os::raw::c_int,
    pub vacuum_index_cleanup: bool,
    pub vacuum_truncate: bool,
}
#[repr(C)]
pub struct ViewOptions {
    pub vl_len_: int32,
    pub security_barrier: bool,
    pub check_option_offset: ::std::os::raw::c_int,
}
#[pg_guard]
extern "C" {
    pub fn RelationIncrementReferenceCount(rel: PgPtr<RelationData>);
}
#[pg_guard]
extern "C" {
    pub fn RelationDecrementReferenceCount(rel: PgPtr<RelationData>);
}
#[pg_guard]
extern "C" {
    pub fn RelationGetRepsetList(rel: PgPtr<RelationData>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub static mut default_table_access_method: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut synchronize_seqscans: bool;
}
#[repr(C)]
pub struct BulkInsertStateData {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct VacuumParams {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ScanOptions {
    SO_TYPE_SEQSCAN = 1,
    SO_TYPE_BITMAPSCAN = 2,
    SO_TYPE_SAMPLESCAN = 4,
    SO_TYPE_ANALYZE = 8,
    SO_TYPE_TIDSCAN = 256,
    SO_ALLOW_STRAT = 16,
    SO_ALLOW_SYNC = 32,
    SO_ALLOW_PAGEMODE = 64,
    SO_TEMP_SNAPSHOT = 128,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum TM_Result {
    TM_Ok = 0,
    TM_Invisible = 1,
    TM_SelfModified = 2,
    TM_Updated = 3,
    TM_Deleted = 4,
    TM_BeingModified = 5,
    TM_WouldBlock = 6,
}
#[repr(C)]
pub struct TM_FailureData {
    pub ctid: ItemPointerData,
    pub xmax: TransactionId,
    pub cmax: CommandId,
    pub traversed: bool,
}
pub type IndexBuildCallback = ::std::option::Option<
    unsafe extern "C" fn(
        index: PgPtr<RelationData>,
        htup: PgPtr<HeapTupleData>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
        tupleIsAlive: bool,
        state: PgPtr<::std::os::raw::c_void>,
    ),
>;
#[repr(C)]
pub struct TableAmRoutine {
    pub type_: NodeTag,
    pub slot_callbacks: ::std::option::Option<
        unsafe extern "C" fn(rel: PgPtr<RelationData>) -> PgPtr<TupleTableSlotOps>,
    >,
    pub scan_begin: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            snapshot: PgPtr<SnapshotData>,
            nkeys: ::std::os::raw::c_int,
            key: PgPtr<ScanKeyData>,
            pscan: PgPtr<ParallelTableScanDescData>,
            flags: uint32,
        ) -> PgPtr<TableScanDescData>,
    >,
    pub scan_end: ::std::option::Option<unsafe extern "C" fn(scan: PgPtr<TableScanDescData>)>,
    pub scan_rescan: ::std::option::Option<
        unsafe extern "C" fn(
            scan: PgPtr<TableScanDescData>,
            key: PgPtr<ScanKeyData>,
            set_params: bool,
            allow_strat: bool,
            allow_sync: bool,
            allow_pagemode: bool,
        ),
    >,
    pub scan_getnextslot: ::std::option::Option<
        unsafe extern "C" fn(
            scan: PgPtr<TableScanDescData>,
            direction: ScanDirection,
            slot: PgPtr<TupleTableSlot>,
        ) -> bool,
    >,
    pub parallelscan_estimate:
        ::std::option::Option<unsafe extern "C" fn(rel: PgPtr<RelationData>) -> Size>,
    pub parallelscan_initialize: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            pscan: PgPtr<ParallelTableScanDescData>,
        ) -> Size,
    >,
    pub parallelscan_reinitialize: ::std::option::Option<
        unsafe extern "C" fn(rel: PgPtr<RelationData>, pscan: PgPtr<ParallelTableScanDescData>),
    >,
    pub index_fetch_begin: ::std::option::Option<
        unsafe extern "C" fn(rel: PgPtr<RelationData>) -> PgPtr<IndexFetchTableData>,
    >,
    pub index_fetch_reset:
        ::std::option::Option<unsafe extern "C" fn(data: PgPtr<IndexFetchTableData>)>,
    pub index_fetch_end:
        ::std::option::Option<unsafe extern "C" fn(data: PgPtr<IndexFetchTableData>)>,
    pub index_fetch_tuple: ::std::option::Option<
        unsafe extern "C" fn(
            scan: PgPtr<IndexFetchTableData>,
            tid: PgPtr<ItemPointerData>,
            snapshot: PgPtr<SnapshotData>,
            slot: PgPtr<TupleTableSlot>,
            call_again: PgPtr<bool>,
            all_dead: PgPtr<bool>,
        ) -> bool,
    >,
    pub tuple_fetch_row_version: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            tid: PgPtr<ItemPointerData>,
            snapshot: PgPtr<SnapshotData>,
            slot: PgPtr<TupleTableSlot>,
        ) -> bool,
    >,
    pub tuple_tid_valid: ::std::option::Option<
        unsafe extern "C" fn(scan: PgPtr<TableScanDescData>, tid: PgPtr<ItemPointerData>) -> bool,
    >,
    pub tuple_get_latest_tid: ::std::option::Option<
        unsafe extern "C" fn(scan: PgPtr<TableScanDescData>, tid: PgPtr<ItemPointerData>),
    >,
    pub tuple_satisfies_snapshot: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            slot: PgPtr<TupleTableSlot>,
            snapshot: PgPtr<SnapshotData>,
        ) -> bool,
    >,
    pub compute_xid_horizon_for_tuples: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            items: PgPtr<ItemPointerData>,
            nitems: ::std::os::raw::c_int,
        ) -> TransactionId,
    >,
    pub tuple_insert: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            slot: PgPtr<TupleTableSlot>,
            cid: CommandId,
            options: ::std::os::raw::c_int,
            bistate: PgPtr<BulkInsertStateData>,
        ),
    >,
    pub tuple_insert_speculative: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            slot: PgPtr<TupleTableSlot>,
            cid: CommandId,
            options: ::std::os::raw::c_int,
            bistate: PgPtr<BulkInsertStateData>,
            specToken: uint32,
        ),
    >,
    pub tuple_complete_speculative: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            slot: PgPtr<TupleTableSlot>,
            specToken: uint32,
            succeeded: bool,
        ),
    >,
    pub multi_insert: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            slots: PgPtr<PgPtr<TupleTableSlot>>,
            nslots: ::std::os::raw::c_int,
            cid: CommandId,
            options: ::std::os::raw::c_int,
            bistate: PgPtr<BulkInsertStateData>,
        ),
    >,
    pub tuple_delete: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            tid: PgPtr<ItemPointerData>,
            cid: CommandId,
            snapshot: PgPtr<SnapshotData>,
            crosscheck: PgPtr<SnapshotData>,
            wait: bool,
            tmfd: PgPtr<TM_FailureData>,
            changingPart: bool,
        ) -> TM_Result,
    >,
    pub tuple_update: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            otid: PgPtr<ItemPointerData>,
            slot: PgPtr<TupleTableSlot>,
            cid: CommandId,
            snapshot: PgPtr<SnapshotData>,
            crosscheck: PgPtr<SnapshotData>,
            wait: bool,
            tmfd: PgPtr<TM_FailureData>,
            lockmode: PgPtr<LockTupleMode>,
            update_indexes: PgPtr<bool>,
        ) -> TM_Result,
    >,
    pub tuple_lock: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            tid: PgPtr<ItemPointerData>,
            snapshot: PgPtr<SnapshotData>,
            slot: PgPtr<TupleTableSlot>,
            cid: CommandId,
            mode: LockTupleMode,
            wait_policy: LockWaitPolicy,
            flags: uint8,
            tmfd: PgPtr<TM_FailureData>,
        ) -> TM_Result,
    >,
    pub finish_bulk_insert: ::std::option::Option<
        unsafe extern "C" fn(rel: PgPtr<RelationData>, options: ::std::os::raw::c_int),
    >,
    pub relation_set_new_filenode: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            newrnode: PgPtr<RelFileNode>,
            persistence: ::std::os::raw::c_char,
            freezeXid: PgPtr<TransactionId>,
            minmulti: PgPtr<MultiXactId>,
        ),
    >,
    pub relation_nontransactional_truncate:
        ::std::option::Option<unsafe extern "C" fn(rel: PgPtr<RelationData>)>,
    pub relation_copy_data: ::std::option::Option<
        unsafe extern "C" fn(rel: PgPtr<RelationData>, newrnode: PgPtr<RelFileNode>),
    >,
    pub relation_copy_for_cluster: ::std::option::Option<
        unsafe extern "C" fn(
            NewTable: PgPtr<RelationData>,
            OldTable: PgPtr<RelationData>,
            OldIndex: PgPtr<RelationData>,
            use_sort: bool,
            OldestXmin: TransactionId,
            xid_cutoff: PgPtr<TransactionId>,
            multi_cutoff: PgPtr<MultiXactId>,
            num_tuples: PgPtr<f64>,
            tups_vacuumed: PgPtr<f64>,
            tups_recently_dead: PgPtr<f64>,
        ),
    >,
    pub relation_vacuum: ::std::option::Option<
        unsafe extern "C" fn(
            onerel: PgPtr<RelationData>,
            params: PgPtr<VacuumParams>,
            bstrategy: PgPtr<BufferAccessStrategyData>,
        ),
    >,
    pub scan_analyze_next_block: ::std::option::Option<
        unsafe extern "C" fn(
            scan: PgPtr<TableScanDescData>,
            blockno: BlockNumber,
            bstrategy: PgPtr<BufferAccessStrategyData>,
        ) -> bool,
    >,
    pub scan_analyze_next_tuple: ::std::option::Option<
        unsafe extern "C" fn(
            scan: PgPtr<TableScanDescData>,
            OldestXmin: TransactionId,
            liverows: PgPtr<f64>,
            deadrows: PgPtr<f64>,
            slot: PgPtr<TupleTableSlot>,
        ) -> bool,
    >,
    pub index_build_range_scan: ::std::option::Option<
        unsafe extern "C" fn(
            table_rel: PgPtr<RelationData>,
            index_rel: PgPtr<RelationData>,
            index_info: PgPtr<IndexInfo>,
            allow_sync: bool,
            anyvisible: bool,
            progress: bool,
            start_blockno: BlockNumber,
            numblocks: BlockNumber,
            callback: IndexBuildCallback,
            callback_state: PgPtr<::std::os::raw::c_void>,
            scan: PgPtr<TableScanDescData>,
        ) -> f64,
    >,
    pub index_validate_scan: ::std::option::Option<
        unsafe extern "C" fn(
            table_rel: PgPtr<RelationData>,
            index_rel: PgPtr<RelationData>,
            index_info: PgPtr<IndexInfo>,
            snapshot: PgPtr<SnapshotData>,
            state: PgPtr<ValidateIndexState>,
        ),
    >,
    pub relation_size: ::std::option::Option<
        unsafe extern "C" fn(rel: PgPtr<RelationData>, forkNumber: ForkNumber) -> uint64,
    >,
    pub relation_needs_toast_table:
        ::std::option::Option<unsafe extern "C" fn(rel: PgPtr<RelationData>) -> bool>,
    pub relation_estimate_size: ::std::option::Option<
        unsafe extern "C" fn(
            rel: PgPtr<RelationData>,
            attr_widths: PgPtr<int32>,
            pages: PgPtr<BlockNumber>,
            tuples: PgPtr<f64>,
            allvisfrac: PgPtr<f64>,
        ),
    >,
    pub scan_bitmap_next_block: ::std::option::Option<
        unsafe extern "C" fn(
            scan: PgPtr<TableScanDescData>,
            tbmres: PgPtr<TBMIterateResult>,
        ) -> bool,
    >,
    pub scan_bitmap_next_tuple: ::std::option::Option<
        unsafe extern "C" fn(
            scan: PgPtr<TableScanDescData>,
            tbmres: PgPtr<TBMIterateResult>,
            slot: PgPtr<TupleTableSlot>,
        ) -> bool,
    >,
    pub scan_sample_next_block: ::std::option::Option<
        unsafe extern "C" fn(
            scan: PgPtr<TableScanDescData>,
            scanstate: PgPtr<SampleScanState>,
        ) -> bool,
    >,
    pub scan_sample_next_tuple: ::std::option::Option<
        unsafe extern "C" fn(
            scan: PgPtr<TableScanDescData>,
            scanstate: PgPtr<SampleScanState>,
            slot: PgPtr<TupleTableSlot>,
        ) -> bool,
    >,
}
#[pg_guard]
extern "C" {
    pub fn table_slot_callbacks(rel: PgPtr<RelationData>) -> PgPtr<TupleTableSlotOps>;
}
#[pg_guard]
extern "C" {
    pub fn table_slot_create(
        rel: PgPtr<RelationData>,
        reglist: PgPtr<PgPtr<List>>,
    ) -> PgPtr<TupleTableSlot>;
}
#[pg_guard]
extern "C" {
    pub fn table_beginscan_catalog(
        rel: PgPtr<RelationData>,
        nkeys: ::std::os::raw::c_int,
        key: PgPtr<ScanKeyData>,
    ) -> PgPtr<TableScanDescData>;
}
#[pg_guard]
extern "C" {
    pub fn table_scan_update_snapshot(
        scan: PgPtr<TableScanDescData>,
        snapshot: PgPtr<SnapshotData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn table_parallelscan_estimate(
        rel: PgPtr<RelationData>,
        snapshot: PgPtr<SnapshotData>,
    ) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn table_parallelscan_initialize(
        rel: PgPtr<RelationData>,
        pscan: PgPtr<ParallelTableScanDescData>,
        snapshot: PgPtr<SnapshotData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn table_beginscan_parallel(
        rel: PgPtr<RelationData>,
        pscan: PgPtr<ParallelTableScanDescData>,
    ) -> PgPtr<TableScanDescData>;
}
#[pg_guard]
extern "C" {
    pub fn table_index_fetch_tuple_check(
        rel: PgPtr<RelationData>,
        tid: PgPtr<ItemPointerData>,
        snapshot: PgPtr<SnapshotData>,
        all_dead: PgPtr<bool>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn table_tuple_get_latest_tid(scan: PgPtr<TableScanDescData>, tid: PgPtr<ItemPointerData>);
}
#[pg_guard]
extern "C" {
    pub fn simple_table_tuple_insert(rel: PgPtr<RelationData>, slot: PgPtr<TupleTableSlot>);
}
#[pg_guard]
extern "C" {
    pub fn simple_table_tuple_delete(
        rel: PgPtr<RelationData>,
        tid: PgPtr<ItemPointerData>,
        snapshot: PgPtr<SnapshotData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn simple_table_tuple_update(
        rel: PgPtr<RelationData>,
        otid: PgPtr<ItemPointerData>,
        slot: PgPtr<TupleTableSlot>,
        snapshot: PgPtr<SnapshotData>,
        update_indexes: PgPtr<bool>,
    );
}
#[pg_guard]
extern "C" {
    pub fn table_block_parallelscan_estimate(rel: PgPtr<RelationData>) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn table_block_parallelscan_initialize(
        rel: PgPtr<RelationData>,
        pscan: PgPtr<ParallelTableScanDescData>,
    ) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn table_block_parallelscan_reinitialize(
        rel: PgPtr<RelationData>,
        pscan: PgPtr<ParallelTableScanDescData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn table_block_parallelscan_nextpage(
        rel: PgPtr<RelationData>,
        pbscan: PgPtr<ParallelBlockTableScanDescData>,
    ) -> BlockNumber;
}
#[pg_guard]
extern "C" {
    pub fn table_block_parallelscan_startblock_init(
        rel: PgPtr<RelationData>,
        pbscan: PgPtr<ParallelBlockTableScanDescData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn GetTableAmRoutine(amhandler: Oid) -> PgPtr<TableAmRoutine>;
}
#[pg_guard]
extern "C" {
    pub fn GetHeapamTableAmRoutine() -> PgPtr<TableAmRoutine>;
}
#[pg_guard]
extern "C" {
    pub fn check_default_table_access_method(
        newval: PgPtr<PgPtr<::std::os::raw::c_char>>,
        extra: PgPtr<PgPtr<::std::os::raw::c_void>>,
        source: GucSource,
    ) -> bool;
}
#[repr(C)]
pub struct SharedInvalCatcacheMsg {
    pub id: int8,
    pub dbId: Oid,
    pub hashValue: uint32,
}
#[repr(C)]
pub struct SharedInvalCatalogMsg {
    pub id: int8,
    pub dbId: Oid,
    pub catId: Oid,
}
#[repr(C)]
pub struct SharedInvalRelcacheMsg {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
#[repr(C)]
pub struct SharedInvalSmgrMsg {
    pub id: int8,
    pub backend_hi: int8,
    pub backend_lo: uint16,
    pub rnode: RelFileNode,
}
#[repr(C)]
pub struct SharedInvalRelmapMsg {
    pub id: int8,
    pub dbId: Oid,
}
#[repr(C)]
pub struct SharedInvalSnapshotMsg {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
#[repr(C)]
pub struct SharedInvalidationMessage {
    pub id: __BindgenUnionField<int8>,
    pub cc: __BindgenUnionField<SharedInvalCatcacheMsg>,
    pub cat: __BindgenUnionField<SharedInvalCatalogMsg>,
    pub rc: __BindgenUnionField<SharedInvalRelcacheMsg>,
    pub sm: __BindgenUnionField<SharedInvalSmgrMsg>,
    pub rm: __BindgenUnionField<SharedInvalRelmapMsg>,
    pub sn: __BindgenUnionField<SharedInvalSnapshotMsg>,
    pub bindgen_union_field: [u32; 4usize],
}
#[pg_guard]
extern "C" {
    pub static mut SharedInvalidMessageCounter: uint64;
}
#[pg_guard]
extern "C" {
    pub static mut catchupInterruptPending: sig_atomic_t;
}
#[pg_guard]
extern "C" {
    pub fn SendSharedInvalidMessages(
        msgs: PgPtr<SharedInvalidationMessage>,
        n: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn ReceiveSharedInvalidMessages(
        invalFunction: ::std::option::Option<
            unsafe extern "C" fn(msg: PgPtr<SharedInvalidationMessage>),
        >,
        resetFunction: ::std::option::Option<unsafe extern "C" fn()>,
    );
}
#[pg_guard]
extern "C" {
    pub fn HandleCatchupInterrupt();
}
#[pg_guard]
extern "C" {
    pub fn ProcessCatchupInterrupt();
}
#[pg_guard]
extern "C" {
    pub fn xactGetCommittedInvalidationMessages(
        msgs: PgPtr<PgPtr<SharedInvalidationMessage>>,
        RelcacheInitFileInval: PgPtr<bool>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ProcessCommittedInvalidationMessages(
        msgs: PgPtr<SharedInvalidationMessage>,
        nmsgs: ::std::os::raw::c_int,
        RelcacheInitFileInval: bool,
        dbid: Oid,
        tsid: Oid,
    );
}
#[pg_guard]
extern "C" {
    pub fn LocalExecuteInvalidationMessage(msg: PgPtr<SharedInvalidationMessage>);
}
#[pg_guard]
extern "C" {
    pub static mut PgStartTime: TimestampTz;
}
#[pg_guard]
extern "C" {
    pub static mut PgReloadTime: TimestampTz;
}
#[pg_guard]
extern "C" {
    pub fn anytimestamp_typmod_check(istz: bool, typmod: int32) -> int32;
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentTimestamp() -> TimestampTz;
}
#[pg_guard]
extern "C" {
    pub fn GetSQLCurrentTimestamp(typmod: int32) -> TimestampTz;
}
#[pg_guard]
extern "C" {
    pub fn GetSQLLocalTimestamp(typmod: int32) -> Timestamp;
}
#[pg_guard]
extern "C" {
    pub fn TimestampDifference(
        start_time: TimestampTz,
        stop_time: TimestampTz,
        secs: PgPtr<::std::os::raw::c_long>,
        microsecs: PgPtr<::std::os::raw::c_int>,
    );
}
#[pg_guard]
extern "C" {
    pub fn TimestampDifferenceExceeds(
        start_time: TimestampTz,
        stop_time: TimestampTz,
        msec: ::std::os::raw::c_int,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn time_t_to_timestamptz(tm: pg_time_t) -> TimestampTz;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_to_time_t(t: TimestampTz) -> pg_time_t;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_to_str(t: TimestampTz) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn tm2timestamp(
        tm: PgPtr<pg_tm>,
        fsec: fsec_t,
        tzp: PgPtr<::std::os::raw::c_int>,
        dt: PgPtr<Timestamp>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn timestamp2tm(
        dt: Timestamp,
        tzp: PgPtr<::std::os::raw::c_int>,
        tm: PgPtr<pg_tm>,
        fsec: PgPtr<fsec_t>,
        tzn: PgPtr<PgPtr<::std::os::raw::c_char>>,
        attimezone: PgPtr<pg_tz>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn dt2time(
        dt: Timestamp,
        hour: PgPtr<::std::os::raw::c_int>,
        min: PgPtr<::std::os::raw::c_int>,
        sec: PgPtr<::std::os::raw::c_int>,
        fsec: PgPtr<fsec_t>,
    );
}
#[pg_guard]
extern "C" {
    pub fn interval2tm(
        span: Interval,
        tm: PgPtr<pg_tm>,
        fsec: PgPtr<fsec_t>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn tm2interval(
        tm: PgPtr<pg_tm>,
        fsec: fsec_t,
        span: PgPtr<Interval>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SetEpochTimestamp() -> Timestamp;
}
#[pg_guard]
extern "C" {
    pub fn GetEpochTime(tm: PgPtr<pg_tm>);
}
#[pg_guard]
extern "C" {
    pub fn timestamp_cmp_internal(dt1: Timestamp, dt2: Timestamp) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn isoweek2j(
        year: ::std::os::raw::c_int,
        week: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn isoweek2date(
        woy: ::std::os::raw::c_int,
        year: PgPtr<::std::os::raw::c_int>,
        mon: PgPtr<::std::os::raw::c_int>,
        mday: PgPtr<::std::os::raw::c_int>,
    );
}
#[pg_guard]
extern "C" {
    pub fn isoweekdate2date(
        isoweek: ::std::os::raw::c_int,
        wday: ::std::os::raw::c_int,
        year: PgPtr<::std::os::raw::c_int>,
        mon: PgPtr<::std::os::raw::c_int>,
        mday: PgPtr<::std::os::raw::c_int>,
    );
}
#[pg_guard]
extern "C" {
    pub fn date2isoweek(
        year: ::std::os::raw::c_int,
        mon: ::std::os::raw::c_int,
        mday: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn date2isoyear(
        year: ::std::os::raw::c_int,
        mon: ::std::os::raw::c_int,
        mday: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn date2isoyearday(
        year: ::std::os::raw::c_int,
        mon: ::std::os::raw::c_int,
        mday: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn TimestampTimestampTzRequiresRewrite() -> bool;
}
#[repr(C)]
pub struct tzEntry {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct datetkn {
    pub token: [::std::os::raw::c_char; 11usize],
    pub type_: ::std::os::raw::c_char,
    pub value: int32,
}
#[repr(C)]
pub struct TimeZoneAbbrevTable {
    pub tblsize: Size,
    pub numabbrevs: ::std::os::raw::c_int,
    pub abbrevs: __IncompleteArrayField<datetkn>,
}
#[repr(C)]
pub struct DynamicZoneAbbrev {
    pub tz: PgPtr<pg_tz>,
    pub zone: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[pg_guard]
extern "C" {
    pub static mut months: [*const ::std::os::raw::c_char; 0usize];
}
#[pg_guard]
extern "C" {
    pub static mut days: [*const ::std::os::raw::c_char; 0usize];
}
#[pg_guard]
extern "C" {
    pub static mut day_tab: [[::std::os::raw::c_int; 13usize]; 2usize];
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentDateTime(tm: PgPtr<pg_tm>);
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentTimeUsec(
        tm: PgPtr<pg_tm>,
        fsec: PgPtr<fsec_t>,
        tzp: PgPtr<::std::os::raw::c_int>,
    );
}
#[pg_guard]
extern "C" {
    pub fn j2date(
        jd: ::std::os::raw::c_int,
        year: PgPtr<::std::os::raw::c_int>,
        month: PgPtr<::std::os::raw::c_int>,
        day: PgPtr<::std::os::raw::c_int>,
    );
}
#[pg_guard]
extern "C" {
    pub fn date2j(
        year: ::std::os::raw::c_int,
        month: ::std::os::raw::c_int,
        day: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn ParseDateTime(
        timestr: PgPtr<::std::os::raw::c_char>,
        workbuf: PgPtr<::std::os::raw::c_char>,
        buflen: usize,
        field: PgPtr<PgPtr<::std::os::raw::c_char>>,
        ftype: PgPtr<::std::os::raw::c_int>,
        maxfields: ::std::os::raw::c_int,
        numfields: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn DecodeDateTime(
        field: PgPtr<PgPtr<::std::os::raw::c_char>>,
        ftype: PgPtr<::std::os::raw::c_int>,
        nf: ::std::os::raw::c_int,
        dtype: PgPtr<::std::os::raw::c_int>,
        tm: PgPtr<pg_tm>,
        fsec: PgPtr<fsec_t>,
        tzp: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn DecodeTimezone(
        str_: PgPtr<::std::os::raw::c_char>,
        tzp: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn DecodeTimeOnly(
        field: PgPtr<PgPtr<::std::os::raw::c_char>>,
        ftype: PgPtr<::std::os::raw::c_int>,
        nf: ::std::os::raw::c_int,
        dtype: PgPtr<::std::os::raw::c_int>,
        tm: PgPtr<pg_tm>,
        fsec: PgPtr<fsec_t>,
        tzp: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn DecodeInterval(
        field: PgPtr<PgPtr<::std::os::raw::c_char>>,
        ftype: PgPtr<::std::os::raw::c_int>,
        nf: ::std::os::raw::c_int,
        range: ::std::os::raw::c_int,
        dtype: PgPtr<::std::os::raw::c_int>,
        tm: PgPtr<pg_tm>,
        fsec: PgPtr<fsec_t>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn DecodeISO8601Interval(
        str_: PgPtr<::std::os::raw::c_char>,
        dtype: PgPtr<::std::os::raw::c_int>,
        tm: PgPtr<pg_tm>,
        fsec: PgPtr<fsec_t>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn DateTimeParseError(
        dterr: ::std::os::raw::c_int,
        str_: PgPtr<::std::os::raw::c_char>,
        datatype: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn DetermineTimeZoneOffset(tm: PgPtr<pg_tm>, tzp: PgPtr<pg_tz>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn DetermineTimeZoneAbbrevOffset(
        tm: PgPtr<pg_tm>,
        abbr: PgPtr<::std::os::raw::c_char>,
        tzp: PgPtr<pg_tz>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn DetermineTimeZoneAbbrevOffsetTS(
        ts: TimestampTz,
        abbr: PgPtr<::std::os::raw::c_char>,
        tzp: PgPtr<pg_tz>,
        isdst: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn EncodeDateOnly(
        tm: PgPtr<pg_tm>,
        style: ::std::os::raw::c_int,
        str_: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn EncodeTimeOnly(
        tm: PgPtr<pg_tm>,
        fsec: fsec_t,
        print_tz: bool,
        tz: ::std::os::raw::c_int,
        style: ::std::os::raw::c_int,
        str_: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn EncodeDateTime(
        tm: PgPtr<pg_tm>,
        fsec: fsec_t,
        print_tz: bool,
        tz: ::std::os::raw::c_int,
        tzn: PgPtr<::std::os::raw::c_char>,
        style: ::std::os::raw::c_int,
        str_: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn EncodeInterval(
        tm: PgPtr<pg_tm>,
        fsec: fsec_t,
        style: ::std::os::raw::c_int,
        str_: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn EncodeSpecialTimestamp(dt: Timestamp, str_: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn ValidateDate(
        fmask: ::std::os::raw::c_int,
        isjulian: bool,
        is2digits: bool,
        bc: bool,
        tm: PgPtr<pg_tm>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn DecodeTimezoneAbbrev(
        field: ::std::os::raw::c_int,
        lowtoken: PgPtr<::std::os::raw::c_char>,
        offset: PgPtr<::std::os::raw::c_int>,
        tz: PgPtr<PgPtr<pg_tz>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn DecodeSpecial(
        field: ::std::os::raw::c_int,
        lowtoken: PgPtr<::std::os::raw::c_char>,
        val: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn DecodeUnits(
        field: ::std::os::raw::c_int,
        lowtoken: PgPtr<::std::os::raw::c_char>,
        val: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn j2day(jd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn TemporalSimplify(max_precis: int32, node: PgPtr<Node>) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn CheckDateTokenTables() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ConvertTimeZoneAbbrevs(
        abbrevs: PgPtr<tzEntry>,
        n: ::std::os::raw::c_int,
    ) -> PgPtr<TimeZoneAbbrevTable>;
}
#[pg_guard]
extern "C" {
    pub fn InstallTimeZoneAbbrevs(tbl: PgPtr<TimeZoneAbbrevTable>);
}
#[pg_guard]
extern "C" {
    pub static mut DefaultXactIsoLevel: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut XactIsoLevel: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut DefaultXactReadOnly: bool;
}
#[pg_guard]
extern "C" {
    pub static mut XactReadOnly: bool;
}
#[pg_guard]
extern "C" {
    pub static mut xact_is_sampled: bool;
}
#[pg_guard]
extern "C" {
    pub static mut DefaultXactDeferrable: bool;
}
#[pg_guard]
extern "C" {
    pub static mut XactDeferrable: bool;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SyncCommitLevel {
    SYNCHRONOUS_COMMIT_OFF = 0,
    SYNCHRONOUS_COMMIT_LOCAL_FLUSH = 1,
    SYNCHRONOUS_COMMIT_REMOTE_WRITE = 2,
    SYNCHRONOUS_COMMIT_REMOTE_FLUSH = 3,
    SYNCHRONOUS_COMMIT_REMOTE_APPLY = 4,
}
#[pg_guard]
extern "C" {
    pub static mut synchronous_commit: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut MyXactFlags: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum XactEvent {
    XACT_EVENT_COMMIT = 0,
    XACT_EVENT_PARALLEL_COMMIT = 1,
    XACT_EVENT_ABORT = 2,
    XACT_EVENT_PARALLEL_ABORT = 3,
    XACT_EVENT_PREPARE = 4,
    XACT_EVENT_PRE_COMMIT = 5,
    XACT_EVENT_PARALLEL_PRE_COMMIT = 6,
    XACT_EVENT_PRE_PREPARE = 7,
}
pub type XactCallback = ::std::option::Option<
    unsafe extern "C" fn(event: XactEvent, arg: PgPtr<::std::os::raw::c_void>),
>;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SubXactEvent {
    SUBXACT_EVENT_START_SUB = 0,
    SUBXACT_EVENT_COMMIT_SUB = 1,
    SUBXACT_EVENT_ABORT_SUB = 2,
    SUBXACT_EVENT_PRE_COMMIT_SUB = 3,
}
pub type SubXactCallback = ::std::option::Option<
    unsafe extern "C" fn(
        event: SubXactEvent,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        arg: PgPtr<::std::os::raw::c_void>,
    ),
>;
#[repr(C)]
pub struct xl_xact_assignment {
    pub xtop: TransactionId,
    pub nsubxacts: ::std::os::raw::c_int,
    pub xsub: __IncompleteArrayField<TransactionId>,
}
#[repr(C)]
pub struct xl_xact_xinfo {
    pub xinfo: uint32,
}
#[repr(C)]
pub struct xl_xact_dbinfo {
    pub dbId: Oid,
    pub tsId: Oid,
}
#[repr(C)]
pub struct xl_xact_subxacts {
    pub nsubxacts: ::std::os::raw::c_int,
    pub subxacts: __IncompleteArrayField<TransactionId>,
}
#[repr(C)]
pub struct xl_xact_relfilenodes {
    pub nrels: ::std::os::raw::c_int,
    pub xnodes: __IncompleteArrayField<RelFileNode>,
}
#[repr(C)]
pub struct xl_xact_invals {
    pub nmsgs: ::std::os::raw::c_int,
    pub msgs: __IncompleteArrayField<SharedInvalidationMessage>,
}
#[repr(C)]
pub struct xl_xact_twophase {
    pub xid: TransactionId,
}
#[repr(C)]
pub struct xl_xact_origin {
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
#[repr(C)]
pub struct xl_xact_commit {
    pub xact_time: TimestampTz,
}
#[repr(C)]
pub struct xl_xact_abort {
    pub xact_time: TimestampTz,
}
#[repr(C)]
pub struct xl_xact_parsed_commit {
    pub xact_time: TimestampTz,
    pub xinfo: uint32,
    pub dbId: Oid,
    pub tsId: Oid,
    pub nsubxacts: ::std::os::raw::c_int,
    pub subxacts: PgPtr<TransactionId>,
    pub nrels: ::std::os::raw::c_int,
    pub xnodes: PgPtr<RelFileNode>,
    pub nmsgs: ::std::os::raw::c_int,
    pub msgs: PgPtr<SharedInvalidationMessage>,
    pub twophase_xid: TransactionId,
    pub twophase_gid: [::std::os::raw::c_char; 200usize],
    pub nabortrels: ::std::os::raw::c_int,
    pub abortnodes: PgPtr<RelFileNode>,
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
pub type xl_xact_parsed_prepare = xl_xact_parsed_commit;
#[repr(C)]
pub struct xl_xact_parsed_abort {
    pub xact_time: TimestampTz,
    pub xinfo: uint32,
    pub dbId: Oid,
    pub tsId: Oid,
    pub nsubxacts: ::std::os::raw::c_int,
    pub subxacts: PgPtr<TransactionId>,
    pub nrels: ::std::os::raw::c_int,
    pub xnodes: PgPtr<RelFileNode>,
    pub twophase_xid: TransactionId,
    pub twophase_gid: [::std::os::raw::c_char; 200usize],
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
#[pg_guard]
extern "C" {
    pub fn IsTransactionState() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn IsAbortedTransactionBlockState() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetTopTransactionId() -> TransactionId;
}
#[pg_guard]
extern "C" {
    pub fn GetTopTransactionIdIfAny() -> TransactionId;
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentTransactionId() -> TransactionId;
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentTransactionIdIfAny() -> TransactionId;
}
#[pg_guard]
extern "C" {
    pub fn GetStableLatestTransactionId() -> TransactionId;
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentSubTransactionId() -> SubTransactionId;
}
#[pg_guard]
extern "C" {
    pub fn GetTopFullTransactionId() -> FullTransactionId;
}
#[pg_guard]
extern "C" {
    pub fn GetTopFullTransactionIdIfAny() -> FullTransactionId;
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentFullTransactionId() -> FullTransactionId;
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentFullTransactionIdIfAny() -> FullTransactionId;
}
#[pg_guard]
extern "C" {
    pub fn MarkCurrentTransactionIdLoggedIfAny();
}
#[pg_guard]
extern "C" {
    pub fn SubTransactionIsActive(subxid: SubTransactionId) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentCommandId(used: bool) -> CommandId;
}
#[pg_guard]
extern "C" {
    pub fn SetParallelStartTimestamps(xact_ts: TimestampTz, stmt_ts: TimestampTz);
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentTransactionStartTimestamp() -> TimestampTz;
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentStatementStartTimestamp() -> TimestampTz;
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentTransactionStopTimestamp() -> TimestampTz;
}
#[pg_guard]
extern "C" {
    pub fn SetCurrentStatementStartTimestamp();
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentTransactionNestLevel() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdIsCurrentTransactionId(xid: TransactionId) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn CommandCounterIncrement();
}
#[pg_guard]
extern "C" {
    pub fn ForceSyncCommit();
}
#[pg_guard]
extern "C" {
    pub fn StartTransactionCommand();
}
#[pg_guard]
extern "C" {
    pub fn SaveTransactionCharacteristics();
}
#[pg_guard]
extern "C" {
    pub fn RestoreTransactionCharacteristics();
}
#[pg_guard]
extern "C" {
    pub fn CommitTransactionCommand();
}
#[pg_guard]
extern "C" {
    pub fn AbortCurrentTransaction();
}
#[pg_guard]
extern "C" {
    pub fn BeginTransactionBlock();
}
#[pg_guard]
extern "C" {
    pub fn EndTransactionBlock(chain: bool) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn PrepareTransactionBlock(gid: PgPtr<::std::os::raw::c_char>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn UserAbortTransactionBlock(chain: bool);
}
#[pg_guard]
extern "C" {
    pub fn BeginImplicitTransactionBlock();
}
#[pg_guard]
extern "C" {
    pub fn EndImplicitTransactionBlock();
}
#[pg_guard]
extern "C" {
    pub fn ReleaseSavepoint(name: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn DefineSavepoint(name: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn RollbackToSavepoint(name: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn BeginInternalSubTransaction(name: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn ReleaseCurrentSubTransaction();
}
#[pg_guard]
extern "C" {
    pub fn RollbackAndReleaseCurrentSubTransaction();
}
#[pg_guard]
extern "C" {
    pub fn IsSubTransaction() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn EstimateTransactionStateSpace() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn SerializeTransactionState(maxsize: Size, start_address: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn StartParallelWorkerTransaction(tstatespace: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn EndParallelWorkerTransaction();
}
#[pg_guard]
extern "C" {
    pub fn IsTransactionBlock() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn IsTransactionOrTransactionBlock() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn TransactionBlockStatusCode() -> ::std::os::raw::c_char;
}
#[pg_guard]
extern "C" {
    pub fn AbortOutOfAnyTransaction();
}
#[pg_guard]
extern "C" {
    pub fn PreventInTransactionBlock(isTopLevel: bool, stmtType: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn RequireTransactionBlock(isTopLevel: bool, stmtType: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn WarnNoTransactionBlock(isTopLevel: bool, stmtType: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn IsInTransactionBlock(isTopLevel: bool) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn RegisterXactCallback(callback: XactCallback, arg: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn UnregisterXactCallback(callback: XactCallback, arg: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn RegisterSubXactCallback(callback: SubXactCallback, arg: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn UnregisterSubXactCallback(callback: SubXactCallback, arg: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn xactGetCommittedChildren(ptr: PgPtr<PgPtr<TransactionId>>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn XactLogCommitRecord(
        commit_time: TimestampTz,
        nsubxacts: ::std::os::raw::c_int,
        subxacts: PgPtr<TransactionId>,
        nrels: ::std::os::raw::c_int,
        rels: PgPtr<RelFileNode>,
        nmsgs: ::std::os::raw::c_int,
        msgs: PgPtr<SharedInvalidationMessage>,
        relcacheInval: bool,
        forceSync: bool,
        xactflags: ::std::os::raw::c_int,
        twophase_xid: TransactionId,
        twophase_gid: PgPtr<::std::os::raw::c_char>,
    ) -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn XactLogAbortRecord(
        abort_time: TimestampTz,
        nsubxacts: ::std::os::raw::c_int,
        subxacts: PgPtr<TransactionId>,
        nrels: ::std::os::raw::c_int,
        rels: PgPtr<RelFileNode>,
        xactflags: ::std::os::raw::c_int,
        twophase_xid: TransactionId,
        twophase_gid: PgPtr<::std::os::raw::c_char>,
    ) -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn xact_redo(record: PgPtr<XLogReaderState>);
}
#[pg_guard]
extern "C" {
    pub fn xact_desc(buf: PgPtr<StringInfoData>, record: PgPtr<XLogReaderState>);
}
#[pg_guard]
extern "C" {
    pub fn xact_identify(info: uint8) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn ParseCommitRecord(
        info: uint8,
        xlrec: PgPtr<xl_xact_commit>,
        parsed: PgPtr<xl_xact_parsed_commit>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ParseAbortRecord(
        info: uint8,
        xlrec: PgPtr<xl_xact_abort>,
        parsed: PgPtr<xl_xact_parsed_abort>,
    );
}
#[pg_guard]
extern "C" {
    pub fn EnterParallelMode();
}
#[pg_guard]
extern "C" {
    pub fn ExitParallelMode();
}
#[pg_guard]
extern "C" {
    pub fn IsInParallelMode() -> bool;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum IndexStateFlagsAction {
    INDEX_CREATE_SET_READY = 0,
    INDEX_CREATE_SET_VALID = 1,
    INDEX_DROP_CLEAR_VALID = 2,
    INDEX_DROP_SET_DEAD = 3,
}
#[repr(C)]
pub struct ValidateIndexState {
    pub tuplesort: PgPtr<Tuplesortstate>,
    pub htups: f64,
    pub itups: f64,
    pub tups_inserted: f64,
}
#[pg_guard]
extern "C" {
    pub fn index_check_primary_key(
        heapRel: PgPtr<RelationData>,
        indexInfo: PgPtr<IndexInfo>,
        is_alter_table: bool,
        stmt: PgPtr<IndexStmt>,
    );
}
#[pg_guard]
extern "C" {
    pub fn index_create(
        heapRelation: PgPtr<RelationData>,
        indexRelationName: PgPtr<::std::os::raw::c_char>,
        indexRelationId: Oid,
        parentIndexRelid: Oid,
        parentConstraintId: Oid,
        relFileNode: Oid,
        indexInfo: PgPtr<IndexInfo>,
        indexColNames: PgPtr<List>,
        accessMethodObjectId: Oid,
        tableSpaceId: Oid,
        collationObjectId: PgPtr<Oid>,
        classObjectId: PgPtr<Oid>,
        coloptions: PgPtr<int16>,
        reloptions: Datum,
        flags: bits16,
        constr_flags: bits16,
        allow_system_table_mods: bool,
        is_internal: bool,
        constraintId: PgPtr<Oid>,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn index_concurrently_create_copy(
        heapRelation: PgPtr<RelationData>,
        oldIndexId: Oid,
        newName: PgPtr<::std::os::raw::c_char>,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn index_concurrently_build(heapRelationId: Oid, indexRelationId: Oid);
}
#[pg_guard]
extern "C" {
    pub fn index_concurrently_swap(
        newIndexId: Oid,
        oldIndexId: Oid,
        oldName: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn index_concurrently_set_dead(heapId: Oid, indexId: Oid);
}
#[pg_guard]
extern "C" {
    pub fn index_constraint_create(
        heapRelation: PgPtr<RelationData>,
        indexRelationId: Oid,
        parentConstraintId: Oid,
        indexInfo: PgPtr<IndexInfo>,
        constraintName: PgPtr<::std::os::raw::c_char>,
        constraintType: ::std::os::raw::c_char,
        constr_flags: bits16,
        allow_system_table_mods: bool,
        is_internal: bool,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn index_drop(indexId: Oid, concurrent: bool, concurrent_lock_mode: bool);
}
#[pg_guard]
extern "C" {
    pub fn BuildIndexInfo(index: PgPtr<RelationData>) -> PgPtr<IndexInfo>;
}
#[pg_guard]
extern "C" {
    pub fn BuildDummyIndexInfo(index: PgPtr<RelationData>) -> PgPtr<IndexInfo>;
}
#[pg_guard]
extern "C" {
    pub fn CompareIndexInfo(
        info1: PgPtr<IndexInfo>,
        info2: PgPtr<IndexInfo>,
        collations1: PgPtr<Oid>,
        collations2: PgPtr<Oid>,
        opfamilies1: PgPtr<Oid>,
        opfamilies2: PgPtr<Oid>,
        attmap: PgPtr<AttrNumber>,
        maplen: ::std::os::raw::c_int,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn BuildSpeculativeIndexInfo(index: PgPtr<RelationData>, ii: PgPtr<IndexInfo>);
}
#[pg_guard]
extern "C" {
    pub fn FormIndexDatum(
        indexInfo: PgPtr<IndexInfo>,
        slot: PgPtr<TupleTableSlot>,
        estate: PgPtr<EState>,
        values: PgPtr<Datum>,
        isnull: PgPtr<bool>,
    );
}
#[pg_guard]
extern "C" {
    pub fn index_build(
        heapRelation: PgPtr<RelationData>,
        indexRelation: PgPtr<RelationData>,
        indexInfo: PgPtr<IndexInfo>,
        isreindex: bool,
        parallel: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn validate_index(heapId: Oid, indexId: Oid, snapshot: PgPtr<SnapshotData>);
}
#[pg_guard]
extern "C" {
    pub fn index_set_state_flags(indexId: Oid, action: IndexStateFlagsAction);
}
#[pg_guard]
extern "C" {
    pub fn IndexGetRelation(indexId: Oid, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn reindex_index(
        indexId: Oid,
        skip_constraint_checks: bool,
        relpersistence: ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn reindex_relation(
        relid: Oid,
        flags: ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ReindexIsProcessingHeap(heapOid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ReindexIsProcessingIndex(indexOid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ResetReindexState(nestLevel: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn EstimateReindexStateSpace() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn SerializeReindexState(maxsize: Size, start_address: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn RestoreReindexState(reindexstate: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn IndexSetParentIndex(idx: PgPtr<RelationData>, parentOid: Oid);
}
#[repr(C)]
pub struct _FuncCandidateList {
    pub next: PgPtr<_FuncCandidateList>,
    pub pathpos: ::std::os::raw::c_int,
    pub oid: Oid,
    pub nargs: ::std::os::raw::c_int,
    pub nvargs: ::std::os::raw::c_int,
    pub ndargs: ::std::os::raw::c_int,
    pub argnumbers: PgPtr<::std::os::raw::c_int>,
    pub args: __IncompleteArrayField<Oid>,
}
pub type FuncCandidateList = PgPtr<_FuncCandidateList>;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum TempNamespaceStatus {
    TEMP_NAMESPACE_NOT_TEMP = 0,
    TEMP_NAMESPACE_IDLE = 1,
    TEMP_NAMESPACE_IN_USE = 2,
}
#[repr(C)]
pub struct OverrideSearchPath {
    pub schemas: PgPtr<List>,
    pub addCatalog: bool,
    pub addTemp: bool,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum RVROption {
    RVR_MISSING_OK = 1,
    RVR_NOWAIT = 2,
    RVR_SKIP_LOCKED = 4,
}
pub type RangeVarGetRelidCallback = ::std::option::Option<
    unsafe extern "C" fn(
        relation: PgPtr<RangeVar>,
        relId: Oid,
        oldRelId: Oid,
        callback_arg: PgPtr<::std::os::raw::c_void>,
    ),
>;
#[pg_guard]
extern "C" {
    pub fn RangeVarGetRelidExtended(
        relation: PgPtr<RangeVar>,
        lockmode: LOCKMODE,
        flags: uint32,
        callback: RangeVarGetRelidCallback,
        callback_arg: PgPtr<::std::os::raw::c_void>,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn RangeVarGetCreationNamespace(newRelation: PgPtr<RangeVar>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn RangeVarGetAndCheckCreationNamespace(
        newRelation: PgPtr<RangeVar>,
        lockmode: LOCKMODE,
        existing_relation_id: PgPtr<Oid>,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn RangeVarAdjustRelationPersistence(newRelation: PgPtr<RangeVar>, nspid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn RelnameGetRelid(relname: PgPtr<::std::os::raw::c_char>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn RelationIsVisible(relid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn TypenameGetTypid(typname: PgPtr<::std::os::raw::c_char>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn TypenameGetTypidExtended(typname: PgPtr<::std::os::raw::c_char>, temp_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn TypeIsVisible(typid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn FuncnameGetCandidates(
        names: PgPtr<List>,
        nargs: ::std::os::raw::c_int,
        argnames: PgPtr<List>,
        expand_variadic: bool,
        expand_defaults: bool,
        missing_ok: bool,
    ) -> PgPtr<_FuncCandidateList>;
}
#[pg_guard]
extern "C" {
    pub fn FunctionIsVisible(funcid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn OpernameGetOprid(names: PgPtr<List>, oprleft: Oid, oprright: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn OpernameGetCandidates(
        names: PgPtr<List>,
        oprkind: ::std::os::raw::c_char,
        missing_schema_ok: bool,
    ) -> PgPtr<_FuncCandidateList>;
}
#[pg_guard]
extern "C" {
    pub fn OperatorIsVisible(oprid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn OpclassnameGetOpcid(amid: Oid, opcname: PgPtr<::std::os::raw::c_char>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn OpclassIsVisible(opcid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn OpfamilynameGetOpfid(amid: Oid, opfname: PgPtr<::std::os::raw::c_char>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn OpfamilyIsVisible(opfid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn CollationGetCollid(collname: PgPtr<::std::os::raw::c_char>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn CollationIsVisible(collid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ConversionGetConid(conname: PgPtr<::std::os::raw::c_char>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn ConversionIsVisible(conid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_statistics_object_oid(names: PgPtr<List>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn StatisticsObjIsVisible(stxid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_ts_parser_oid(names: PgPtr<List>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn TSParserIsVisible(prsId: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_ts_dict_oid(names: PgPtr<List>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn TSDictionaryIsVisible(dictId: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_ts_template_oid(names: PgPtr<List>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn TSTemplateIsVisible(tmplId: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_ts_config_oid(names: PgPtr<List>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn TSConfigIsVisible(cfgid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn DeconstructQualifiedName(
        names: PgPtr<List>,
        nspname_p: PgPtr<PgPtr<::std::os::raw::c_char>>,
        objname_p: PgPtr<PgPtr<::std::os::raw::c_char>>,
    );
}
#[pg_guard]
extern "C" {
    pub fn LookupNamespaceNoError(nspname: PgPtr<::std::os::raw::c_char>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn LookupExplicitNamespace(nspname: PgPtr<::std::os::raw::c_char>, missing_ok: bool)
        -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_namespace_oid(nspname: PgPtr<::std::os::raw::c_char>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn LookupCreationNamespace(nspname: PgPtr<::std::os::raw::c_char>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn CheckSetNamespace(oldNspOid: Oid, nspOid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn QualifiedNameGetCreationNamespace(
        names: PgPtr<List>,
        objname_p: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn makeRangeVarFromNameList(names: PgPtr<List>) -> PgPtr<RangeVar>;
}
#[pg_guard]
extern "C" {
    pub fn NameListToString(names: PgPtr<List>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn NameListToQuotedString(names: PgPtr<List>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn isTempNamespace(namespaceId: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn isTempToastNamespace(namespaceId: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn isTempOrTempToastNamespace(namespaceId: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn isAnyTempNamespace(namespaceId: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn isOtherTempNamespace(namespaceId: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn checkTempNamespaceStatus(namespaceId: Oid) -> TempNamespaceStatus;
}
#[pg_guard]
extern "C" {
    pub fn isTempNamespaceInUse(namespaceId: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetTempNamespaceBackendId(namespaceId: Oid) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn GetTempToastNamespace() -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn GetTempNamespaceState(tempNamespaceId: PgPtr<Oid>, tempToastNamespaceId: PgPtr<Oid>);
}
#[pg_guard]
extern "C" {
    pub fn SetTempNamespaceState(tempNamespaceId: Oid, tempToastNamespaceId: Oid);
}
#[pg_guard]
extern "C" {
    pub fn ResetTempTableNamespace();
}
#[pg_guard]
extern "C" {
    pub fn GetOverrideSearchPath(context: PgPtr<MemoryContextData>) -> PgPtr<OverrideSearchPath>;
}
#[pg_guard]
extern "C" {
    pub fn CopyOverrideSearchPath(path: PgPtr<OverrideSearchPath>) -> PgPtr<OverrideSearchPath>;
}
#[pg_guard]
extern "C" {
    pub fn OverrideSearchPathMatchesCurrent(path: PgPtr<OverrideSearchPath>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn PushOverrideSearchPath(newpath: PgPtr<OverrideSearchPath>);
}
#[pg_guard]
extern "C" {
    pub fn PopOverrideSearchPath();
}
#[pg_guard]
extern "C" {
    pub fn get_collation_oid(collname: PgPtr<List>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_conversion_oid(conname: PgPtr<List>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn FindDefaultConversionProc(for_encoding: int32, to_encoding: int32) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn InitializeSearchPath();
}
#[pg_guard]
extern "C" {
    pub fn AtEOXact_Namespace(isCommit: bool, parallel: bool);
}
#[pg_guard]
extern "C" {
    pub fn AtEOSubXact_Namespace(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
}
#[pg_guard]
extern "C" {
    pub static mut namespace_search_path: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn fetch_search_path(includeImplicit: bool) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn fetch_search_path_array(
        sarray: PgPtr<Oid>,
        sarray_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct FormData_pg_enum {
    pub oid: Oid,
    pub enumtypid: Oid,
    pub enumsortorder: float4,
    pub enumlabel: NameData,
}
pub type Form_pg_enum = PgPtr<FormData_pg_enum>;
#[pg_guard]
extern "C" {
    pub fn EnumValuesCreate(enumTypeOid: Oid, vals: PgPtr<List>);
}
#[pg_guard]
extern "C" {
    pub fn EnumValuesDelete(enumTypeOid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn AddEnumLabel(
        enumTypeOid: Oid,
        newVal: PgPtr<::std::os::raw::c_char>,
        neighbor: PgPtr<::std::os::raw::c_char>,
        newValIsAfter: bool,
        skipIfExists: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn RenameEnumLabel(
        enumTypeOid: Oid,
        oldVal: PgPtr<::std::os::raw::c_char>,
        newVal: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn EnumBlacklisted(enum_id: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn EstimateEnumBlacklistSpace() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn SerializeEnumBlacklist(space: PgPtr<::std::os::raw::c_void>, size: Size);
}
#[pg_guard]
extern "C" {
    pub fn RestoreEnumBlacklist(space: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn AtEOXact_Enum();
}
#[repr(C)]
pub struct FormData_pg_proc {
    pub oid: Oid,
    pub proname: NameData,
    pub pronamespace: Oid,
    pub proowner: Oid,
    pub prolang: Oid,
    pub procost: float4,
    pub prorows: float4,
    pub provariadic: Oid,
    pub prosupport: regproc,
    pub prokind: ::std::os::raw::c_char,
    pub prosecdef: bool,
    pub proleakproof: bool,
    pub proisstrict: bool,
    pub proretset: bool,
    pub provolatile: ::std::os::raw::c_char,
    pub proparallel: ::std::os::raw::c_char,
    pub pronargs: int16,
    pub pronargdefaults: int16,
    pub prorettype: Oid,
    pub proargtypes: oidvector,
}
pub type Form_pg_proc = PgPtr<FormData_pg_proc>;
#[pg_guard]
extern "C" {
    pub fn ProcedureCreate(
        procedureName: PgPtr<::std::os::raw::c_char>,
        procNamespace: Oid,
        replace: bool,
        returnsSet: bool,
        returnType: Oid,
        proowner: Oid,
        languageObjectId: Oid,
        languageValidator: Oid,
        prosrc: PgPtr<::std::os::raw::c_char>,
        probin: PgPtr<::std::os::raw::c_char>,
        prokind: ::std::os::raw::c_char,
        security_definer: bool,
        isLeakProof: bool,
        isStrict: bool,
        volatility: ::std::os::raw::c_char,
        parallel: ::std::os::raw::c_char,
        parameterTypes: PgPtr<oidvector>,
        allParameterTypes: Datum,
        parameterModes: Datum,
        parameterNames: Datum,
        parameterDefaults: PgPtr<List>,
        trftypes: Datum,
        proconfig: Datum,
        prosupport: Oid,
        procost: float4,
        prorows: float4,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn function_parse_error_transpose(prosrc: PgPtr<::std::os::raw::c_char>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn oid_array_to_list(datum: Datum) -> PgPtr<List>;
}
#[repr(C)]
pub struct FormData_pg_type {
    pub oid: Oid,
    pub typname: NameData,
    pub typnamespace: Oid,
    pub typowner: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typtype: ::std::os::raw::c_char,
    pub typcategory: ::std::os::raw::c_char,
    pub typispreferred: bool,
    pub typisdefined: bool,
    pub typdelim: ::std::os::raw::c_char,
    pub typrelid: Oid,
    pub typelem: Oid,
    pub typarray: Oid,
    pub typinput: regproc,
    pub typoutput: regproc,
    pub typreceive: regproc,
    pub typsend: regproc,
    pub typmodin: regproc,
    pub typmodout: regproc,
    pub typanalyze: regproc,
    pub typalign: ::std::os::raw::c_char,
    pub typstorage: ::std::os::raw::c_char,
    pub typnotnull: bool,
    pub typbasetype: Oid,
    pub typtypmod: int32,
    pub typndims: int32,
    pub typcollation: Oid,
}
pub type Form_pg_type = PgPtr<FormData_pg_type>;
#[pg_guard]
extern "C" {
    pub fn TypeShellMake(
        typeName: PgPtr<::std::os::raw::c_char>,
        typeNamespace: Oid,
        ownerId: Oid,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn TypeCreate(
        newTypeOid: Oid,
        typeName: PgPtr<::std::os::raw::c_char>,
        typeNamespace: Oid,
        relationOid: Oid,
        relationKind: ::std::os::raw::c_char,
        ownerId: Oid,
        internalSize: int16,
        typeType: ::std::os::raw::c_char,
        typeCategory: ::std::os::raw::c_char,
        typePreferred: bool,
        typDelim: ::std::os::raw::c_char,
        inputProcedure: Oid,
        outputProcedure: Oid,
        receiveProcedure: Oid,
        sendProcedure: Oid,
        typmodinProcedure: Oid,
        typmodoutProcedure: Oid,
        analyzeProcedure: Oid,
        elementType: Oid,
        isImplicitArray: bool,
        arrayType: Oid,
        baseType: Oid,
        defaultTypeValue: PgPtr<::std::os::raw::c_char>,
        defaultTypeBin: PgPtr<::std::os::raw::c_char>,
        passedByValue: bool,
        alignment: ::std::os::raw::c_char,
        storage: ::std::os::raw::c_char,
        typeMod: int32,
        typNDims: int32,
        typeNotNull: bool,
        typeCollation: Oid,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn GenerateTypeDependencies(
        typeObjectId: Oid,
        typeForm: PgPtr<FormData_pg_type>,
        defaultExpr: PgPtr<Node>,
        typacl: PgPtr<::std::os::raw::c_void>,
        relationKind: ::std::os::raw::c_char,
        isImplicitArray: bool,
        isDependentType: bool,
        rebuild: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn RenameTypeInternal(
        typeOid: Oid,
        newTypeName: PgPtr<::std::os::raw::c_char>,
        typeNamespace: Oid,
    );
}
#[pg_guard]
extern "C" {
    pub fn makeArrayTypeName(
        typeName: PgPtr<::std::os::raw::c_char>,
        typeNamespace: Oid,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn moveArrayTypeName(
        typeOid: Oid,
        typeName: PgPtr<::std::os::raw::c_char>,
        typeNamespace: Oid,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn CommentObject(stmt: PgPtr<CommentStmt>) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn DeleteComments(oid: Oid, classoid: Oid, subid: int32);
}
#[pg_guard]
extern "C" {
    pub fn CreateComments(
        oid: Oid,
        classoid: Oid,
        subid: int32,
        comment: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn DeleteSharedComments(oid: Oid, classoid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn CreateSharedComments(oid: Oid, classoid: Oid, comment: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn GetComment(oid: Oid, classoid: Oid, subid: int32) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn createdb(pstate: PgPtr<ParseState>, stmt: PgPtr<CreatedbStmt>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn dropdb(dbname: PgPtr<::std::os::raw::c_char>, missing_ok: bool);
}
#[pg_guard]
extern "C" {
    pub fn RenameDatabase(
        oldname: PgPtr<::std::os::raw::c_char>,
        newname: PgPtr<::std::os::raw::c_char>,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn AlterDatabase(
        pstate: PgPtr<ParseState>,
        stmt: PgPtr<AlterDatabaseStmt>,
        isTopLevel: bool,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn AlterDatabaseSet(stmt: PgPtr<AlterDatabaseSetStmt>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn AlterDatabaseOwner(
        dbname: PgPtr<::std::os::raw::c_char>,
        newOwnerId: Oid,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn get_database_oid(dbname: PgPtr<::std::os::raw::c_char>, missingok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_database_name(dbid: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn check_encoding_locale_matches(
        encoding: ::std::os::raw::c_int,
        collate: PgPtr<::std::os::raw::c_char>,
        ctype: PgPtr<::std::os::raw::c_char>,
    );
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum DependencyType {
    DEPENDENCY_NORMAL = 110,
    DEPENDENCY_AUTO = 97,
    DEPENDENCY_INTERNAL = 105,
    DEPENDENCY_PARTITION_PRI = 80,
    DEPENDENCY_PARTITION_SEC = 83,
    DEPENDENCY_EXTENSION = 101,
    DEPENDENCY_AUTO_EXTENSION = 120,
    DEPENDENCY_PIN = 112,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SharedDependencyType {
    SHARED_DEPENDENCY_PIN = 112,
    SHARED_DEPENDENCY_OWNER = 111,
    SHARED_DEPENDENCY_ACL = 97,
    SHARED_DEPENDENCY_POLICY = 114,
    SHARED_DEPENDENCY_INVALID = 0,
}
#[repr(C)]
pub struct ObjectAddresses {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ObjectClass {
    OCLASS_CLASS = 0,
    OCLASS_PROC = 1,
    OCLASS_TYPE = 2,
    OCLASS_CAST = 3,
    OCLASS_COLLATION = 4,
    OCLASS_CONSTRAINT = 5,
    OCLASS_CONVERSION = 6,
    OCLASS_DEFAULT = 7,
    OCLASS_LANGUAGE = 8,
    OCLASS_LARGEOBJECT = 9,
    OCLASS_OPERATOR = 10,
    OCLASS_OPCLASS = 11,
    OCLASS_OPFAMILY = 12,
    OCLASS_AM = 13,
    OCLASS_AMOP = 14,
    OCLASS_AMPROC = 15,
    OCLASS_REWRITE = 16,
    OCLASS_TRIGGER = 17,
    OCLASS_SCHEMA = 18,
    OCLASS_STATISTIC_EXT = 19,
    OCLASS_TSPARSER = 20,
    OCLASS_TSDICT = 21,
    OCLASS_TSTEMPLATE = 22,
    OCLASS_TSCONFIG = 23,
    OCLASS_ROLE = 24,
    OCLASS_DATABASE = 25,
    OCLASS_TBLSPACE = 26,
    OCLASS_FDW = 27,
    OCLASS_FOREIGN_SERVER = 28,
    OCLASS_USER_MAPPING = 29,
    OCLASS_DEFACL = 30,
    OCLASS_EXTENSION = 31,
    OCLASS_EVENT_TRIGGER = 32,
    OCLASS_POLICY = 33,
    OCLASS_PUBLICATION = 34,
    OCLASS_PUBLICATION_REL = 35,
    OCLASS_SUBSCRIPTION = 36,
    OCLASS_TRANSFORM = 37,
}
#[pg_guard]
extern "C" {
    pub fn AcquireDeletionLock(object: PgPtr<ObjectAddress>, flags: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn ReleaseDeletionLock(object: PgPtr<ObjectAddress>);
}
#[pg_guard]
extern "C" {
    pub fn performDeletion(
        object: PgPtr<ObjectAddress>,
        behavior: DropBehavior,
        flags: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn performMultipleDeletions(
        objects: PgPtr<ObjectAddresses>,
        behavior: DropBehavior,
        flags: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn recordDependencyOnExpr(
        depender: PgPtr<ObjectAddress>,
        expr: PgPtr<Node>,
        rtable: PgPtr<List>,
        behavior: DependencyType,
    );
}
#[pg_guard]
extern "C" {
    pub fn recordDependencyOnSingleRelExpr(
        depender: PgPtr<ObjectAddress>,
        expr: PgPtr<Node>,
        relId: Oid,
        behavior: DependencyType,
        self_behavior: DependencyType,
        reverse_self: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn getObjectClass(object: PgPtr<ObjectAddress>) -> ObjectClass;
}
#[pg_guard]
extern "C" {
    pub fn new_object_addresses() -> PgPtr<ObjectAddresses>;
}
#[pg_guard]
extern "C" {
    pub fn add_exact_object_address(object: PgPtr<ObjectAddress>, addrs: PgPtr<ObjectAddresses>);
}
#[pg_guard]
extern "C" {
    pub fn object_address_present(
        object: PgPtr<ObjectAddress>,
        addrs: PgPtr<ObjectAddresses>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn record_object_address_dependencies(
        depender: PgPtr<ObjectAddress>,
        referenced: PgPtr<ObjectAddresses>,
        behavior: DependencyType,
    );
}
#[pg_guard]
extern "C" {
    pub fn sort_object_addresses(addrs: PgPtr<ObjectAddresses>);
}
#[pg_guard]
extern "C" {
    pub fn free_object_addresses(addrs: PgPtr<ObjectAddresses>);
}
#[pg_guard]
extern "C" {
    pub fn recordDependencyOn(
        depender: PgPtr<ObjectAddress>,
        referenced: PgPtr<ObjectAddress>,
        behavior: DependencyType,
    );
}
#[pg_guard]
extern "C" {
    pub fn recordMultipleDependencies(
        depender: PgPtr<ObjectAddress>,
        referenced: PgPtr<ObjectAddress>,
        nreferenced: ::std::os::raw::c_int,
        behavior: DependencyType,
    );
}
#[pg_guard]
extern "C" {
    pub fn recordDependencyOnCurrentExtension(object: PgPtr<ObjectAddress>, isReplace: bool);
}
#[pg_guard]
extern "C" {
    pub fn deleteDependencyRecordsFor(
        classId: Oid,
        objectId: Oid,
        skipExtensionDeps: bool,
    ) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn deleteDependencyRecordsForClass(
        classId: Oid,
        objectId: Oid,
        refclassId: Oid,
        deptype: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn changeDependencyFor(
        classId: Oid,
        objectId: Oid,
        refClassId: Oid,
        oldRefObjectId: Oid,
        newRefObjectId: Oid,
    ) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn changeDependenciesOf(
        classId: Oid,
        oldObjectId: Oid,
        newObjectId: Oid,
    ) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn changeDependenciesOn(
        refClassId: Oid,
        oldRefObjectId: Oid,
        newRefObjectId: Oid,
    ) -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn getExtensionOfObject(classId: Oid, objectId: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn getAutoExtensionsOfObject(classId: Oid, objectId: Oid) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn sequenceIsOwned(
        seqId: Oid,
        deptype: ::std::os::raw::c_char,
        tableId: PgPtr<Oid>,
        colId: PgPtr<int32>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn getOwnedSequences(relid: Oid, attnum: AttrNumber) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn getOwnedSequence(relid: Oid, attnum: AttrNumber) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_constraint_index(constraintId: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_index_constraint(indexId: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_index_ref_constraints(indexId: Oid) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn recordSharedDependencyOn(
        depender: PgPtr<ObjectAddress>,
        referenced: PgPtr<ObjectAddress>,
        deptype: SharedDependencyType,
    );
}
#[pg_guard]
extern "C" {
    pub fn deleteSharedDependencyRecordsFor(classId: Oid, objectId: Oid, objectSubId: int32);
}
#[pg_guard]
extern "C" {
    pub fn recordDependencyOnOwner(classId: Oid, objectId: Oid, owner: Oid);
}
#[pg_guard]
extern "C" {
    pub fn changeDependencyOnOwner(classId: Oid, objectId: Oid, newOwnerId: Oid);
}
#[pg_guard]
extern "C" {
    pub fn updateAclDependencies(
        classId: Oid,
        objectId: Oid,
        objectSubId: int32,
        ownerId: Oid,
        noldmembers: ::std::os::raw::c_int,
        oldmembers: PgPtr<Oid>,
        nnewmembers: ::std::os::raw::c_int,
        newmembers: PgPtr<Oid>,
    );
}
#[pg_guard]
extern "C" {
    pub fn checkSharedDependencies(
        classId: Oid,
        objectId: Oid,
        detail_msg: PgPtr<PgPtr<::std::os::raw::c_char>>,
        detail_log_msg: PgPtr<PgPtr<::std::os::raw::c_char>>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn shdepLockAndCheckObject(classId: Oid, objectId: Oid);
}
#[pg_guard]
extern "C" {
    pub fn copyTemplateDependencies(templateDbId: Oid, newDbId: Oid);
}
#[pg_guard]
extern "C" {
    pub fn dropDatabaseDependencies(databaseId: Oid);
}
#[pg_guard]
extern "C" {
    pub fn shdepDropOwned(relids: PgPtr<List>, behavior: DropBehavior);
}
#[pg_guard]
extern "C" {
    pub fn shdepReassignOwned(relids: PgPtr<List>, newrole: Oid);
}
#[repr(C)]
pub struct FormData_pg_event_trigger {
    pub oid: Oid,
    pub evtname: NameData,
    pub evtevent: NameData,
    pub evtowner: Oid,
    pub evtfoid: Oid,
    pub evtenabled: ::std::os::raw::c_char,
}
pub type Form_pg_event_trigger = PgPtr<FormData_pg_event_trigger>;
#[repr(C)]
pub struct InternalGrant {
    pub is_grant: bool,
    pub objtype: ObjectType,
    pub objects: PgPtr<List>,
    pub all_privs: bool,
    pub privileges: AclMode,
    pub col_privs: PgPtr<List>,
    pub grantees: PgPtr<List>,
    pub grant_option: bool,
    pub behavior: DropBehavior,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum CollectedCommandType {
    SCT_Simple = 0,
    SCT_AlterTable = 1,
    SCT_Grant = 2,
    SCT_AlterOpFamily = 3,
    SCT_AlterDefaultPrivileges = 4,
    SCT_CreateOpClass = 5,
    SCT_AlterTSConfig = 6,
}
#[repr(C)]
pub struct CollectedATSubcmd {
    pub address: ObjectAddress,
    pub parsetree: PgPtr<Node>,
}
#[repr(C)]
pub struct CollectedCommand {
    pub type_: CollectedCommandType,
    pub in_extension: bool,
    pub parsetree: PgPtr<Node>,
    pub d: CollectedCommand__bindgen_ty_1,
    pub parent: PgPtr<CollectedCommand>,
}
#[repr(C)]
pub struct CollectedCommand__bindgen_ty_1 {
    pub simple: __BindgenUnionField<CollectedCommand__bindgen_ty_1__bindgen_ty_1>,
    pub alterTable: __BindgenUnionField<CollectedCommand__bindgen_ty_1__bindgen_ty_2>,
    pub grant: __BindgenUnionField<CollectedCommand__bindgen_ty_1__bindgen_ty_3>,
    pub opfam: __BindgenUnionField<CollectedCommand__bindgen_ty_1__bindgen_ty_4>,
    pub createopc: __BindgenUnionField<CollectedCommand__bindgen_ty_1__bindgen_ty_5>,
    pub atscfg: __BindgenUnionField<CollectedCommand__bindgen_ty_1__bindgen_ty_6>,
    pub defprivs: __BindgenUnionField<CollectedCommand__bindgen_ty_1__bindgen_ty_7>,
    pub bindgen_union_field: [u64; 4usize],
}
#[repr(C)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_1 {
    pub address: ObjectAddress,
    pub secondaryObject: ObjectAddress,
}
#[repr(C)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_2 {
    pub objectId: Oid,
    pub classId: Oid,
    pub subcmds: PgPtr<List>,
}
#[repr(C)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_3 {
    pub istmt: PgPtr<InternalGrant>,
}
#[repr(C)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_4 {
    pub address: ObjectAddress,
    pub operators: PgPtr<List>,
    pub procedures: PgPtr<List>,
}
#[repr(C)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_5 {
    pub address: ObjectAddress,
    pub operators: PgPtr<List>,
    pub procedures: PgPtr<List>,
}
#[repr(C)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_6 {
    pub address: ObjectAddress,
    pub dictIds: PgPtr<Oid>,
    pub ndicts: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_7 {
    pub objtype: ObjectType,
}
#[repr(C)]
pub struct EventTriggerData {
    pub type_: NodeTag,
    pub event: PgPtr<::std::os::raw::c_char>,
    pub parsetree: PgPtr<Node>,
    pub tag: PgPtr<::std::os::raw::c_char>,
}
#[pg_guard]
extern "C" {
    pub fn CreateEventTrigger(stmt: PgPtr<CreateEventTrigStmt>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn RemoveEventTriggerById(trigOid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn get_event_trigger_oid(trigname: PgPtr<::std::os::raw::c_char>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn AlterEventTrigger(stmt: PgPtr<AlterEventTrigStmt>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn AlterEventTriggerOwner(
        name: PgPtr<::std::os::raw::c_char>,
        newOwnerId: Oid,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn AlterEventTriggerOwner_oid(arg1: Oid, newOwnerId: Oid);
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerSupportsObjectType(obtype: ObjectType) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerSupportsObjectClass(objclass: ObjectClass) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerDDLCommandStart(parsetree: PgPtr<Node>);
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerDDLCommandEnd(parsetree: PgPtr<Node>);
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerSQLDrop(parsetree: PgPtr<Node>);
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerTableRewrite(
        parsetree: PgPtr<Node>,
        tableOid: Oid,
        reason: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerBeginCompleteQuery() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerEndCompleteQuery();
}
#[pg_guard]
extern "C" {
    pub fn trackDroppedObjectsNeeded() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerSQLDropAddObject(object: PgPtr<ObjectAddress>, original: bool, normal: bool);
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerInhibitCommandCollection();
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerUndoInhibitCommandCollection();
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerCollectSimpleCommand(
        address: ObjectAddress,
        secondaryObject: ObjectAddress,
        parsetree: PgPtr<Node>,
    );
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerAlterTableStart(parsetree: PgPtr<Node>);
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerAlterTableRelid(objectId: Oid);
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerCollectAlterTableSubcmd(subcmd: PgPtr<Node>, address: ObjectAddress);
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerAlterTableEnd();
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerCollectGrant(istmt: PgPtr<InternalGrant>);
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerCollectAlterOpFam(
        stmt: PgPtr<AlterOpFamilyStmt>,
        opfamoid: Oid,
        operators: PgPtr<List>,
        procedures: PgPtr<List>,
    );
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerCollectCreateOpClass(
        stmt: PgPtr<CreateOpClassStmt>,
        opcoid: Oid,
        operators: PgPtr<List>,
        procedures: PgPtr<List>,
    );
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerCollectAlterTSConfig(
        stmt: PgPtr<AlterTSConfigurationStmt>,
        cfgId: Oid,
        dictIds: PgPtr<Oid>,
        ndicts: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn EventTriggerCollectAlterDefPrivs(stmt: PgPtr<AlterDefaultPrivilegesStmt>);
}
#[pg_guard]
extern "C" {
    pub fn CreateProceduralLanguage(stmt: PgPtr<CreatePLangStmt>) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn DropProceduralLanguageById(langOid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn PLTemplateExists(languageName: PgPtr<::std::os::raw::c_char>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_language_oid(langname: PgPtr<::std::os::raw::c_char>, missing_ok: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn DefineRelation(
        stmt: PgPtr<CreateStmt>,
        relkind: ::std::os::raw::c_char,
        ownerId: Oid,
        typaddress: PgPtr<ObjectAddress>,
        queryString: PgPtr<::std::os::raw::c_char>,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn RemoveRelations(drop: PgPtr<DropStmt>);
}
#[pg_guard]
extern "C" {
    pub fn AlterTableLookupRelation(stmt: PgPtr<AlterTableStmt>, lockmode: LOCKMODE) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn AlterTable(relid: Oid, lockmode: LOCKMODE, stmt: PgPtr<AlterTableStmt>);
}
#[pg_guard]
extern "C" {
    pub fn AlterTableGetLockLevel(cmds: PgPtr<List>) -> LOCKMODE;
}
#[pg_guard]
extern "C" {
    pub fn ATExecChangeOwner(
        relationOid: Oid,
        newOwnerId: Oid,
        recursing: bool,
        lockmode: LOCKMODE,
    );
}
#[pg_guard]
extern "C" {
    pub fn AlterTableInternal(relid: Oid, cmds: PgPtr<List>, recurse: bool);
}
#[pg_guard]
extern "C" {
    pub fn AlterTableMoveAll(stmt: PgPtr<AlterTableMoveAllStmt>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn AlterTableNamespace(
        stmt: PgPtr<AlterObjectSchemaStmt>,
        oldschema: PgPtr<Oid>,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn AlterTableNamespaceInternal(
        rel: PgPtr<RelationData>,
        oldNspOid: Oid,
        nspOid: Oid,
        objsMoved: PgPtr<ObjectAddresses>,
    );
}
#[pg_guard]
extern "C" {
    pub fn AlterRelationNamespaceInternal(
        classRel: PgPtr<RelationData>,
        relOid: Oid,
        oldNspOid: Oid,
        newNspOid: Oid,
        hasDependEntry: bool,
        objsMoved: PgPtr<ObjectAddresses>,
    );
}
#[pg_guard]
extern "C" {
    pub fn CheckTableNotInUse(rel: PgPtr<RelationData>, stmt: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn ExecuteTruncate(stmt: PgPtr<TruncateStmt>);
}
#[pg_guard]
extern "C" {
    pub fn ExecuteTruncateGuts(
        explicit_rels: PgPtr<List>,
        relids: PgPtr<List>,
        relids_logged: PgPtr<List>,
        behavior: DropBehavior,
        restart_seqs: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn SetRelationHasSubclass(relationId: Oid, relhassubclass: bool);
}
#[pg_guard]
extern "C" {
    pub fn renameatt(stmt: PgPtr<RenameStmt>) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn renameatt_type(stmt: PgPtr<RenameStmt>) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn RenameConstraint(stmt: PgPtr<RenameStmt>) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn RenameRelation(stmt: PgPtr<RenameStmt>) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn RenameRelationInternal(
        myrelid: Oid,
        newrelname: PgPtr<::std::os::raw::c_char>,
        is_internal: bool,
        is_index: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn find_composite_type_dependencies(
        typeOid: Oid,
        origRelation: PgPtr<RelationData>,
        origTypeName: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn check_of_type(typetuple: PgPtr<HeapTupleData>);
}
#[pg_guard]
extern "C" {
    pub fn register_on_commit_action(relid: Oid, action: OnCommitAction);
}
#[pg_guard]
extern "C" {
    pub fn remove_on_commit_action(relid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn PreCommit_on_commit_actions();
}
#[pg_guard]
extern "C" {
    pub fn AtEOXact_on_commit_actions(isCommit: bool);
}
#[pg_guard]
extern "C" {
    pub fn AtEOSubXact_on_commit_actions(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
}
#[pg_guard]
extern "C" {
    pub fn RangeVarCallbackOwnsTable(
        relation: PgPtr<RangeVar>,
        relId: Oid,
        oldRelId: Oid,
        arg: PgPtr<::std::os::raw::c_void>,
    );
}
#[pg_guard]
extern "C" {
    pub fn RangeVarCallbackOwnsRelation(
        relation: PgPtr<RangeVar>,
        relId: Oid,
        oldRelId: Oid,
        noCatalogs: PgPtr<::std::os::raw::c_void>,
    );
}
#[pg_guard]
extern "C" {
    pub fn PartConstraintImpliedByRelConstraint(
        scanrel: PgPtr<RelationData>,
        partConstraint: PgPtr<List>,
    ) -> bool;
}
#[repr(C)]
pub struct FormData_pg_trigger {
    pub oid: Oid,
    pub tgrelid: Oid,
    pub tgname: NameData,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::std::os::raw::c_char,
    pub tgisinternal: bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: bool,
    pub tginitdeferred: bool,
    pub tgnargs: int16,
    pub tgattr: int2vector,
}
pub type Form_pg_trigger = PgPtr<FormData_pg_trigger>;
pub type TriggerEvent = uint32;
#[repr(C)]
pub struct TriggerData {
    pub type_: NodeTag,
    pub tg_event: TriggerEvent,
    pub tg_relation: PgPtr<RelationData>,
    pub tg_trigtuple: PgPtr<HeapTupleData>,
    pub tg_newtuple: PgPtr<HeapTupleData>,
    pub tg_trigger: PgPtr<Trigger>,
    pub tg_trigslot: PgPtr<TupleTableSlot>,
    pub tg_newslot: PgPtr<TupleTableSlot>,
    pub tg_oldtable: PgPtr<Tuplestorestate>,
    pub tg_newtable: PgPtr<Tuplestorestate>,
}
#[repr(C)]
pub struct AfterTriggersTableData {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct TransitionCaptureState {
    pub tcs_delete_old_table: bool,
    pub tcs_update_old_table: bool,
    pub tcs_update_new_table: bool,
    pub tcs_insert_new_table: bool,
    pub tcs_map: PgPtr<TupleConversionMap>,
    pub tcs_original_insert_tuple: PgPtr<TupleTableSlot>,
    pub tcs_private: PgPtr<AfterTriggersTableData>,
}
#[pg_guard]
extern "C" {
    pub static mut SessionReplicationRole: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn CreateTrigger(
        stmt: PgPtr<CreateTrigStmt>,
        queryString: PgPtr<::std::os::raw::c_char>,
        relOid: Oid,
        refRelOid: Oid,
        constraintOid: Oid,
        indexOid: Oid,
        funcoid: Oid,
        parentTriggerOid: Oid,
        whenClause: PgPtr<Node>,
        isInternal: bool,
        in_partition: bool,
    ) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn RemoveTriggerById(trigOid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn get_trigger_oid(
        relid: Oid,
        name: PgPtr<::std::os::raw::c_char>,
        missing_ok: bool,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn renametrig(stmt: PgPtr<RenameStmt>) -> ObjectAddress;
}
#[pg_guard]
extern "C" {
    pub fn EnableDisableTrigger(
        rel: PgPtr<RelationData>,
        tgname: PgPtr<::std::os::raw::c_char>,
        fires_when: ::std::os::raw::c_char,
        skip_system: bool,
        lockmode: LOCKMODE,
    );
}
#[pg_guard]
extern "C" {
    pub fn RelationBuildTriggers(relation: PgPtr<RelationData>);
}
#[pg_guard]
extern "C" {
    pub fn CopyTriggerDesc(trigdesc: PgPtr<TriggerDesc>) -> PgPtr<TriggerDesc>;
}
#[pg_guard]
extern "C" {
    pub fn FindTriggerIncompatibleWithInheritance(
        trigdesc: PgPtr<TriggerDesc>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn MakeTransitionCaptureState(
        trigdesc: PgPtr<TriggerDesc>,
        relid: Oid,
        cmdType: CmdType,
    ) -> PgPtr<TransitionCaptureState>;
}
#[pg_guard]
extern "C" {
    pub fn FreeTriggerDesc(trigdesc: PgPtr<TriggerDesc>);
}
#[pg_guard]
extern "C" {
    pub fn ExecBSInsertTriggers(estate: PgPtr<EState>, relinfo: PgPtr<ResultRelInfo>);
}
#[pg_guard]
extern "C" {
    pub fn ExecASInsertTriggers(
        estate: PgPtr<EState>,
        relinfo: PgPtr<ResultRelInfo>,
        transition_capture: PgPtr<TransitionCaptureState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecBRInsertTriggers(
        estate: PgPtr<EState>,
        relinfo: PgPtr<ResultRelInfo>,
        slot: PgPtr<TupleTableSlot>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecARInsertTriggers(
        estate: PgPtr<EState>,
        relinfo: PgPtr<ResultRelInfo>,
        slot: PgPtr<TupleTableSlot>,
        recheckIndexes: PgPtr<List>,
        transition_capture: PgPtr<TransitionCaptureState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecIRInsertTriggers(
        estate: PgPtr<EState>,
        relinfo: PgPtr<ResultRelInfo>,
        slot: PgPtr<TupleTableSlot>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecBSDeleteTriggers(estate: PgPtr<EState>, relinfo: PgPtr<ResultRelInfo>);
}
#[pg_guard]
extern "C" {
    pub fn ExecASDeleteTriggers(
        estate: PgPtr<EState>,
        relinfo: PgPtr<ResultRelInfo>,
        transition_capture: PgPtr<TransitionCaptureState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecBRDeleteTriggers(
        estate: PgPtr<EState>,
        epqstate: PgPtr<EPQState>,
        relinfo: PgPtr<ResultRelInfo>,
        tupleid: PgPtr<ItemPointerData>,
        fdw_trigtuple: PgPtr<HeapTupleData>,
        epqslot: PgPtr<PgPtr<TupleTableSlot>>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecARDeleteTriggers(
        estate: PgPtr<EState>,
        relinfo: PgPtr<ResultRelInfo>,
        tupleid: PgPtr<ItemPointerData>,
        fdw_trigtuple: PgPtr<HeapTupleData>,
        transition_capture: PgPtr<TransitionCaptureState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecIRDeleteTriggers(
        estate: PgPtr<EState>,
        relinfo: PgPtr<ResultRelInfo>,
        trigtuple: PgPtr<HeapTupleData>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecBSUpdateTriggers(estate: PgPtr<EState>, relinfo: PgPtr<ResultRelInfo>);
}
#[pg_guard]
extern "C" {
    pub fn ExecASUpdateTriggers(
        estate: PgPtr<EState>,
        relinfo: PgPtr<ResultRelInfo>,
        transition_capture: PgPtr<TransitionCaptureState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecBRUpdateTriggers(
        estate: PgPtr<EState>,
        epqstate: PgPtr<EPQState>,
        relinfo: PgPtr<ResultRelInfo>,
        tupleid: PgPtr<ItemPointerData>,
        fdw_trigtuple: PgPtr<HeapTupleData>,
        slot: PgPtr<TupleTableSlot>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecARUpdateTriggers(
        estate: PgPtr<EState>,
        relinfo: PgPtr<ResultRelInfo>,
        tupleid: PgPtr<ItemPointerData>,
        fdw_trigtuple: PgPtr<HeapTupleData>,
        slot: PgPtr<TupleTableSlot>,
        recheckIndexes: PgPtr<List>,
        transition_capture: PgPtr<TransitionCaptureState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExecIRUpdateTriggers(
        estate: PgPtr<EState>,
        relinfo: PgPtr<ResultRelInfo>,
        trigtuple: PgPtr<HeapTupleData>,
        slot: PgPtr<TupleTableSlot>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ExecBSTruncateTriggers(estate: PgPtr<EState>, relinfo: PgPtr<ResultRelInfo>);
}
#[pg_guard]
extern "C" {
    pub fn ExecASTruncateTriggers(estate: PgPtr<EState>, relinfo: PgPtr<ResultRelInfo>);
}
#[pg_guard]
extern "C" {
    pub fn AfterTriggerBeginXact();
}
#[pg_guard]
extern "C" {
    pub fn AfterTriggerBeginQuery();
}
#[pg_guard]
extern "C" {
    pub fn AfterTriggerEndQuery(estate: PgPtr<EState>);
}
#[pg_guard]
extern "C" {
    pub fn AfterTriggerFireDeferred();
}
#[pg_guard]
extern "C" {
    pub fn AfterTriggerEndXact(isCommit: bool);
}
#[pg_guard]
extern "C" {
    pub fn AfterTriggerBeginSubXact();
}
#[pg_guard]
extern "C" {
    pub fn AfterTriggerEndSubXact(isCommit: bool);
}
#[pg_guard]
extern "C" {
    pub fn AfterTriggerSetState(stmt: PgPtr<ConstraintsSetStmt>);
}
#[pg_guard]
extern "C" {
    pub fn AfterTriggerPendingOnRel(relid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_pk_upd_check_required(
        trigger: PgPtr<Trigger>,
        pk_rel: PgPtr<RelationData>,
        old_slot: PgPtr<TupleTableSlot>,
        new_slot: PgPtr<TupleTableSlot>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_fk_upd_check_required(
        trigger: PgPtr<Trigger>,
        fk_rel: PgPtr<RelationData>,
        old_slot: PgPtr<TupleTableSlot>,
        new_slot: PgPtr<TupleTableSlot>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn RI_Initial_Check(
        trigger: PgPtr<Trigger>,
        fk_rel: PgPtr<RelationData>,
        pk_rel: PgPtr<RelationData>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn RI_PartitionRemove_Check(
        trigger: PgPtr<Trigger>,
        fk_rel: PgPtr<RelationData>,
        pk_rel: PgPtr<RelationData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_trigger_type(tgfoid: Oid) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum PlanCacheMode {
    PLAN_CACHE_MODE_AUTO = 0,
    PLAN_CACHE_MODE_FORCE_GENERIC_PLAN = 1,
    PLAN_CACHE_MODE_FORCE_CUSTOM_PLAN = 2,
}
#[pg_guard]
extern "C" {
    pub static mut plan_cache_mode: ::std::os::raw::c_int;
}
#[repr(C)]
pub struct CachedPlanSource {
    pub magic: ::std::os::raw::c_int,
    pub raw_parse_tree: PgPtr<RawStmt>,
    pub query_string: PgPtr<::std::os::raw::c_char>,
    pub commandTag: PgPtr<::std::os::raw::c_char>,
    pub param_types: PgPtr<Oid>,
    pub num_params: ::std::os::raw::c_int,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: PgPtr<::std::os::raw::c_void>,
    pub cursor_options: ::std::os::raw::c_int,
    pub fixed_result: bool,
    pub resultDesc: PgPtr<TupleDescData>,
    pub context: PgPtr<MemoryContextData>,
    pub query_list: PgPtr<List>,
    pub relationOids: PgPtr<List>,
    pub invalItems: PgPtr<List>,
    pub search_path: PgPtr<OverrideSearchPath>,
    pub query_context: PgPtr<MemoryContextData>,
    pub rewriteRoleId: Oid,
    pub rewriteRowSecurity: bool,
    pub dependsOnRLS: bool,
    pub gplan: PgPtr<CachedPlan>,
    pub is_oneshot: bool,
    pub is_complete: bool,
    pub is_saved: bool,
    pub is_valid: bool,
    pub generation: ::std::os::raw::c_int,
    pub node: dlist_node,
    pub generic_cost: f64,
    pub total_custom_cost: f64,
    pub num_custom_plans: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct CachedPlan {
    pub magic: ::std::os::raw::c_int,
    pub stmt_list: PgPtr<List>,
    pub is_oneshot: bool,
    pub is_saved: bool,
    pub is_valid: bool,
    pub planRoleId: Oid,
    pub dependsOnRole: bool,
    pub saved_xmin: TransactionId,
    pub generation: ::std::os::raw::c_int,
    pub refcount: ::std::os::raw::c_int,
    pub context: PgPtr<MemoryContextData>,
}
#[repr(C)]
pub struct CachedExpression {
    pub magic: ::std::os::raw::c_int,
    pub expr: PgPtr<Node>,
    pub is_valid: bool,
    pub relationOids: PgPtr<List>,
    pub invalItems: PgPtr<List>,
    pub context: PgPtr<MemoryContextData>,
    pub node: dlist_node,
}
#[pg_guard]
extern "C" {
    pub fn InitPlanCache();
}
#[pg_guard]
extern "C" {
    pub fn ResetPlanCache();
}
#[pg_guard]
extern "C" {
    pub fn CreateCachedPlan(
        raw_parse_tree: PgPtr<RawStmt>,
        query_string: PgPtr<::std::os::raw::c_char>,
        commandTag: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<CachedPlanSource>;
}
#[pg_guard]
extern "C" {
    pub fn CreateOneShotCachedPlan(
        raw_parse_tree: PgPtr<RawStmt>,
        query_string: PgPtr<::std::os::raw::c_char>,
        commandTag: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<CachedPlanSource>;
}
#[pg_guard]
extern "C" {
    pub fn CompleteCachedPlan(
        plansource: PgPtr<CachedPlanSource>,
        querytree_list: PgPtr<List>,
        querytree_context: PgPtr<MemoryContextData>,
        param_types: PgPtr<Oid>,
        num_params: ::std::os::raw::c_int,
        parserSetup: ParserSetupHook,
        parserSetupArg: PgPtr<::std::os::raw::c_void>,
        cursor_options: ::std::os::raw::c_int,
        fixed_result: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn SaveCachedPlan(plansource: PgPtr<CachedPlanSource>);
}
#[pg_guard]
extern "C" {
    pub fn DropCachedPlan(plansource: PgPtr<CachedPlanSource>);
}
#[pg_guard]
extern "C" {
    pub fn CachedPlanSetParentContext(
        plansource: PgPtr<CachedPlanSource>,
        newcontext: PgPtr<MemoryContextData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn CopyCachedPlan(plansource: PgPtr<CachedPlanSource>) -> PgPtr<CachedPlanSource>;
}
#[pg_guard]
extern "C" {
    pub fn CachedPlanIsValid(plansource: PgPtr<CachedPlanSource>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn CachedPlanGetTargetList(
        plansource: PgPtr<CachedPlanSource>,
        queryEnv: PgPtr<QueryEnvironment>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn GetCachedPlan(
        plansource: PgPtr<CachedPlanSource>,
        boundParams: PgPtr<ParamListInfoData>,
        useResOwner: bool,
        queryEnv: PgPtr<QueryEnvironment>,
    ) -> PgPtr<CachedPlan>;
}
#[pg_guard]
extern "C" {
    pub fn ReleaseCachedPlan(plan: PgPtr<CachedPlan>, useResOwner: bool);
}
#[pg_guard]
extern "C" {
    pub fn GetCachedExpression(expr: PgPtr<Node>) -> PgPtr<CachedExpression>;
}
#[pg_guard]
extern "C" {
    pub fn FreeCachedExpression(cexpr: PgPtr<CachedExpression>);
}
pub type ResourceOwner = PgPtr<ResourceOwnerData>;
#[pg_guard]
extern "C" {
    pub static mut CurrentResourceOwner: PgPtr<ResourceOwnerData>;
}
#[pg_guard]
extern "C" {
    pub static mut CurTransactionResourceOwner: PgPtr<ResourceOwnerData>;
}
#[pg_guard]
extern "C" {
    pub static mut TopTransactionResourceOwner: PgPtr<ResourceOwnerData>;
}
#[pg_guard]
extern "C" {
    pub static mut AuxProcessResourceOwner: PgPtr<ResourceOwnerData>;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceReleasePhase {
    RESOURCE_RELEASE_BEFORE_LOCKS = 0,
    RESOURCE_RELEASE_LOCKS = 1,
    RESOURCE_RELEASE_AFTER_LOCKS = 2,
}
pub type ResourceReleaseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        phase: ResourceReleasePhase,
        isCommit: bool,
        isTopLevel: bool,
        arg: PgPtr<::std::os::raw::c_void>,
    ),
>;
#[pg_guard]
extern "C" {
    pub fn ResourceOwnerCreate(
        parent: PgPtr<ResourceOwnerData>,
        name: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<ResourceOwnerData>;
}
#[pg_guard]
extern "C" {
    pub fn ResourceOwnerRelease(
        owner: PgPtr<ResourceOwnerData>,
        phase: ResourceReleasePhase,
        isCommit: bool,
        isTopLevel: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn ResourceOwnerDelete(owner: PgPtr<ResourceOwnerData>);
}
#[pg_guard]
extern "C" {
    pub fn ResourceOwnerGetParent(owner: PgPtr<ResourceOwnerData>) -> PgPtr<ResourceOwnerData>;
}
#[pg_guard]
extern "C" {
    pub fn ResourceOwnerNewParent(
        owner: PgPtr<ResourceOwnerData>,
        newparent: PgPtr<ResourceOwnerData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn RegisterResourceReleaseCallback(
        callback: ResourceReleaseCallback,
        arg: PgPtr<::std::os::raw::c_void>,
    );
}
#[pg_guard]
extern "C" {
    pub fn UnregisterResourceReleaseCallback(
        callback: ResourceReleaseCallback,
        arg: PgPtr<::std::os::raw::c_void>,
    );
}
#[pg_guard]
extern "C" {
    pub fn CreateAuxProcessResourceOwner();
}
#[pg_guard]
extern "C" {
    pub fn ReleaseAuxProcessResources(isCommit: bool);
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum PortalStrategy {
    PORTAL_ONE_SELECT = 0,
    PORTAL_ONE_RETURNING = 1,
    PORTAL_ONE_MOD_WITH = 2,
    PORTAL_UTIL_SELECT = 3,
    PORTAL_MULTI_QUERY = 4,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum PortalStatus {
    PORTAL_NEW = 0,
    PORTAL_DEFINED = 1,
    PORTAL_READY = 2,
    PORTAL_ACTIVE = 3,
    PORTAL_DONE = 4,
    PORTAL_FAILED = 5,
}
pub type Portal = PgPtr<PortalData>;
#[repr(C)]
pub struct PortalData {
    pub name: PgPtr<::std::os::raw::c_char>,
    pub prepStmtName: PgPtr<::std::os::raw::c_char>,
    pub portalContext: PgPtr<MemoryContextData>,
    pub resowner: PgPtr<ResourceOwnerData>,
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(portal: PgPtr<PortalData>)>,
    pub createSubid: SubTransactionId,
    pub activeSubid: SubTransactionId,
    pub sourceText: PgPtr<::std::os::raw::c_char>,
    pub commandTag: PgPtr<::std::os::raw::c_char>,
    pub stmts: PgPtr<List>,
    pub cplan: PgPtr<CachedPlan>,
    pub portalParams: PgPtr<ParamListInfoData>,
    pub queryEnv: PgPtr<QueryEnvironment>,
    pub strategy: PortalStrategy,
    pub cursorOptions: ::std::os::raw::c_int,
    pub run_once: bool,
    pub status: PortalStatus,
    pub portalPinned: bool,
    pub autoHeld: bool,
    pub queryDesc: PgPtr<QueryDesc>,
    pub tupDesc: PgPtr<TupleDescData>,
    pub formats: PgPtr<int16>,
    pub holdStore: PgPtr<Tuplestorestate>,
    pub holdContext: PgPtr<MemoryContextData>,
    pub holdSnapshot: PgPtr<SnapshotData>,
    pub atStart: bool,
    pub atEnd: bool,
    pub portalPos: uint64,
    pub creation_time: TimestampTz,
    pub visible: bool,
}
#[pg_guard]
extern "C" {
    pub fn EnablePortalManager();
}
#[pg_guard]
extern "C" {
    pub fn PreCommit_Portals(isPrepare: bool) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn AtAbort_Portals();
}
#[pg_guard]
extern "C" {
    pub fn AtCleanup_Portals();
}
#[pg_guard]
extern "C" {
    pub fn PortalErrorCleanup();
}
#[pg_guard]
extern "C" {
    pub fn AtSubCommit_Portals(
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        parentXactOwner: PgPtr<ResourceOwnerData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn AtSubAbort_Portals(
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        myXactOwner: PgPtr<ResourceOwnerData>,
        parentXactOwner: PgPtr<ResourceOwnerData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn AtSubCleanup_Portals(mySubid: SubTransactionId);
}
#[pg_guard]
extern "C" {
    pub fn CreatePortal(
        name: PgPtr<::std::os::raw::c_char>,
        allowDup: bool,
        dupSilent: bool,
    ) -> PgPtr<PortalData>;
}
#[pg_guard]
extern "C" {
    pub fn CreateNewPortal() -> PgPtr<PortalData>;
}
#[pg_guard]
extern "C" {
    pub fn PinPortal(portal: PgPtr<PortalData>);
}
#[pg_guard]
extern "C" {
    pub fn UnpinPortal(portal: PgPtr<PortalData>);
}
#[pg_guard]
extern "C" {
    pub fn MarkPortalActive(portal: PgPtr<PortalData>);
}
#[pg_guard]
extern "C" {
    pub fn MarkPortalDone(portal: PgPtr<PortalData>);
}
#[pg_guard]
extern "C" {
    pub fn MarkPortalFailed(portal: PgPtr<PortalData>);
}
#[pg_guard]
extern "C" {
    pub fn PortalDrop(portal: PgPtr<PortalData>, isTopCommit: bool);
}
#[pg_guard]
extern "C" {
    pub fn GetPortalByName(name: PgPtr<::std::os::raw::c_char>) -> PgPtr<PortalData>;
}
#[pg_guard]
extern "C" {
    pub fn PortalDefineQuery(
        portal: PgPtr<PortalData>,
        prepStmtName: PgPtr<::std::os::raw::c_char>,
        sourceText: PgPtr<::std::os::raw::c_char>,
        commandTag: PgPtr<::std::os::raw::c_char>,
        stmts: PgPtr<List>,
        cplan: PgPtr<CachedPlan>,
    );
}
#[pg_guard]
extern "C" {
    pub fn PortalGetPrimaryStmt(portal: PgPtr<PortalData>) -> PgPtr<PlannedStmt>;
}
#[pg_guard]
extern "C" {
    pub fn PortalCreateHoldStore(portal: PgPtr<PortalData>);
}
#[pg_guard]
extern "C" {
    pub fn PortalHashTableDeleteAll();
}
#[pg_guard]
extern "C" {
    pub fn ThereAreNoReadyPortals() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn HoldPinnedPortals();
}
#[repr(C)]
pub struct SPITupleTable {
    pub tuptabcxt: PgPtr<MemoryContextData>,
    pub alloced: uint64,
    pub free: uint64,
    pub tupdesc: PgPtr<TupleDescData>,
    pub vals: PgPtr<PgPtr<HeapTupleData>>,
    pub next: slist_node,
    pub subid: SubTransactionId,
}
#[repr(C)]
pub struct _SPI_plan {
    _unused: [u8; 0],
}
pub type SPIPlanPtr = PgPtr<_SPI_plan>;
#[pg_guard]
extern "C" {
    pub static mut SPI_processed: uint64;
}
#[pg_guard]
extern "C" {
    pub static mut SPI_tuptable: PgPtr<SPITupleTable>;
}
#[pg_guard]
extern "C" {
    pub static mut SPI_result: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_connect() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_connect_ext(options: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_finish() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_execute(
        src: PgPtr<::std::os::raw::c_char>,
        read_only: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_execute_plan(
        plan: PgPtr<_SPI_plan>,
        Values: PgPtr<Datum>,
        Nulls: PgPtr<::std::os::raw::c_char>,
        read_only: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_execute_plan_with_paramlist(
        plan: PgPtr<_SPI_plan>,
        params: PgPtr<ParamListInfoData>,
        read_only: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_exec(
        src: PgPtr<::std::os::raw::c_char>,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_execp(
        plan: PgPtr<_SPI_plan>,
        Values: PgPtr<Datum>,
        Nulls: PgPtr<::std::os::raw::c_char>,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_execute_snapshot(
        plan: PgPtr<_SPI_plan>,
        Values: PgPtr<Datum>,
        Nulls: PgPtr<::std::os::raw::c_char>,
        snapshot: PgPtr<SnapshotData>,
        crosscheck_snapshot: PgPtr<SnapshotData>,
        read_only: bool,
        fire_triggers: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_execute_with_args(
        src: PgPtr<::std::os::raw::c_char>,
        nargs: ::std::os::raw::c_int,
        argtypes: PgPtr<Oid>,
        Values: PgPtr<Datum>,
        Nulls: PgPtr<::std::os::raw::c_char>,
        read_only: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_prepare(
        src: PgPtr<::std::os::raw::c_char>,
        nargs: ::std::os::raw::c_int,
        argtypes: PgPtr<Oid>,
    ) -> PgPtr<_SPI_plan>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_prepare_cursor(
        src: PgPtr<::std::os::raw::c_char>,
        nargs: ::std::os::raw::c_int,
        argtypes: PgPtr<Oid>,
        cursorOptions: ::std::os::raw::c_int,
    ) -> PgPtr<_SPI_plan>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_prepare_params(
        src: PgPtr<::std::os::raw::c_char>,
        parserSetup: ParserSetupHook,
        parserSetupArg: PgPtr<::std::os::raw::c_void>,
        cursorOptions: ::std::os::raw::c_int,
    ) -> PgPtr<_SPI_plan>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_keepplan(plan: PgPtr<_SPI_plan>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_saveplan(plan: PgPtr<_SPI_plan>) -> PgPtr<_SPI_plan>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_freeplan(plan: PgPtr<_SPI_plan>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_getargtypeid(plan: PgPtr<_SPI_plan>, argIndex: ::std::os::raw::c_int) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn SPI_getargcount(plan: PgPtr<_SPI_plan>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_is_cursor_plan(plan: PgPtr<_SPI_plan>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn SPI_plan_is_valid(plan: PgPtr<_SPI_plan>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn SPI_result_code_string(code: ::std::os::raw::c_int) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_plan_get_plan_sources(plan: PgPtr<_SPI_plan>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_plan_get_cached_plan(plan: PgPtr<_SPI_plan>) -> PgPtr<CachedPlan>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_copytuple(tuple: PgPtr<HeapTupleData>) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_returntuple(
        tuple: PgPtr<HeapTupleData>,
        tupdesc: PgPtr<TupleDescData>,
    ) -> PgPtr<HeapTupleHeaderData>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_modifytuple(
        rel: PgPtr<RelationData>,
        tuple: PgPtr<HeapTupleData>,
        natts: ::std::os::raw::c_int,
        attnum: PgPtr<::std::os::raw::c_int>,
        Values: PgPtr<Datum>,
        Nulls: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_fnumber(
        tupdesc: PgPtr<TupleDescData>,
        fname: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_fname(
        tupdesc: PgPtr<TupleDescData>,
        fnumber: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_getvalue(
        tuple: PgPtr<HeapTupleData>,
        tupdesc: PgPtr<TupleDescData>,
        fnumber: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_getbinval(
        tuple: PgPtr<HeapTupleData>,
        tupdesc: PgPtr<TupleDescData>,
        fnumber: ::std::os::raw::c_int,
        isnull: PgPtr<bool>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn SPI_gettype(
        tupdesc: PgPtr<TupleDescData>,
        fnumber: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_gettypeid(tupdesc: PgPtr<TupleDescData>, fnumber: ::std::os::raw::c_int) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn SPI_getrelname(rel: PgPtr<RelationData>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_getnspname(rel: PgPtr<RelationData>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_palloc(size: Size) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_repalloc(
        pointer: PgPtr<::std::os::raw::c_void>,
        size: Size,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_pfree(pointer: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn SPI_datumTransfer(value: Datum, typByVal: bool, typLen: ::std::os::raw::c_int) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn SPI_freetuple(pointer: PgPtr<HeapTupleData>);
}
#[pg_guard]
extern "C" {
    pub fn SPI_freetuptable(tuptable: PgPtr<SPITupleTable>);
}
#[pg_guard]
extern "C" {
    pub fn SPI_cursor_open(
        name: PgPtr<::std::os::raw::c_char>,
        plan: PgPtr<_SPI_plan>,
        Values: PgPtr<Datum>,
        Nulls: PgPtr<::std::os::raw::c_char>,
        read_only: bool,
    ) -> PgPtr<PortalData>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_cursor_open_with_args(
        name: PgPtr<::std::os::raw::c_char>,
        src: PgPtr<::std::os::raw::c_char>,
        nargs: ::std::os::raw::c_int,
        argtypes: PgPtr<Oid>,
        Values: PgPtr<Datum>,
        Nulls: PgPtr<::std::os::raw::c_char>,
        read_only: bool,
        cursorOptions: ::std::os::raw::c_int,
    ) -> PgPtr<PortalData>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_cursor_open_with_paramlist(
        name: PgPtr<::std::os::raw::c_char>,
        plan: PgPtr<_SPI_plan>,
        params: PgPtr<ParamListInfoData>,
        read_only: bool,
    ) -> PgPtr<PortalData>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_cursor_find(name: PgPtr<::std::os::raw::c_char>) -> PgPtr<PortalData>;
}
#[pg_guard]
extern "C" {
    pub fn SPI_cursor_fetch(
        portal: PgPtr<PortalData>,
        forward: bool,
        count: ::std::os::raw::c_long,
    );
}
#[pg_guard]
extern "C" {
    pub fn SPI_cursor_move(portal: PgPtr<PortalData>, forward: bool, count: ::std::os::raw::c_long);
}
#[pg_guard]
extern "C" {
    pub fn SPI_scroll_cursor_fetch(
        arg1: PgPtr<PortalData>,
        direction: FetchDirection,
        count: ::std::os::raw::c_long,
    );
}
#[pg_guard]
extern "C" {
    pub fn SPI_scroll_cursor_move(
        arg1: PgPtr<PortalData>,
        direction: FetchDirection,
        count: ::std::os::raw::c_long,
    );
}
#[pg_guard]
extern "C" {
    pub fn SPI_cursor_close(portal: PgPtr<PortalData>);
}
#[pg_guard]
extern "C" {
    pub fn SPI_register_relation(enr: PgPtr<EphemeralNamedRelationData>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_unregister_relation(name: PgPtr<::std::os::raw::c_char>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_register_trigger_data(tdata: PgPtr<TriggerData>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SPI_start_transaction();
}
#[pg_guard]
extern "C" {
    pub fn SPI_commit();
}
#[pg_guard]
extern "C" {
    pub fn SPI_commit_and_chain();
}
#[pg_guard]
extern "C" {
    pub fn SPI_rollback();
}
#[pg_guard]
extern "C" {
    pub fn SPI_rollback_and_chain();
}
#[pg_guard]
extern "C" {
    pub fn SPICleanup();
}
#[pg_guard]
extern "C" {
    pub fn AtEOXact_SPI(isCommit: bool);
}
#[pg_guard]
extern "C" {
    pub fn AtEOSubXact_SPI(isCommit: bool, mySubid: SubTransactionId);
}
#[pg_guard]
extern "C" {
    pub fn SPI_inside_nonatomic_context() -> bool;
}
pub type bgworker_main_type = ::std::option::Option<unsafe extern "C" fn(main_arg: Datum)>;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum BgWorkerStartTime {
    BgWorkerStart_PostmasterStart = 0,
    BgWorkerStart_ConsistentState = 1,
    BgWorkerStart_RecoveryFinished = 2,
}
#[repr(C)]
pub struct BackgroundWorker {
    pub bgw_name: [::std::os::raw::c_char; 96usize],
    pub bgw_type: [::std::os::raw::c_char; 96usize],
    pub bgw_flags: ::std::os::raw::c_int,
    pub bgw_start_time: BgWorkerStartTime,
    pub bgw_restart_time: ::std::os::raw::c_int,
    pub bgw_library_name: [::std::os::raw::c_char; 96usize],
    pub bgw_function_name: [::std::os::raw::c_char; 96usize],
    pub bgw_main_arg: Datum,
    pub bgw_extra: [::std::os::raw::c_char; 128usize],
    pub bgw_notify_pid: pid_t,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum BgwHandleStatus {
    BGWH_STARTED = 0,
    BGWH_NOT_YET_STARTED = 1,
    BGWH_STOPPED = 2,
    BGWH_POSTMASTER_DIED = 3,
}
#[repr(C)]
pub struct BackgroundWorkerHandle {
    _unused: [u8; 0],
}
#[pg_guard]
extern "C" {
    pub fn RegisterBackgroundWorker(worker: PgPtr<BackgroundWorker>);
}
#[pg_guard]
extern "C" {
    pub fn RegisterDynamicBackgroundWorker(
        worker: PgPtr<BackgroundWorker>,
        handle: PgPtr<PgPtr<BackgroundWorkerHandle>>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetBackgroundWorkerPid(
        handle: PgPtr<BackgroundWorkerHandle>,
        pidp: PgPtr<pid_t>,
    ) -> BgwHandleStatus;
}
#[pg_guard]
extern "C" {
    pub fn WaitForBackgroundWorkerStartup(
        handle: PgPtr<BackgroundWorkerHandle>,
        pid: PgPtr<pid_t>,
    ) -> BgwHandleStatus;
}
#[pg_guard]
extern "C" {
    pub fn WaitForBackgroundWorkerShutdown(arg1: PgPtr<BackgroundWorkerHandle>) -> BgwHandleStatus;
}
#[pg_guard]
extern "C" {
    pub fn GetBackgroundWorkerTypeByPid(pid: pid_t) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn TerminateBackgroundWorker(handle: PgPtr<BackgroundWorkerHandle>);
}
#[pg_guard]
extern "C" {
    pub static mut MyBgworkerEntry: PgPtr<BackgroundWorker>;
}
#[pg_guard]
extern "C" {
    pub fn BackgroundWorkerInitializeConnection(
        dbname: PgPtr<::std::os::raw::c_char>,
        username: PgPtr<::std::os::raw::c_char>,
        flags: uint32,
    );
}
#[pg_guard]
extern "C" {
    pub fn BackgroundWorkerInitializeConnectionByOid(dboid: Oid, useroid: Oid, flags: uint32);
}
#[pg_guard]
extern "C" {
    pub fn BackgroundWorkerBlockSignals();
}
#[pg_guard]
extern "C" {
    pub fn BackgroundWorkerUnblockSignals();
}
#[repr(C)]
pub struct shm_mq {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct shm_mq_handle {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct shm_mq_iovec {
    pub data: PgPtr<::std::os::raw::c_char>,
    pub len: Size,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum shm_mq_result {
    SHM_MQ_SUCCESS = 0,
    SHM_MQ_WOULD_BLOCK = 1,
    SHM_MQ_DETACHED = 2,
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_create(address: PgPtr<::std::os::raw::c_void>, size: Size) -> PgPtr<shm_mq>;
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_set_receiver(mq: PgPtr<shm_mq>, arg1: PgPtr<PGPROC>);
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_set_sender(mq: PgPtr<shm_mq>, arg1: PgPtr<PGPROC>);
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_get_receiver(arg1: PgPtr<shm_mq>) -> PgPtr<PGPROC>;
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_get_sender(arg1: PgPtr<shm_mq>) -> PgPtr<PGPROC>;
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_attach(
        mq: PgPtr<shm_mq>,
        seg: PgPtr<dsm_segment>,
        handle: PgPtr<BackgroundWorkerHandle>,
    ) -> PgPtr<shm_mq_handle>;
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_set_handle(arg1: PgPtr<shm_mq_handle>, arg2: PgPtr<BackgroundWorkerHandle>);
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_detach(mqh: PgPtr<shm_mq_handle>);
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_get_queue(mqh: PgPtr<shm_mq_handle>) -> PgPtr<shm_mq>;
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_send(
        mqh: PgPtr<shm_mq_handle>,
        nbytes: Size,
        data: PgPtr<::std::os::raw::c_void>,
        nowait: bool,
    ) -> shm_mq_result;
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_sendv(
        mqh: PgPtr<shm_mq_handle>,
        iov: PgPtr<shm_mq_iovec>,
        iovcnt: ::std::os::raw::c_int,
        nowait: bool,
    ) -> shm_mq_result;
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_receive(
        mqh: PgPtr<shm_mq_handle>,
        nbytesp: PgPtr<Size>,
        datap: PgPtr<PgPtr<::std::os::raw::c_void>>,
        nowait: bool,
    ) -> shm_mq_result;
}
#[pg_guard]
extern "C" {
    pub fn shm_mq_wait_for_attach(mqh: PgPtr<shm_mq_handle>) -> shm_mq_result;
}
#[pg_guard]
extern "C" {
    pub static shm_mq_minimum_size: Size;
}
#[repr(C)]
pub struct shm_toc {
    _unused: [u8; 0],
}
#[pg_guard]
extern "C" {
    pub fn shm_toc_create(
        magic: uint64,
        address: PgPtr<::std::os::raw::c_void>,
        nbytes: Size,
    ) -> PgPtr<shm_toc>;
}
#[pg_guard]
extern "C" {
    pub fn shm_toc_attach(magic: uint64, address: PgPtr<::std::os::raw::c_void>) -> PgPtr<shm_toc>;
}
#[pg_guard]
extern "C" {
    pub fn shm_toc_allocate(toc: PgPtr<shm_toc>, nbytes: Size) -> PgPtr<::std::os::raw::c_void>;
}
#[pg_guard]
extern "C" {
    pub fn shm_toc_freespace(toc: PgPtr<shm_toc>) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn shm_toc_insert(toc: PgPtr<shm_toc>, key: uint64, address: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn shm_toc_lookup(
        toc: PgPtr<shm_toc>,
        key: uint64,
        noError: bool,
    ) -> PgPtr<::std::os::raw::c_void>;
}
#[repr(C)]
pub struct shm_toc_estimator {
    pub space_for_chunks: Size,
    pub number_of_keys: Size,
}
#[pg_guard]
extern "C" {
    pub fn shm_toc_estimate(e: PgPtr<shm_toc_estimator>) -> Size;
}
pub type parallel_worker_main_type =
    ::std::option::Option<unsafe extern "C" fn(seg: PgPtr<dsm_segment>, toc: PgPtr<shm_toc>)>;
#[repr(C)]
pub struct ParallelWorkerInfo {
    pub bgwhandle: PgPtr<BackgroundWorkerHandle>,
    pub error_mqh: PgPtr<shm_mq_handle>,
    pub pid: int32,
}
#[repr(C)]
pub struct ParallelContext {
    pub node: dlist_node,
    pub subid: SubTransactionId,
    pub nworkers: ::std::os::raw::c_int,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub library_name: PgPtr<::std::os::raw::c_char>,
    pub function_name: PgPtr<::std::os::raw::c_char>,
    pub error_context_stack: PgPtr<ErrorContextCallback>,
    pub estimator: shm_toc_estimator,
    pub seg: PgPtr<dsm_segment>,
    pub private_memory: PgPtr<::std::os::raw::c_void>,
    pub toc: PgPtr<shm_toc>,
    pub worker: PgPtr<ParallelWorkerInfo>,
    pub nknown_attached_workers: ::std::os::raw::c_int,
    pub known_attached_workers: PgPtr<bool>,
}
#[repr(C)]
pub struct ParallelWorkerContext {
    pub seg: PgPtr<dsm_segment>,
    pub toc: PgPtr<shm_toc>,
}
#[pg_guard]
extern "C" {
    pub static mut ParallelMessagePending: bool;
}
#[pg_guard]
extern "C" {
    pub static mut ParallelWorkerNumber: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut InitializingParallelWorker: bool;
}
#[pg_guard]
extern "C" {
    pub fn CreateParallelContext(
        library_name: PgPtr<::std::os::raw::c_char>,
        function_name: PgPtr<::std::os::raw::c_char>,
        nworkers: ::std::os::raw::c_int,
    ) -> PgPtr<ParallelContext>;
}
#[pg_guard]
extern "C" {
    pub fn InitializeParallelDSM(pcxt: PgPtr<ParallelContext>);
}
#[pg_guard]
extern "C" {
    pub fn ReinitializeParallelDSM(pcxt: PgPtr<ParallelContext>);
}
#[pg_guard]
extern "C" {
    pub fn LaunchParallelWorkers(pcxt: PgPtr<ParallelContext>);
}
#[pg_guard]
extern "C" {
    pub fn WaitForParallelWorkersToAttach(pcxt: PgPtr<ParallelContext>);
}
#[pg_guard]
extern "C" {
    pub fn WaitForParallelWorkersToFinish(pcxt: PgPtr<ParallelContext>);
}
#[pg_guard]
extern "C" {
    pub fn DestroyParallelContext(pcxt: PgPtr<ParallelContext>);
}
#[pg_guard]
extern "C" {
    pub fn ParallelContextActive() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn HandleParallelMessageInterrupt();
}
#[pg_guard]
extern "C" {
    pub fn HandleParallelMessages();
}
#[pg_guard]
extern "C" {
    pub fn AtEOXact_Parallel(isCommit: bool);
}
#[pg_guard]
extern "C" {
    pub fn AtEOSubXact_Parallel(isCommit: bool, mySubId: SubTransactionId);
}
#[pg_guard]
extern "C" {
    pub fn ParallelWorkerReportLastRecEnd(last_xlog_end: XLogRecPtr);
}
#[pg_guard]
extern "C" {
    pub fn ParallelWorkerMain(main_arg: Datum);
}
pub type Relids = PgPtr<Bitmapset>;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum CostSelector {
    STARTUP_COST = 0,
    TOTAL_COST = 1,
}
#[repr(C)]
pub struct QualCost {
    pub startup: Cost,
    pub per_tuple: Cost,
}
#[repr(C)]
pub struct AggClauseCosts {
    pub numAggs: ::std::os::raw::c_int,
    pub numOrderedAggs: ::std::os::raw::c_int,
    pub hasNonPartial: bool,
    pub hasNonSerial: bool,
    pub transCost: QualCost,
    pub finalCost: QualCost,
    pub transitionSpace: Size,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum UpperRelationKind {
    UPPERREL_SETOP = 0,
    UPPERREL_PARTIAL_GROUP_AGG = 1,
    UPPERREL_GROUP_AGG = 2,
    UPPERREL_WINDOW = 3,
    UPPERREL_DISTINCT = 4,
    UPPERREL_ORDERED = 5,
    UPPERREL_FINAL = 6,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum InheritanceKind {
    INHKIND_NONE = 0,
    INHKIND_INHERITED = 1,
    INHKIND_PARTITIONED = 2,
}
#[repr(C)]
pub struct PlannerGlobal {
    pub type_: NodeTag,
    pub boundParams: PgPtr<ParamListInfoData>,
    pub subplans: PgPtr<List>,
    pub subroots: PgPtr<List>,
    pub rewindPlanIDs: PgPtr<Bitmapset>,
    pub finalrtable: PgPtr<List>,
    pub finalrowmarks: PgPtr<List>,
    pub resultRelations: PgPtr<List>,
    pub rootResultRelations: PgPtr<List>,
    pub relationOids: PgPtr<List>,
    pub invalItems: PgPtr<List>,
    pub paramExecTypes: PgPtr<List>,
    pub lastPHId: Index,
    pub lastRowMarkId: Index,
    pub lastPlanNodeId: ::std::os::raw::c_int,
    pub transientPlan: bool,
    pub dependsOnRole: bool,
    pub parallelModeOK: bool,
    pub parallelModeNeeded: bool,
    pub maxParallelHazard: ::std::os::raw::c_char,
    pub partition_directory: PgPtr<PartitionDirectoryData>,
}
#[repr(C)]
pub struct PlannerInfo {
    pub type_: NodeTag,
    pub parse: PgPtr<Query>,
    pub glob: PgPtr<PlannerGlobal>,
    pub query_level: Index,
    pub parent_root: PgPtr<PlannerInfo>,
    pub plan_params: PgPtr<List>,
    pub outer_params: PgPtr<Bitmapset>,
    pub simple_rel_array: PgPtr<PgPtr<RelOptInfo>>,
    pub simple_rel_array_size: ::std::os::raw::c_int,
    pub simple_rte_array: PgPtr<PgPtr<RangeTblEntry>>,
    pub append_rel_array: PgPtr<PgPtr<AppendRelInfo>>,
    pub all_baserels: PgPtr<Bitmapset>,
    pub nullable_baserels: PgPtr<Bitmapset>,
    pub join_rel_list: PgPtr<List>,
    pub join_rel_hash: PgPtr<HTAB>,
    pub join_rel_level: PgPtr<PgPtr<List>>,
    pub join_cur_level: ::std::os::raw::c_int,
    pub init_plans: PgPtr<List>,
    pub cte_plan_ids: PgPtr<List>,
    pub multiexpr_params: PgPtr<List>,
    pub eq_classes: PgPtr<List>,
    pub canon_pathkeys: PgPtr<List>,
    pub left_join_clauses: PgPtr<List>,
    pub right_join_clauses: PgPtr<List>,
    pub full_join_clauses: PgPtr<List>,
    pub join_info_list: PgPtr<List>,
    pub append_rel_list: PgPtr<List>,
    pub rowMarks: PgPtr<List>,
    pub placeholder_list: PgPtr<List>,
    pub fkey_list: PgPtr<List>,
    pub query_pathkeys: PgPtr<List>,
    pub group_pathkeys: PgPtr<List>,
    pub window_pathkeys: PgPtr<List>,
    pub distinct_pathkeys: PgPtr<List>,
    pub sort_pathkeys: PgPtr<List>,
    pub part_schemes: PgPtr<List>,
    pub initial_rels: PgPtr<List>,
    pub upper_rels: [*mut List; 7usize],
    pub upper_targets: [*mut PathTarget; 7usize],
    pub processed_tlist: PgPtr<List>,
    pub grouping_map: PgPtr<AttrNumber>,
    pub minmax_aggs: PgPtr<List>,
    pub planner_cxt: PgPtr<MemoryContextData>,
    pub total_table_pages: f64,
    pub tuple_fraction: f64,
    pub limit_tuples: f64,
    pub qual_security_level: Index,
    pub inhTargetKind: InheritanceKind,
    pub hasJoinRTEs: bool,
    pub hasLateralRTEs: bool,
    pub hasHavingQual: bool,
    pub hasPseudoConstantQuals: bool,
    pub hasRecursion: bool,
    pub wt_param_id: ::std::os::raw::c_int,
    pub non_recursive_path: PgPtr<Path>,
    pub curOuterRels: PgPtr<Bitmapset>,
    pub curOuterParams: PgPtr<List>,
    pub join_search_private: PgPtr<::std::os::raw::c_void>,
    pub partColsUpdated: bool,
}
#[repr(C)]
pub struct PartitionSchemeData {
    pub strategy: ::std::os::raw::c_char,
    pub partnatts: int16,
    pub partopfamily: PgPtr<Oid>,
    pub partopcintype: PgPtr<Oid>,
    pub partcollation: PgPtr<Oid>,
    pub parttyplen: PgPtr<int16>,
    pub parttypbyval: PgPtr<bool>,
    pub partsupfunc: PgPtr<FmgrInfo>,
}
pub type PartitionScheme = PgPtr<PartitionSchemeData>;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum RelOptKind {
    RELOPT_BASEREL = 0,
    RELOPT_JOINREL = 1,
    RELOPT_OTHER_MEMBER_REL = 2,
    RELOPT_OTHER_JOINREL = 3,
    RELOPT_UPPER_REL = 4,
    RELOPT_OTHER_UPPER_REL = 5,
    RELOPT_DEADREL = 6,
}
#[repr(C)]
pub struct RelOptInfo {
    pub type_: NodeTag,
    pub reloptkind: RelOptKind,
    pub relids: PgPtr<Bitmapset>,
    pub rows: f64,
    pub consider_startup: bool,
    pub consider_param_startup: bool,
    pub consider_parallel: bool,
    pub reltarget: PgPtr<PathTarget>,
    pub pathlist: PgPtr<List>,
    pub ppilist: PgPtr<List>,
    pub partial_pathlist: PgPtr<List>,
    pub cheapest_startup_path: PgPtr<Path>,
    pub cheapest_total_path: PgPtr<Path>,
    pub cheapest_unique_path: PgPtr<Path>,
    pub cheapest_parameterized_paths: PgPtr<List>,
    pub direct_lateral_relids: PgPtr<Bitmapset>,
    pub lateral_relids: PgPtr<Bitmapset>,
    pub relid: Index,
    pub reltablespace: Oid,
    pub rtekind: RTEKind,
    pub min_attr: AttrNumber,
    pub max_attr: AttrNumber,
    pub attr_needed: PgPtr<PgPtr<Bitmapset>>,
    pub attr_widths: PgPtr<int32>,
    pub lateral_vars: PgPtr<List>,
    pub lateral_referencers: PgPtr<Bitmapset>,
    pub indexlist: PgPtr<List>,
    pub statlist: PgPtr<List>,
    pub pages: BlockNumber,
    pub tuples: f64,
    pub allvisfrac: f64,
    pub subroot: PgPtr<PlannerInfo>,
    pub subplan_params: PgPtr<List>,
    pub rel_parallel_workers: ::std::os::raw::c_int,
    pub serverid: Oid,
    pub userid: Oid,
    pub useridiscurrent: bool,
    pub fdwroutine: PgPtr<FdwRoutine>,
    pub fdw_private: PgPtr<::std::os::raw::c_void>,
    pub unique_for_rels: PgPtr<List>,
    pub non_unique_for_rels: PgPtr<List>,
    pub baserestrictinfo: PgPtr<List>,
    pub baserestrictcost: QualCost,
    pub baserestrict_min_security: Index,
    pub joininfo: PgPtr<List>,
    pub has_eclass_joins: bool,
    pub consider_partitionwise_join: bool,
    pub top_parent_relids: PgPtr<Bitmapset>,
    pub part_scheme: PgPtr<PartitionSchemeData>,
    pub nparts: ::std::os::raw::c_int,
    pub boundinfo: PgPtr<PartitionBoundInfoData>,
    pub partition_qual: PgPtr<List>,
    pub part_rels: PgPtr<PgPtr<RelOptInfo>>,
    pub partexprs: PgPtr<PgPtr<List>>,
    pub nullable_partexprs: PgPtr<PgPtr<List>>,
    pub partitioned_child_rels: PgPtr<List>,
}
#[repr(C)]
pub struct IndexOptInfo {
    pub type_: NodeTag,
    pub indexoid: Oid,
    pub reltablespace: Oid,
    pub rel: PgPtr<RelOptInfo>,
    pub pages: BlockNumber,
    pub tuples: f64,
    pub tree_height: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
    pub nkeycolumns: ::std::os::raw::c_int,
    pub indexkeys: PgPtr<::std::os::raw::c_int>,
    pub indexcollations: PgPtr<Oid>,
    pub opfamily: PgPtr<Oid>,
    pub opcintype: PgPtr<Oid>,
    pub sortopfamily: PgPtr<Oid>,
    pub reverse_sort: PgPtr<bool>,
    pub nulls_first: PgPtr<bool>,
    pub canreturn: PgPtr<bool>,
    pub relam: Oid,
    pub indexprs: PgPtr<List>,
    pub indpred: PgPtr<List>,
    pub indextlist: PgPtr<List>,
    pub indrestrictinfo: PgPtr<List>,
    pub predOK: bool,
    pub unique: bool,
    pub immediate: bool,
    pub hypothetical: bool,
    pub amcanorderbyop: bool,
    pub amoptionalkey: bool,
    pub amsearcharray: bool,
    pub amsearchnulls: bool,
    pub amhasgettuple: bool,
    pub amhasgetbitmap: bool,
    pub amcanparallel: bool,
    pub amcostestimate: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
pub struct ForeignKeyOptInfo {
    pub type_: NodeTag,
    pub con_relid: Index,
    pub ref_relid: Index,
    pub nkeys: ::std::os::raw::c_int,
    pub conkey: [AttrNumber; 32usize],
    pub confkey: [AttrNumber; 32usize],
    pub conpfeqop: [Oid; 32usize],
    pub nmatched_ec: ::std::os::raw::c_int,
    pub nmatched_rcols: ::std::os::raw::c_int,
    pub nmatched_ri: ::std::os::raw::c_int,
    pub eclass: [*mut EquivalenceClass; 32usize],
    pub rinfos: [*mut List; 32usize],
}
#[repr(C)]
pub struct StatisticExtInfo {
    pub type_: NodeTag,
    pub statOid: Oid,
    pub rel: PgPtr<RelOptInfo>,
    pub kind: ::std::os::raw::c_char,
    pub keys: PgPtr<Bitmapset>,
}
#[repr(C)]
pub struct EquivalenceClass {
    pub type_: NodeTag,
    pub ec_opfamilies: PgPtr<List>,
    pub ec_collation: Oid,
    pub ec_members: PgPtr<List>,
    pub ec_sources: PgPtr<List>,
    pub ec_derives: PgPtr<List>,
    pub ec_relids: PgPtr<Bitmapset>,
    pub ec_has_const: bool,
    pub ec_has_volatile: bool,
    pub ec_below_outer_join: bool,
    pub ec_broken: bool,
    pub ec_sortref: Index,
    pub ec_min_security: Index,
    pub ec_max_security: Index,
    pub ec_merged: PgPtr<EquivalenceClass>,
}
#[repr(C)]
pub struct EquivalenceMember {
    pub type_: NodeTag,
    pub em_expr: PgPtr<Expr>,
    pub em_relids: PgPtr<Bitmapset>,
    pub em_nullable_relids: PgPtr<Bitmapset>,
    pub em_is_const: bool,
    pub em_is_child: bool,
    pub em_datatype: Oid,
}
#[repr(C)]
pub struct PathKey {
    pub type_: NodeTag,
    pub pk_eclass: PgPtr<EquivalenceClass>,
    pub pk_opfamily: Oid,
    pub pk_strategy: ::std::os::raw::c_int,
    pub pk_nulls_first: bool,
}
#[repr(C)]
pub struct PathTarget {
    pub type_: NodeTag,
    pub exprs: PgPtr<List>,
    pub sortgrouprefs: PgPtr<Index>,
    pub cost: QualCost,
    pub width: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ParamPathInfo {
    pub type_: NodeTag,
    pub ppi_req_outer: PgPtr<Bitmapset>,
    pub ppi_rows: f64,
    pub ppi_clauses: PgPtr<List>,
}
#[repr(C)]
pub struct Path {
    pub type_: NodeTag,
    pub pathtype: NodeTag,
    pub parent: PgPtr<RelOptInfo>,
    pub pathtarget: PgPtr<PathTarget>,
    pub param_info: PgPtr<ParamPathInfo>,
    pub parallel_aware: bool,
    pub parallel_safe: bool,
    pub parallel_workers: ::std::os::raw::c_int,
    pub rows: f64,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub pathkeys: PgPtr<List>,
}
#[repr(C)]
pub struct IndexPath {
    pub path: Path,
    pub indexinfo: PgPtr<IndexOptInfo>,
    pub indexclauses: PgPtr<List>,
    pub indexorderbys: PgPtr<List>,
    pub indexorderbycols: PgPtr<List>,
    pub indexscandir: ScanDirection,
    pub indextotalcost: Cost,
    pub indexselectivity: Selectivity,
}
#[repr(C)]
pub struct IndexClause {
    pub type_: NodeTag,
    pub rinfo: PgPtr<RestrictInfo>,
    pub indexquals: PgPtr<List>,
    pub lossy: bool,
    pub indexcol: AttrNumber,
    pub indexcols: PgPtr<List>,
}
#[repr(C)]
pub struct BitmapHeapPath {
    pub path: Path,
    pub bitmapqual: PgPtr<Path>,
}
#[repr(C)]
pub struct BitmapAndPath {
    pub path: Path,
    pub bitmapquals: PgPtr<List>,
    pub bitmapselectivity: Selectivity,
}
#[repr(C)]
pub struct BitmapOrPath {
    pub path: Path,
    pub bitmapquals: PgPtr<List>,
    pub bitmapselectivity: Selectivity,
}
#[repr(C)]
pub struct TidPath {
    pub path: Path,
    pub tidquals: PgPtr<List>,
}
#[repr(C)]
pub struct SubqueryScanPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
}
#[repr(C)]
pub struct ForeignPath {
    pub path: Path,
    pub fdw_outerpath: PgPtr<Path>,
    pub fdw_private: PgPtr<List>,
}
#[repr(C)]
pub struct CustomPath {
    pub path: Path,
    pub flags: uint32,
    pub custom_paths: PgPtr<List>,
    pub custom_private: PgPtr<List>,
    pub methods: PgPtr<CustomPathMethods>,
}
#[repr(C)]
pub struct AppendPath {
    pub path: Path,
    pub partitioned_rels: PgPtr<List>,
    pub subpaths: PgPtr<List>,
    pub first_partial_path: ::std::os::raw::c_int,
    pub limit_tuples: f64,
}
#[pg_guard]
extern "C" {
    pub fn is_dummy_rel(rel: PgPtr<RelOptInfo>) -> bool;
}
#[repr(C)]
pub struct MergeAppendPath {
    pub path: Path,
    pub partitioned_rels: PgPtr<List>,
    pub subpaths: PgPtr<List>,
    pub limit_tuples: f64,
}
#[repr(C)]
pub struct GroupResultPath {
    pub path: Path,
    pub quals: PgPtr<List>,
}
#[repr(C)]
pub struct MaterialPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum UniquePathMethod {
    UNIQUE_PATH_NOOP = 0,
    UNIQUE_PATH_HASH = 1,
    UNIQUE_PATH_SORT = 2,
}
#[repr(C)]
pub struct UniquePath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
    pub umethod: UniquePathMethod,
    pub in_operators: PgPtr<List>,
    pub uniq_exprs: PgPtr<List>,
}
#[repr(C)]
pub struct GatherPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
    pub single_copy: bool,
    pub num_workers: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct GatherMergePath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
    pub num_workers: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct JoinPath {
    pub path: Path,
    pub jointype: JoinType,
    pub inner_unique: bool,
    pub outerjoinpath: PgPtr<Path>,
    pub innerjoinpath: PgPtr<Path>,
    pub joinrestrictinfo: PgPtr<List>,
}
pub type NestPath = JoinPath;
#[repr(C)]
pub struct MergePath {
    pub jpath: JoinPath,
    pub path_mergeclauses: PgPtr<List>,
    pub outersortkeys: PgPtr<List>,
    pub innersortkeys: PgPtr<List>,
    pub skip_mark_restore: bool,
    pub materialize_inner: bool,
}
#[repr(C)]
pub struct HashPath {
    pub jpath: JoinPath,
    pub path_hashclauses: PgPtr<List>,
    pub num_batches: ::std::os::raw::c_int,
    pub inner_rows_total: f64,
}
#[repr(C)]
pub struct ProjectionPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
    pub dummypp: bool,
}
#[repr(C)]
pub struct ProjectSetPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
}
#[repr(C)]
pub struct SortPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
}
#[repr(C)]
pub struct GroupPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
    pub groupClause: PgPtr<List>,
    pub qual: PgPtr<List>,
}
#[repr(C)]
pub struct UpperUniquePath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
    pub numkeys: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct AggPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub numGroups: f64,
    pub groupClause: PgPtr<List>,
    pub qual: PgPtr<List>,
}
#[repr(C)]
pub struct GroupingSetData {
    pub type_: NodeTag,
    pub set: PgPtr<List>,
    pub numGroups: f64,
}
#[repr(C)]
pub struct RollupData {
    pub type_: NodeTag,
    pub groupClause: PgPtr<List>,
    pub gsets: PgPtr<List>,
    pub gsets_data: PgPtr<List>,
    pub numGroups: f64,
    pub hashable: bool,
    pub is_hashed: bool,
}
#[repr(C)]
pub struct GroupingSetsPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
    pub aggstrategy: AggStrategy,
    pub rollups: PgPtr<List>,
    pub qual: PgPtr<List>,
}
#[repr(C)]
pub struct MinMaxAggPath {
    pub path: Path,
    pub mmaggregates: PgPtr<List>,
    pub quals: PgPtr<List>,
}
#[repr(C)]
pub struct WindowAggPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
    pub winclause: PgPtr<WindowClause>,
}
#[repr(C)]
pub struct SetOpPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
    pub cmd: SetOpCmd,
    pub strategy: SetOpStrategy,
    pub distinctList: PgPtr<List>,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::std::os::raw::c_int,
    pub numGroups: f64,
}
#[repr(C)]
pub struct RecursiveUnionPath {
    pub path: Path,
    pub leftpath: PgPtr<Path>,
    pub rightpath: PgPtr<Path>,
    pub distinctList: PgPtr<List>,
    pub wtParam: ::std::os::raw::c_int,
    pub numGroups: f64,
}
#[repr(C)]
pub struct LockRowsPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
    pub rowMarks: PgPtr<List>,
    pub epqParam: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ModifyTablePath {
    pub path: Path,
    pub operation: CmdType,
    pub canSetTag: bool,
    pub nominalRelation: Index,
    pub rootRelation: Index,
    pub partColsUpdated: bool,
    pub resultRelations: PgPtr<List>,
    pub subpaths: PgPtr<List>,
    pub subroots: PgPtr<List>,
    pub withCheckOptionLists: PgPtr<List>,
    pub returningLists: PgPtr<List>,
    pub rowMarks: PgPtr<List>,
    pub onconflict: PgPtr<OnConflictExpr>,
    pub epqParam: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct LimitPath {
    pub path: Path,
    pub subpath: PgPtr<Path>,
    pub limitOffset: PgPtr<Node>,
    pub limitCount: PgPtr<Node>,
}
#[repr(C)]
pub struct RestrictInfo {
    pub type_: NodeTag,
    pub clause: PgPtr<Expr>,
    pub is_pushed_down: bool,
    pub outerjoin_delayed: bool,
    pub can_join: bool,
    pub pseudoconstant: bool,
    pub leakproof: bool,
    pub security_level: Index,
    pub clause_relids: PgPtr<Bitmapset>,
    pub required_relids: PgPtr<Bitmapset>,
    pub outer_relids: PgPtr<Bitmapset>,
    pub nullable_relids: PgPtr<Bitmapset>,
    pub left_relids: PgPtr<Bitmapset>,
    pub right_relids: PgPtr<Bitmapset>,
    pub orclause: PgPtr<Expr>,
    pub parent_ec: PgPtr<EquivalenceClass>,
    pub eval_cost: QualCost,
    pub norm_selec: Selectivity,
    pub outer_selec: Selectivity,
    pub mergeopfamilies: PgPtr<List>,
    pub left_ec: PgPtr<EquivalenceClass>,
    pub right_ec: PgPtr<EquivalenceClass>,
    pub left_em: PgPtr<EquivalenceMember>,
    pub right_em: PgPtr<EquivalenceMember>,
    pub scansel_cache: PgPtr<List>,
    pub outer_is_left: bool,
    pub hashjoinoperator: Oid,
    pub left_bucketsize: Selectivity,
    pub right_bucketsize: Selectivity,
    pub left_mcvfreq: Selectivity,
    pub right_mcvfreq: Selectivity,
}
#[repr(C)]
pub struct MergeScanSelCache {
    pub opfamily: Oid,
    pub collation: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub nulls_first: bool,
    pub leftstartsel: Selectivity,
    pub leftendsel: Selectivity,
    pub rightstartsel: Selectivity,
    pub rightendsel: Selectivity,
}
#[repr(C)]
pub struct PlaceHolderVar {
    pub xpr: Expr,
    pub phexpr: PgPtr<Expr>,
    pub phrels: PgPtr<Bitmapset>,
    pub phid: Index,
    pub phlevelsup: Index,
}
#[repr(C)]
pub struct SpecialJoinInfo {
    pub type_: NodeTag,
    pub min_lefthand: PgPtr<Bitmapset>,
    pub min_righthand: PgPtr<Bitmapset>,
    pub syn_lefthand: PgPtr<Bitmapset>,
    pub syn_righthand: PgPtr<Bitmapset>,
    pub jointype: JoinType,
    pub lhs_strict: bool,
    pub delay_upper_joins: bool,
    pub semi_can_btree: bool,
    pub semi_can_hash: bool,
    pub semi_operators: PgPtr<List>,
    pub semi_rhs_exprs: PgPtr<List>,
}
#[repr(C)]
pub struct AppendRelInfo {
    pub type_: NodeTag,
    pub parent_relid: Index,
    pub child_relid: Index,
    pub parent_reltype: Oid,
    pub child_reltype: Oid,
    pub translated_vars: PgPtr<List>,
    pub parent_reloid: Oid,
}
#[repr(C)]
pub struct PlaceHolderInfo {
    pub type_: NodeTag,
    pub phid: Index,
    pub ph_var: PgPtr<PlaceHolderVar>,
    pub ph_eval_at: PgPtr<Bitmapset>,
    pub ph_lateral: PgPtr<Bitmapset>,
    pub ph_needed: PgPtr<Bitmapset>,
    pub ph_width: int32,
}
#[repr(C)]
pub struct MinMaxAggInfo {
    pub type_: NodeTag,
    pub aggfnoid: Oid,
    pub aggsortop: Oid,
    pub target: PgPtr<Expr>,
    pub subroot: PgPtr<PlannerInfo>,
    pub path: PgPtr<Path>,
    pub pathcost: Cost,
    pub param: PgPtr<Param>,
}
#[repr(C)]
pub struct PlannerParamItem {
    pub type_: NodeTag,
    pub item: PgPtr<Node>,
    pub paramId: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct SemiAntiJoinFactors {
    pub outer_match_frac: Selectivity,
    pub match_count: Selectivity,
}
#[repr(C)]
pub struct JoinPathExtraData {
    pub restrictlist: PgPtr<List>,
    pub mergeclause_list: PgPtr<List>,
    pub inner_unique: bool,
    pub sjinfo: PgPtr<SpecialJoinInfo>,
    pub semifactors: SemiAntiJoinFactors,
    pub param_source_rels: PgPtr<Bitmapset>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum PartitionwiseAggregateType {
    PARTITIONWISE_AGGREGATE_NONE = 0,
    PARTITIONWISE_AGGREGATE_FULL = 1,
    PARTITIONWISE_AGGREGATE_PARTIAL = 2,
}
#[repr(C)]
pub struct GroupPathExtraData {
    pub flags: ::std::os::raw::c_int,
    pub partial_costs_set: bool,
    pub agg_partial_costs: AggClauseCosts,
    pub agg_final_costs: AggClauseCosts,
    pub target_parallel_safe: bool,
    pub havingQual: PgPtr<Node>,
    pub targetList: PgPtr<List>,
    pub patype: PartitionwiseAggregateType,
}
#[repr(C)]
pub struct FinalPathExtraData {
    pub limit_needed: bool,
    pub limit_tuples: f64,
    pub count_est: int64,
    pub offset_est: int64,
}
#[repr(C)]
pub struct JoinCostWorkspace {
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub run_cost: Cost,
    pub inner_run_cost: Cost,
    pub inner_rescan_run_cost: Cost,
    pub outer_rows: f64,
    pub inner_rows: f64,
    pub outer_skip_rows: f64,
    pub inner_skip_rows: f64,
    pub numbuckets: ::std::os::raw::c_int,
    pub numbatches: ::std::os::raw::c_int,
    pub inner_rows_total: f64,
}
pub type GetForeignRelSize_function = ::std::option::Option<
    unsafe extern "C" fn(root: PgPtr<PlannerInfo>, baserel: PgPtr<RelOptInfo>, foreigntableid: Oid),
>;
pub type GetForeignPaths_function = ::std::option::Option<
    unsafe extern "C" fn(root: PgPtr<PlannerInfo>, baserel: PgPtr<RelOptInfo>, foreigntableid: Oid),
>;
pub type GetForeignPlan_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        foreigntableid: Oid,
        best_path: PgPtr<ForeignPath>,
        tlist: PgPtr<List>,
        scan_clauses: PgPtr<List>,
        outer_plan: PgPtr<Plan>,
    ) -> PgPtr<ForeignScan>,
>;
pub type BeginForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(node: PgPtr<ForeignScanState>, eflags: ::std::os::raw::c_int),
>;
pub type IterateForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(node: PgPtr<ForeignScanState>) -> PgPtr<TupleTableSlot>,
>;
pub type RecheckForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(node: PgPtr<ForeignScanState>, slot: PgPtr<TupleTableSlot>) -> bool,
>;
pub type ReScanForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: PgPtr<ForeignScanState>)>;
pub type EndForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: PgPtr<ForeignScanState>)>;
pub type GetForeignJoinPaths_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        joinrel: PgPtr<RelOptInfo>,
        outerrel: PgPtr<RelOptInfo>,
        innerrel: PgPtr<RelOptInfo>,
        jointype: JoinType,
        extra: PgPtr<JoinPathExtraData>,
    ),
>;
pub type GetForeignUpperPaths_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        stage: UpperRelationKind,
        input_rel: PgPtr<RelOptInfo>,
        output_rel: PgPtr<RelOptInfo>,
        extra: PgPtr<::std::os::raw::c_void>,
    ),
>;
pub type AddForeignUpdateTargets_function = ::std::option::Option<
    unsafe extern "C" fn(
        parsetree: PgPtr<Query>,
        target_rte: PgPtr<RangeTblEntry>,
        target_relation: PgPtr<RelationData>,
    ),
>;
pub type PlanForeignModify_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        plan: PgPtr<ModifyTable>,
        resultRelation: Index,
        subplan_index: ::std::os::raw::c_int,
    ) -> PgPtr<List>,
>;
pub type BeginForeignModify_function = ::std::option::Option<
    unsafe extern "C" fn(
        mtstate: PgPtr<ModifyTableState>,
        rinfo: PgPtr<ResultRelInfo>,
        fdw_private: PgPtr<List>,
        subplan_index: ::std::os::raw::c_int,
        eflags: ::std::os::raw::c_int,
    ),
>;
pub type ExecForeignInsert_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: PgPtr<EState>,
        rinfo: PgPtr<ResultRelInfo>,
        slot: PgPtr<TupleTableSlot>,
        planSlot: PgPtr<TupleTableSlot>,
    ) -> PgPtr<TupleTableSlot>,
>;
pub type ExecForeignUpdate_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: PgPtr<EState>,
        rinfo: PgPtr<ResultRelInfo>,
        slot: PgPtr<TupleTableSlot>,
        planSlot: PgPtr<TupleTableSlot>,
    ) -> PgPtr<TupleTableSlot>,
>;
pub type ExecForeignDelete_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: PgPtr<EState>,
        rinfo: PgPtr<ResultRelInfo>,
        slot: PgPtr<TupleTableSlot>,
        planSlot: PgPtr<TupleTableSlot>,
    ) -> PgPtr<TupleTableSlot>,
>;
pub type EndForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(estate: PgPtr<EState>, rinfo: PgPtr<ResultRelInfo>)>;
pub type BeginForeignInsert_function = ::std::option::Option<
    unsafe extern "C" fn(mtstate: PgPtr<ModifyTableState>, rinfo: PgPtr<ResultRelInfo>),
>;
pub type EndForeignInsert_function =
    ::std::option::Option<unsafe extern "C" fn(estate: PgPtr<EState>, rinfo: PgPtr<ResultRelInfo>)>;
pub type IsForeignRelUpdatable_function =
    ::std::option::Option<unsafe extern "C" fn(rel: PgPtr<RelationData>) -> ::std::os::raw::c_int>;
pub type PlanDirectModify_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        plan: PgPtr<ModifyTable>,
        resultRelation: Index,
        subplan_index: ::std::os::raw::c_int,
    ) -> bool,
>;
pub type BeginDirectModify_function = ::std::option::Option<
    unsafe extern "C" fn(node: PgPtr<ForeignScanState>, eflags: ::std::os::raw::c_int),
>;
pub type IterateDirectModify_function = ::std::option::Option<
    unsafe extern "C" fn(node: PgPtr<ForeignScanState>) -> PgPtr<TupleTableSlot>,
>;
pub type EndDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: PgPtr<ForeignScanState>)>;
pub type GetForeignRowMarkType_function = ::std::option::Option<
    unsafe extern "C" fn(rte: PgPtr<RangeTblEntry>, strength: LockClauseStrength) -> RowMarkType,
>;
pub type RefetchForeignRow_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: PgPtr<EState>,
        erm: PgPtr<ExecRowMark>,
        rowid: Datum,
        slot: PgPtr<TupleTableSlot>,
        updated: PgPtr<bool>,
    ),
>;
pub type ExplainForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(node: PgPtr<ForeignScanState>, es: PgPtr<ExplainState>),
>;
pub type ExplainForeignModify_function = ::std::option::Option<
    unsafe extern "C" fn(
        mtstate: PgPtr<ModifyTableState>,
        rinfo: PgPtr<ResultRelInfo>,
        fdw_private: PgPtr<List>,
        subplan_index: ::std::os::raw::c_int,
        es: PgPtr<ExplainState>,
    ),
>;
pub type ExplainDirectModify_function = ::std::option::Option<
    unsafe extern "C" fn(node: PgPtr<ForeignScanState>, es: PgPtr<ExplainState>),
>;
pub type AcquireSampleRowsFunc = ::std::option::Option<
    unsafe extern "C" fn(
        relation: PgPtr<RelationData>,
        elevel: ::std::os::raw::c_int,
        rows: PgPtr<PgPtr<HeapTupleData>>,
        targrows: ::std::os::raw::c_int,
        totalrows: PgPtr<f64>,
        totaldeadrows: PgPtr<f64>,
    ) -> ::std::os::raw::c_int,
>;
pub type AnalyzeForeignTable_function = ::std::option::Option<
    unsafe extern "C" fn(
        relation: PgPtr<RelationData>,
        func: PgPtr<AcquireSampleRowsFunc>,
        totalpages: PgPtr<BlockNumber>,
    ) -> bool,
>;
pub type ImportForeignSchema_function = ::std::option::Option<
    unsafe extern "C" fn(stmt: PgPtr<ImportForeignSchemaStmt>, serverOid: Oid) -> PgPtr<List>,
>;
pub type EstimateDSMForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(node: PgPtr<ForeignScanState>, pcxt: PgPtr<ParallelContext>) -> Size,
>;
pub type InitializeDSMForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(
        node: PgPtr<ForeignScanState>,
        pcxt: PgPtr<ParallelContext>,
        coordinate: PgPtr<::std::os::raw::c_void>,
    ),
>;
pub type ReInitializeDSMForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(
        node: PgPtr<ForeignScanState>,
        pcxt: PgPtr<ParallelContext>,
        coordinate: PgPtr<::std::os::raw::c_void>,
    ),
>;
pub type InitializeWorkerForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(
        node: PgPtr<ForeignScanState>,
        toc: PgPtr<shm_toc>,
        coordinate: PgPtr<::std::os::raw::c_void>,
    ),
>;
pub type ShutdownForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: PgPtr<ForeignScanState>)>;
pub type IsForeignScanParallelSafe_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        rte: PgPtr<RangeTblEntry>,
    ) -> bool,
>;
pub type ReparameterizeForeignPathByChild_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        fdw_private: PgPtr<List>,
        child_rel: PgPtr<RelOptInfo>,
    ) -> PgPtr<List>,
>;
#[repr(C)]
pub struct FdwRoutine {
    pub type_: NodeTag,
    pub GetForeignRelSize: GetForeignRelSize_function,
    pub GetForeignPaths: GetForeignPaths_function,
    pub GetForeignPlan: GetForeignPlan_function,
    pub BeginForeignScan: BeginForeignScan_function,
    pub IterateForeignScan: IterateForeignScan_function,
    pub ReScanForeignScan: ReScanForeignScan_function,
    pub EndForeignScan: EndForeignScan_function,
    pub GetForeignJoinPaths: GetForeignJoinPaths_function,
    pub GetForeignUpperPaths: GetForeignUpperPaths_function,
    pub AddForeignUpdateTargets: AddForeignUpdateTargets_function,
    pub PlanForeignModify: PlanForeignModify_function,
    pub BeginForeignModify: BeginForeignModify_function,
    pub ExecForeignInsert: ExecForeignInsert_function,
    pub ExecForeignUpdate: ExecForeignUpdate_function,
    pub ExecForeignDelete: ExecForeignDelete_function,
    pub EndForeignModify: EndForeignModify_function,
    pub BeginForeignInsert: BeginForeignInsert_function,
    pub EndForeignInsert: EndForeignInsert_function,
    pub IsForeignRelUpdatable: IsForeignRelUpdatable_function,
    pub PlanDirectModify: PlanDirectModify_function,
    pub BeginDirectModify: BeginDirectModify_function,
    pub IterateDirectModify: IterateDirectModify_function,
    pub EndDirectModify: EndDirectModify_function,
    pub GetForeignRowMarkType: GetForeignRowMarkType_function,
    pub RefetchForeignRow: RefetchForeignRow_function,
    pub RecheckForeignScan: RecheckForeignScan_function,
    pub ExplainForeignScan: ExplainForeignScan_function,
    pub ExplainForeignModify: ExplainForeignModify_function,
    pub ExplainDirectModify: ExplainDirectModify_function,
    pub AnalyzeForeignTable: AnalyzeForeignTable_function,
    pub ImportForeignSchema: ImportForeignSchema_function,
    pub IsForeignScanParallelSafe: IsForeignScanParallelSafe_function,
    pub EstimateDSMForeignScan: EstimateDSMForeignScan_function,
    pub InitializeDSMForeignScan: InitializeDSMForeignScan_function,
    pub ReInitializeDSMForeignScan: ReInitializeDSMForeignScan_function,
    pub InitializeWorkerForeignScan: InitializeWorkerForeignScan_function,
    pub ShutdownForeignScan: ShutdownForeignScan_function,
    pub ReparameterizeForeignPathByChild: ReparameterizeForeignPathByChild_function,
}
#[pg_guard]
extern "C" {
    pub fn GetFdwRoutine(fdwhandler: Oid) -> PgPtr<FdwRoutine>;
}
#[pg_guard]
extern "C" {
    pub fn GetForeignServerIdByRelId(relid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn GetFdwRoutineByServerId(serverid: Oid) -> PgPtr<FdwRoutine>;
}
#[pg_guard]
extern "C" {
    pub fn GetFdwRoutineByRelId(relid: Oid) -> PgPtr<FdwRoutine>;
}
#[pg_guard]
extern "C" {
    pub fn GetFdwRoutineForRelation(
        relation: PgPtr<RelationData>,
        makecopy: bool,
    ) -> PgPtr<FdwRoutine>;
}
#[pg_guard]
extern "C" {
    pub fn IsImportableForeignTable(
        tablename: PgPtr<::std::os::raw::c_char>,
        stmt: PgPtr<ImportForeignSchemaStmt>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetExistingLocalJoinPath(joinrel: PgPtr<RelOptInfo>) -> PgPtr<Path>;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum GenericOptionFlags {
    ServerOpt = 1,
    UserMappingOpt = 2,
    FdwOpt = 4,
}
#[repr(C)]
pub struct ForeignDataWrapper {
    pub fdwid: Oid,
    pub owner: Oid,
    pub fdwname: PgPtr<::std::os::raw::c_char>,
    pub fdwhandler: Oid,
    pub fdwvalidator: Oid,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct ForeignServer {
    pub serverid: Oid,
    pub fdwid: Oid,
    pub owner: Oid,
    pub servername: PgPtr<::std::os::raw::c_char>,
    pub servertype: PgPtr<::std::os::raw::c_char>,
    pub serverversion: PgPtr<::std::os::raw::c_char>,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct UserMapping {
    pub umid: Oid,
    pub userid: Oid,
    pub serverid: Oid,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct ForeignTable {
    pub relid: Oid,
    pub serverid: Oid,
    pub options: PgPtr<List>,
}
#[pg_guard]
extern "C" {
    pub fn GetForeignServer(serverid: Oid) -> PgPtr<ForeignServer>;
}
#[pg_guard]
extern "C" {
    pub fn GetForeignServerExtended(serverid: Oid, flags: bits16) -> PgPtr<ForeignServer>;
}
#[pg_guard]
extern "C" {
    pub fn GetForeignServerByName(
        name: PgPtr<::std::os::raw::c_char>,
        missing_ok: bool,
    ) -> PgPtr<ForeignServer>;
}
#[pg_guard]
extern "C" {
    pub fn GetUserMapping(userid: Oid, serverid: Oid) -> PgPtr<UserMapping>;
}
#[pg_guard]
extern "C" {
    pub fn GetForeignDataWrapper(fdwid: Oid) -> PgPtr<ForeignDataWrapper>;
}
#[pg_guard]
extern "C" {
    pub fn GetForeignDataWrapperExtended(fdwid: Oid, flags: bits16) -> PgPtr<ForeignDataWrapper>;
}
#[pg_guard]
extern "C" {
    pub fn GetForeignDataWrapperByName(
        name: PgPtr<::std::os::raw::c_char>,
        missing_ok: bool,
    ) -> PgPtr<ForeignDataWrapper>;
}
#[pg_guard]
extern "C" {
    pub fn GetForeignTable(relid: Oid) -> PgPtr<ForeignTable>;
}
#[pg_guard]
extern "C" {
    pub fn GetForeignColumnOptions(relid: Oid, attnum: AttrNumber) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn get_foreign_data_wrapper_oid(
        fdwname: PgPtr<::std::os::raw::c_char>,
        missing_ok: bool,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_foreign_server_oid(
        servername: PgPtr<::std::os::raw::c_char>,
        missing_ok: bool,
    ) -> Oid;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ExplainFormat {
    EXPLAIN_FORMAT_TEXT = 0,
    EXPLAIN_FORMAT_XML = 1,
    EXPLAIN_FORMAT_JSON = 2,
    EXPLAIN_FORMAT_YAML = 3,
}
#[repr(C)]
pub struct ExplainState {
    pub str_: PgPtr<StringInfoData>,
    pub verbose: bool,
    pub analyze: bool,
    pub costs: bool,
    pub buffers: bool,
    pub timing: bool,
    pub summary: bool,
    pub settings: bool,
    pub format: ExplainFormat,
    pub indent: ::std::os::raw::c_int,
    pub grouping_stack: PgPtr<List>,
    pub pstmt: PgPtr<PlannedStmt>,
    pub rtable: PgPtr<List>,
    pub rtable_names: PgPtr<List>,
    pub deparse_cxt: PgPtr<List>,
    pub printed_subplans: PgPtr<Bitmapset>,
}
pub type ExplainOneQuery_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        query: PgPtr<Query>,
        cursorOptions: ::std::os::raw::c_int,
        into: PgPtr<IntoClause>,
        es: PgPtr<ExplainState>,
        queryString: PgPtr<::std::os::raw::c_char>,
        params: PgPtr<ParamListInfoData>,
        queryEnv: PgPtr<QueryEnvironment>,
    ),
>;
#[pg_guard]
extern "C" {
    pub static mut ExplainOneQuery_hook: ExplainOneQuery_hook_type;
}
pub type explain_get_index_name_hook_type =
    ::std::option::Option<unsafe extern "C" fn(indexId: Oid) -> PgPtr<::std::os::raw::c_char>>;
#[pg_guard]
extern "C" {
    pub static mut explain_get_index_name_hook: explain_get_index_name_hook_type;
}
#[pg_guard]
extern "C" {
    pub fn ExplainQuery(
        pstate: PgPtr<ParseState>,
        stmt: PgPtr<ExplainStmt>,
        queryString: PgPtr<::std::os::raw::c_char>,
        params: PgPtr<ParamListInfoData>,
        queryEnv: PgPtr<QueryEnvironment>,
        dest: PgPtr<DestReceiver>,
    );
}
#[pg_guard]
extern "C" {
    pub fn NewExplainState() -> PgPtr<ExplainState>;
}
#[pg_guard]
extern "C" {
    pub fn ExplainResultDesc(stmt: PgPtr<ExplainStmt>) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn ExplainOneUtility(
        utilityStmt: PgPtr<Node>,
        into: PgPtr<IntoClause>,
        es: PgPtr<ExplainState>,
        queryString: PgPtr<::std::os::raw::c_char>,
        params: PgPtr<ParamListInfoData>,
        queryEnv: PgPtr<QueryEnvironment>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExplainOnePlan(
        plannedstmt: PgPtr<PlannedStmt>,
        into: PgPtr<IntoClause>,
        es: PgPtr<ExplainState>,
        queryString: PgPtr<::std::os::raw::c_char>,
        params: PgPtr<ParamListInfoData>,
        queryEnv: PgPtr<QueryEnvironment>,
        planduration: PgPtr<instr_time>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExplainPrintPlan(es: PgPtr<ExplainState>, queryDesc: PgPtr<QueryDesc>);
}
#[pg_guard]
extern "C" {
    pub fn ExplainPrintTriggers(es: PgPtr<ExplainState>, queryDesc: PgPtr<QueryDesc>);
}
#[pg_guard]
extern "C" {
    pub fn ExplainPrintJITSummary(es: PgPtr<ExplainState>, queryDesc: PgPtr<QueryDesc>);
}
#[pg_guard]
extern "C" {
    pub fn ExplainPrintJIT(
        es: PgPtr<ExplainState>,
        jit_flags: ::std::os::raw::c_int,
        jit_instr: PgPtr<JitInstrumentation>,
        worker_i: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExplainQueryText(es: PgPtr<ExplainState>, queryDesc: PgPtr<QueryDesc>);
}
#[pg_guard]
extern "C" {
    pub fn ExplainBeginOutput(es: PgPtr<ExplainState>);
}
#[pg_guard]
extern "C" {
    pub fn ExplainEndOutput(es: PgPtr<ExplainState>);
}
#[pg_guard]
extern "C" {
    pub fn ExplainSeparatePlans(es: PgPtr<ExplainState>);
}
#[pg_guard]
extern "C" {
    pub fn ExplainPropertyList(
        qlabel: PgPtr<::std::os::raw::c_char>,
        data: PgPtr<List>,
        es: PgPtr<ExplainState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExplainPropertyListNested(
        qlabel: PgPtr<::std::os::raw::c_char>,
        data: PgPtr<List>,
        es: PgPtr<ExplainState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExplainPropertyText(
        qlabel: PgPtr<::std::os::raw::c_char>,
        value: PgPtr<::std::os::raw::c_char>,
        es: PgPtr<ExplainState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExplainPropertyInteger(
        qlabel: PgPtr<::std::os::raw::c_char>,
        unit: PgPtr<::std::os::raw::c_char>,
        value: int64,
        es: PgPtr<ExplainState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExplainPropertyFloat(
        qlabel: PgPtr<::std::os::raw::c_char>,
        unit: PgPtr<::std::os::raw::c_char>,
        value: f64,
        ndigits: ::std::os::raw::c_int,
        es: PgPtr<ExplainState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExplainPropertyBool(
        qlabel: PgPtr<::std::os::raw::c_char>,
        value: bool,
        es: PgPtr<ExplainState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExplainOpenGroup(
        objtype: PgPtr<::std::os::raw::c_char>,
        labelname: PgPtr<::std::os::raw::c_char>,
        labeled: bool,
        es: PgPtr<ExplainState>,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExplainCloseGroup(
        objtype: PgPtr<::std::os::raw::c_char>,
        labelname: PgPtr<::std::os::raw::c_char>,
        labeled: bool,
        es: PgPtr<ExplainState>,
    );
}
#[repr(C)]
pub struct ExtensibleNode {
    pub type_: NodeTag,
    pub extnodename: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct ExtensibleNodeMethods {
    pub extnodename: PgPtr<::std::os::raw::c_char>,
    pub node_size: Size,
    pub nodeCopy: ::std::option::Option<
        unsafe extern "C" fn(newnode: PgPtr<ExtensibleNode>, oldnode: PgPtr<ExtensibleNode>),
    >,
    pub nodeEqual: ::std::option::Option<
        unsafe extern "C" fn(a: PgPtr<ExtensibleNode>, b: PgPtr<ExtensibleNode>) -> bool,
    >,
    pub nodeOut: ::std::option::Option<
        unsafe extern "C" fn(str_: PgPtr<StringInfoData>, node: PgPtr<ExtensibleNode>),
    >,
    pub nodeRead: ::std::option::Option<unsafe extern "C" fn(node: PgPtr<ExtensibleNode>)>,
}
#[pg_guard]
extern "C" {
    pub fn RegisterExtensibleNodeMethods(method: PgPtr<ExtensibleNodeMethods>);
}
#[pg_guard]
extern "C" {
    pub fn GetExtensibleNodeMethods(
        name: PgPtr<::std::os::raw::c_char>,
        missing_ok: bool,
    ) -> PgPtr<ExtensibleNodeMethods>;
}
#[repr(C)]
pub struct CustomPathMethods {
    pub CustomName: PgPtr<::std::os::raw::c_char>,
    pub PlanCustomPath: ::std::option::Option<
        unsafe extern "C" fn(
            root: PgPtr<PlannerInfo>,
            rel: PgPtr<RelOptInfo>,
            best_path: PgPtr<CustomPath>,
            tlist: PgPtr<List>,
            clauses: PgPtr<List>,
            custom_plans: PgPtr<List>,
        ) -> PgPtr<Plan>,
    >,
    pub ReparameterizeCustomPathByChild: ::std::option::Option<
        unsafe extern "C" fn(
            root: PgPtr<PlannerInfo>,
            custom_private: PgPtr<List>,
            child_rel: PgPtr<RelOptInfo>,
        ) -> PgPtr<List>,
    >,
}
#[repr(C)]
pub struct CustomScanMethods {
    pub CustomName: PgPtr<::std::os::raw::c_char>,
    pub CreateCustomScanState:
        ::std::option::Option<unsafe extern "C" fn(cscan: PgPtr<CustomScan>) -> PgPtr<Node>>,
}
#[repr(C)]
pub struct CustomExecMethods {
    pub CustomName: PgPtr<::std::os::raw::c_char>,
    pub BeginCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: PgPtr<CustomScanState>,
            estate: PgPtr<EState>,
            eflags: ::std::os::raw::c_int,
        ),
    >,
    pub ExecCustomScan: ::std::option::Option<
        unsafe extern "C" fn(node: PgPtr<CustomScanState>) -> PgPtr<TupleTableSlot>,
    >,
    pub EndCustomScan: ::std::option::Option<unsafe extern "C" fn(node: PgPtr<CustomScanState>)>,
    pub ReScanCustomScan: ::std::option::Option<unsafe extern "C" fn(node: PgPtr<CustomScanState>)>,
    pub MarkPosCustomScan:
        ::std::option::Option<unsafe extern "C" fn(node: PgPtr<CustomScanState>)>,
    pub RestrPosCustomScan:
        ::std::option::Option<unsafe extern "C" fn(node: PgPtr<CustomScanState>)>,
    pub EstimateDSMCustomScan: ::std::option::Option<
        unsafe extern "C" fn(node: PgPtr<CustomScanState>, pcxt: PgPtr<ParallelContext>) -> Size,
    >,
    pub InitializeDSMCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: PgPtr<CustomScanState>,
            pcxt: PgPtr<ParallelContext>,
            coordinate: PgPtr<::std::os::raw::c_void>,
        ),
    >,
    pub ReInitializeDSMCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: PgPtr<CustomScanState>,
            pcxt: PgPtr<ParallelContext>,
            coordinate: PgPtr<::std::os::raw::c_void>,
        ),
    >,
    pub InitializeWorkerCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: PgPtr<CustomScanState>,
            toc: PgPtr<shm_toc>,
            coordinate: PgPtr<::std::os::raw::c_void>,
        ),
    >,
    pub ShutdownCustomScan:
        ::std::option::Option<unsafe extern "C" fn(node: PgPtr<CustomScanState>)>,
    pub ExplainCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: PgPtr<CustomScanState>,
            ancestors: PgPtr<List>,
            es: PgPtr<ExplainState>,
        ),
    >,
}
#[pg_guard]
extern "C" {
    pub fn RegisterCustomScanMethods(methods: PgPtr<CustomScanMethods>);
}
#[pg_guard]
extern "C" {
    pub fn GetCustomScanMethods(
        CustomName: PgPtr<::std::os::raw::c_char>,
        missing_ok: bool,
    ) -> PgPtr<CustomScanMethods>;
}
#[pg_guard]
extern "C" {
    pub fn makeA_Expr(
        kind: A_Expr_Kind,
        name: PgPtr<List>,
        lexpr: PgPtr<Node>,
        rexpr: PgPtr<Node>,
        location: ::std::os::raw::c_int,
    ) -> PgPtr<A_Expr>;
}
#[pg_guard]
extern "C" {
    pub fn makeSimpleA_Expr(
        kind: A_Expr_Kind,
        name: PgPtr<::std::os::raw::c_char>,
        lexpr: PgPtr<Node>,
        rexpr: PgPtr<Node>,
        location: ::std::os::raw::c_int,
    ) -> PgPtr<A_Expr>;
}
#[pg_guard]
extern "C" {
    pub fn makeVar(
        varno: Index,
        varattno: AttrNumber,
        vartype: Oid,
        vartypmod: int32,
        varcollid: Oid,
        varlevelsup: Index,
    ) -> PgPtr<Var>;
}
#[pg_guard]
extern "C" {
    pub fn makeVarFromTargetEntry(varno: Index, tle: PgPtr<TargetEntry>) -> PgPtr<Var>;
}
#[pg_guard]
extern "C" {
    pub fn makeWholeRowVar(
        rte: PgPtr<RangeTblEntry>,
        varno: Index,
        varlevelsup: Index,
        allowScalar: bool,
    ) -> PgPtr<Var>;
}
#[pg_guard]
extern "C" {
    pub fn makeTargetEntry(
        expr: PgPtr<Expr>,
        resno: AttrNumber,
        resname: PgPtr<::std::os::raw::c_char>,
        resjunk: bool,
    ) -> PgPtr<TargetEntry>;
}
#[pg_guard]
extern "C" {
    pub fn flatCopyTargetEntry(src_tle: PgPtr<TargetEntry>) -> PgPtr<TargetEntry>;
}
#[pg_guard]
extern "C" {
    pub fn makeFromExpr(fromlist: PgPtr<List>, quals: PgPtr<Node>) -> PgPtr<FromExpr>;
}
#[pg_guard]
extern "C" {
    pub fn makeConst(
        consttype: Oid,
        consttypmod: int32,
        constcollid: Oid,
        constlen: ::std::os::raw::c_int,
        constvalue: Datum,
        constisnull: bool,
        constbyval: bool,
    ) -> PgPtr<Const>;
}
#[pg_guard]
extern "C" {
    pub fn makeNullConst(consttype: Oid, consttypmod: int32, constcollid: Oid) -> PgPtr<Const>;
}
#[pg_guard]
extern "C" {
    pub fn makeBoolConst(value: bool, isnull: bool) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn makeBoolExpr(
        boolop: BoolExprType,
        args: PgPtr<List>,
        location: ::std::os::raw::c_int,
    ) -> PgPtr<Expr>;
}
#[pg_guard]
extern "C" {
    pub fn makeAlias(
        aliasname: PgPtr<::std::os::raw::c_char>,
        colnames: PgPtr<List>,
    ) -> PgPtr<Alias>;
}
#[pg_guard]
extern "C" {
    pub fn makeRelabelType(
        arg: PgPtr<Expr>,
        rtype: Oid,
        rtypmod: int32,
        rcollid: Oid,
        rformat: CoercionForm,
    ) -> PgPtr<RelabelType>;
}
#[pg_guard]
extern "C" {
    pub fn makeRangeVar(
        schemaname: PgPtr<::std::os::raw::c_char>,
        relname: PgPtr<::std::os::raw::c_char>,
        location: ::std::os::raw::c_int,
    ) -> PgPtr<RangeVar>;
}
#[pg_guard]
extern "C" {
    pub fn makeTypeName(typnam: PgPtr<::std::os::raw::c_char>) -> PgPtr<TypeName>;
}
#[pg_guard]
extern "C" {
    pub fn makeTypeNameFromNameList(names: PgPtr<List>) -> PgPtr<TypeName>;
}
#[pg_guard]
extern "C" {
    pub fn makeTypeNameFromOid(typeOid: Oid, typmod: int32) -> PgPtr<TypeName>;
}
#[pg_guard]
extern "C" {
    pub fn makeColumnDef(
        colname: PgPtr<::std::os::raw::c_char>,
        typeOid: Oid,
        typmod: int32,
        collOid: Oid,
    ) -> PgPtr<ColumnDef>;
}
#[pg_guard]
extern "C" {
    pub fn makeFuncExpr(
        funcid: Oid,
        rettype: Oid,
        args: PgPtr<List>,
        funccollid: Oid,
        inputcollid: Oid,
        fformat: CoercionForm,
    ) -> PgPtr<FuncExpr>;
}
#[pg_guard]
extern "C" {
    pub fn makeFuncCall(
        name: PgPtr<List>,
        args: PgPtr<List>,
        location: ::std::os::raw::c_int,
    ) -> PgPtr<FuncCall>;
}
#[pg_guard]
extern "C" {
    pub fn make_opclause(
        opno: Oid,
        opresulttype: Oid,
        opretset: bool,
        leftop: PgPtr<Expr>,
        rightop: PgPtr<Expr>,
        opcollid: Oid,
        inputcollid: Oid,
    ) -> PgPtr<Expr>;
}
#[pg_guard]
extern "C" {
    pub fn make_andclause(andclauses: PgPtr<List>) -> PgPtr<Expr>;
}
#[pg_guard]
extern "C" {
    pub fn make_orclause(orclauses: PgPtr<List>) -> PgPtr<Expr>;
}
#[pg_guard]
extern "C" {
    pub fn make_notclause(notclause: PgPtr<Expr>) -> PgPtr<Expr>;
}
#[pg_guard]
extern "C" {
    pub fn make_and_qual(qual1: PgPtr<Node>, qual2: PgPtr<Node>) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn make_ands_explicit(andclauses: PgPtr<List>) -> PgPtr<Expr>;
}
#[pg_guard]
extern "C" {
    pub fn make_ands_implicit(clause: PgPtr<Expr>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn makeIndexInfo(
        numattrs: ::std::os::raw::c_int,
        numkeyattrs: ::std::os::raw::c_int,
        amoid: Oid,
        expressions: PgPtr<List>,
        predicates: PgPtr<List>,
        unique: bool,
        isready: bool,
        concurrent: bool,
    ) -> PgPtr<IndexInfo>;
}
#[pg_guard]
extern "C" {
    pub fn makeDefElem(
        name: PgPtr<::std::os::raw::c_char>,
        arg: PgPtr<Node>,
        location: ::std::os::raw::c_int,
    ) -> PgPtr<DefElem>;
}
#[pg_guard]
extern "C" {
    pub fn makeDefElemExtended(
        nameSpace: PgPtr<::std::os::raw::c_char>,
        name: PgPtr<::std::os::raw::c_char>,
        arg: PgPtr<Node>,
        defaction: DefElemAction,
        location: ::std::os::raw::c_int,
    ) -> PgPtr<DefElem>;
}
#[pg_guard]
extern "C" {
    pub fn makeGroupingSet(
        kind: GroupingSetKind,
        content: PgPtr<List>,
        location: ::std::os::raw::c_int,
    ) -> PgPtr<GroupingSet>;
}
#[pg_guard]
extern "C" {
    pub fn makeVacuumRelation(
        relation: PgPtr<RangeVar>,
        oid: Oid,
        va_cols: PgPtr<List>,
    ) -> PgPtr<VacuumRelation>;
}
pub type check_function_callback = ::std::option::Option<
    unsafe extern "C" fn(func_id: Oid, context: PgPtr<::std::os::raw::c_void>) -> bool,
>;
#[pg_guard]
extern "C" {
    pub fn exprType(expr: PgPtr<Node>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn exprTypmod(expr: PgPtr<Node>) -> int32;
}
#[pg_guard]
extern "C" {
    pub fn exprIsLengthCoercion(expr: PgPtr<Node>, coercedTypmod: PgPtr<int32>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn relabel_to_typmod(expr: PgPtr<Node>, typmod: int32) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn strip_implicit_coercions(node: PgPtr<Node>) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn expression_returns_set(clause: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn exprCollation(expr: PgPtr<Node>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn exprInputCollation(expr: PgPtr<Node>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn exprSetCollation(expr: PgPtr<Node>, collation: Oid);
}
#[pg_guard]
extern "C" {
    pub fn exprSetInputCollation(expr: PgPtr<Node>, inputcollation: Oid);
}
#[pg_guard]
extern "C" {
    pub fn exprLocation(expr: PgPtr<Node>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn fix_opfuncids(node: PgPtr<Node>);
}
#[pg_guard]
extern "C" {
    pub fn set_opfuncid(opexpr: PgPtr<OpExpr>);
}
#[pg_guard]
extern "C" {
    pub fn set_sa_opfuncid(opexpr: PgPtr<ScalarArrayOpExpr>);
}
#[pg_guard]
extern "C" {
    pub fn check_functions_in_node(
        node: PgPtr<Node>,
        checker: check_function_callback,
        context: PgPtr<::std::os::raw::c_void>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn expression_tree_mutator(
        node: PgPtr<Node>,
        mutator: ::std::option::Option<unsafe extern "C" fn() -> PgPtr<Node>>,
        context: PgPtr<::std::os::raw::c_void>,
    ) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn query_tree_mutator(
        query: PgPtr<Query>,
        mutator: ::std::option::Option<unsafe extern "C" fn() -> PgPtr<Node>>,
        context: PgPtr<::std::os::raw::c_void>,
        flags: ::std::os::raw::c_int,
    ) -> PgPtr<Query>;
}
#[pg_guard]
extern "C" {
    pub fn range_table_walker(
        rtable: PgPtr<List>,
        walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
        context: PgPtr<::std::os::raw::c_void>,
        flags: ::std::os::raw::c_int,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn range_table_mutator(
        rtable: PgPtr<List>,
        mutator: ::std::option::Option<unsafe extern "C" fn() -> PgPtr<Node>>,
        context: PgPtr<::std::os::raw::c_void>,
        flags: ::std::os::raw::c_int,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn range_table_entry_walker(
        rte: PgPtr<RangeTblEntry>,
        walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
        context: PgPtr<::std::os::raw::c_void>,
        flags: ::std::os::raw::c_int,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn query_or_expression_tree_walker(
        node: PgPtr<Node>,
        walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
        context: PgPtr<::std::os::raw::c_void>,
        flags: ::std::os::raw::c_int,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn query_or_expression_tree_mutator(
        node: PgPtr<Node>,
        mutator: ::std::option::Option<unsafe extern "C" fn() -> PgPtr<Node>>,
        context: PgPtr<::std::os::raw::c_void>,
        flags: ::std::os::raw::c_int,
    ) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn raw_expression_tree_walker(
        node: PgPtr<Node>,
        walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
        context: PgPtr<::std::os::raw::c_void>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn planstate_tree_walker(
        planstate: PgPtr<PlanState>,
        walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
        context: PgPtr<::std::os::raw::c_void>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn print(obj: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn pprint(obj: PgPtr<::std::os::raw::c_void>);
}
#[pg_guard]
extern "C" {
    pub fn elog_node_display(
        lev: ::std::os::raw::c_int,
        title: PgPtr<::std::os::raw::c_char>,
        obj: PgPtr<::std::os::raw::c_void>,
        pretty: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn format_node_dump(dump: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pretty_format_node_dump(
        dump: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn print_rt(rtable: PgPtr<List>);
}
#[pg_guard]
extern "C" {
    pub fn print_expr(expr: PgPtr<Node>, rtable: PgPtr<List>);
}
#[pg_guard]
extern "C" {
    pub fn print_pathkeys(pathkeys: PgPtr<List>, rtable: PgPtr<List>);
}
#[pg_guard]
extern "C" {
    pub fn print_tl(tlist: PgPtr<List>, rtable: PgPtr<List>);
}
#[pg_guard]
extern "C" {
    pub fn print_slot(slot: PgPtr<TupleTableSlot>);
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ReplicationKind {
    REPLICATION_KIND_PHYSICAL = 0,
    REPLICATION_KIND_LOGICAL = 1,
}
#[repr(C)]
pub struct IdentifySystemCmd {
    pub type_: NodeTag,
}
#[repr(C)]
pub struct BaseBackupCmd {
    pub type_: NodeTag,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct CreateReplicationSlotCmd {
    pub type_: NodeTag,
    pub slotname: PgPtr<::std::os::raw::c_char>,
    pub kind: ReplicationKind,
    pub plugin: PgPtr<::std::os::raw::c_char>,
    pub temporary: bool,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct DropReplicationSlotCmd {
    pub type_: NodeTag,
    pub slotname: PgPtr<::std::os::raw::c_char>,
    pub wait: bool,
}
#[repr(C)]
pub struct StartReplicationCmd {
    pub type_: NodeTag,
    pub kind: ReplicationKind,
    pub slotname: PgPtr<::std::os::raw::c_char>,
    pub timeline: TimeLineID,
    pub startpoint: XLogRecPtr,
    pub options: PgPtr<List>,
}
#[repr(C)]
pub struct TimeLineHistoryCmd {
    pub type_: NodeTag,
    pub timeline: TimeLineID,
}
#[repr(C)]
pub struct SQLCmd {
    pub type_: NodeTag,
}
#[repr(C)]
pub struct SupportRequestSimplify {
    pub type_: NodeTag,
    pub root: PgPtr<PlannerInfo>,
    pub fcall: PgPtr<FuncExpr>,
}
#[repr(C)]
pub struct SupportRequestSelectivity {
    pub type_: NodeTag,
    pub root: PgPtr<PlannerInfo>,
    pub funcid: Oid,
    pub args: PgPtr<List>,
    pub inputcollid: Oid,
    pub is_join: bool,
    pub varRelid: ::std::os::raw::c_int,
    pub jointype: JoinType,
    pub sjinfo: PgPtr<SpecialJoinInfo>,
    pub selectivity: Selectivity,
}
#[repr(C)]
pub struct SupportRequestCost {
    pub type_: NodeTag,
    pub root: PgPtr<PlannerInfo>,
    pub funcid: Oid,
    pub node: PgPtr<Node>,
    pub startup: Cost,
    pub per_tuple: Cost,
}
#[repr(C)]
pub struct SupportRequestRows {
    pub type_: NodeTag,
    pub root: PgPtr<PlannerInfo>,
    pub funcid: Oid,
    pub node: PgPtr<Node>,
    pub rows: f64,
}
#[repr(C)]
pub struct SupportRequestIndexCondition {
    pub type_: NodeTag,
    pub root: PgPtr<PlannerInfo>,
    pub funcid: Oid,
    pub node: PgPtr<Node>,
    pub indexarg: ::std::os::raw::c_int,
    pub index: PgPtr<IndexOptInfo>,
    pub indexcol: ::std::os::raw::c_int,
    pub opfamily: Oid,
    pub indexcollation: Oid,
    pub lossy: bool,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ConstraintExclusionType {
    CONSTRAINT_EXCLUSION_OFF = 0,
    CONSTRAINT_EXCLUSION_ON = 1,
    CONSTRAINT_EXCLUSION_PARTITION = 2,
}
#[pg_guard]
extern "C" {
    pub static mut disable_cost: Cost;
}
#[pg_guard]
extern "C" {
    pub static mut max_parallel_workers_per_gather: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut enable_seqscan: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_indexscan: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_indexonlyscan: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_bitmapscan: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_tidscan: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_sort: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_hashagg: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_nestloop: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_material: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_mergejoin: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_hashjoin: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_gathermerge: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_partitionwise_join: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_partitionwise_aggregate: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_parallel_append: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_parallel_hash: bool;
}
#[pg_guard]
extern "C" {
    pub static mut enable_partition_pruning: bool;
}
#[pg_guard]
extern "C" {
    pub static mut constraint_exclusion: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn index_pages_fetched(
        tuples_fetched: f64,
        pages: BlockNumber,
        index_pages: f64,
        root: PgPtr<PlannerInfo>,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn cost_seqscan(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        param_info: PgPtr<ParamPathInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_samplescan(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        param_info: PgPtr<ParamPathInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_index(
        path: PgPtr<IndexPath>,
        root: PgPtr<PlannerInfo>,
        loop_count: f64,
        partial_path: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_bitmap_heap_scan(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        param_info: PgPtr<ParamPathInfo>,
        bitmapqual: PgPtr<Path>,
        loop_count: f64,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_bitmap_and_node(path: PgPtr<BitmapAndPath>, root: PgPtr<PlannerInfo>);
}
#[pg_guard]
extern "C" {
    pub fn cost_bitmap_or_node(path: PgPtr<BitmapOrPath>, root: PgPtr<PlannerInfo>);
}
#[pg_guard]
extern "C" {
    pub fn cost_bitmap_tree_node(path: PgPtr<Path>, cost: PgPtr<Cost>, selec: PgPtr<Selectivity>);
}
#[pg_guard]
extern "C" {
    pub fn cost_tidscan(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        tidquals: PgPtr<List>,
        param_info: PgPtr<ParamPathInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_subqueryscan(
        path: PgPtr<SubqueryScanPath>,
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        param_info: PgPtr<ParamPathInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_functionscan(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        param_info: PgPtr<ParamPathInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_valuesscan(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        param_info: PgPtr<ParamPathInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_tablefuncscan(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        param_info: PgPtr<ParamPathInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_ctescan(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        param_info: PgPtr<ParamPathInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_namedtuplestorescan(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        param_info: PgPtr<ParamPathInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_resultscan(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        param_info: PgPtr<ParamPathInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_recursive_union(runion: PgPtr<Path>, nrterm: PgPtr<Path>, rterm: PgPtr<Path>);
}
#[pg_guard]
extern "C" {
    pub fn cost_sort(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        pathkeys: PgPtr<List>,
        input_cost: Cost,
        tuples: f64,
        width: ::std::os::raw::c_int,
        comparison_cost: Cost,
        sort_mem: ::std::os::raw::c_int,
        limit_tuples: f64,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_append(path: PgPtr<AppendPath>);
}
#[pg_guard]
extern "C" {
    pub fn cost_merge_append(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        pathkeys: PgPtr<List>,
        n_streams: ::std::os::raw::c_int,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        tuples: f64,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_material(
        path: PgPtr<Path>,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        tuples: f64,
        width: ::std::os::raw::c_int,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_agg(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        aggstrategy: AggStrategy,
        aggcosts: PgPtr<AggClauseCosts>,
        numGroupCols: ::std::os::raw::c_int,
        numGroups: f64,
        quals: PgPtr<List>,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        input_tuples: f64,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_windowagg(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        windowFuncs: PgPtr<List>,
        numPartCols: ::std::os::raw::c_int,
        numOrderCols: ::std::os::raw::c_int,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        input_tuples: f64,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_group(
        path: PgPtr<Path>,
        root: PgPtr<PlannerInfo>,
        numGroupCols: ::std::os::raw::c_int,
        numGroups: f64,
        quals: PgPtr<List>,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        input_tuples: f64,
    );
}
#[pg_guard]
extern "C" {
    pub fn initial_cost_nestloop(
        root: PgPtr<PlannerInfo>,
        workspace: PgPtr<JoinCostWorkspace>,
        jointype: JoinType,
        outer_path: PgPtr<Path>,
        inner_path: PgPtr<Path>,
        extra: PgPtr<JoinPathExtraData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn final_cost_nestloop(
        root: PgPtr<PlannerInfo>,
        path: PgPtr<NestPath>,
        workspace: PgPtr<JoinCostWorkspace>,
        extra: PgPtr<JoinPathExtraData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn initial_cost_mergejoin(
        root: PgPtr<PlannerInfo>,
        workspace: PgPtr<JoinCostWorkspace>,
        jointype: JoinType,
        mergeclauses: PgPtr<List>,
        outer_path: PgPtr<Path>,
        inner_path: PgPtr<Path>,
        outersortkeys: PgPtr<List>,
        innersortkeys: PgPtr<List>,
        extra: PgPtr<JoinPathExtraData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn final_cost_mergejoin(
        root: PgPtr<PlannerInfo>,
        path: PgPtr<MergePath>,
        workspace: PgPtr<JoinCostWorkspace>,
        extra: PgPtr<JoinPathExtraData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn initial_cost_hashjoin(
        root: PgPtr<PlannerInfo>,
        workspace: PgPtr<JoinCostWorkspace>,
        jointype: JoinType,
        hashclauses: PgPtr<List>,
        outer_path: PgPtr<Path>,
        inner_path: PgPtr<Path>,
        extra: PgPtr<JoinPathExtraData>,
        parallel_hash: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn final_cost_hashjoin(
        root: PgPtr<PlannerInfo>,
        path: PgPtr<HashPath>,
        workspace: PgPtr<JoinCostWorkspace>,
        extra: PgPtr<JoinPathExtraData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_gather(
        path: PgPtr<GatherPath>,
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        param_info: PgPtr<ParamPathInfo>,
        rows: PgPtr<f64>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_gather_merge(
        path: PgPtr<GatherMergePath>,
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        param_info: PgPtr<ParamPathInfo>,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        rows: PgPtr<f64>,
    );
}
#[pg_guard]
extern "C" {
    pub fn cost_subplan(root: PgPtr<PlannerInfo>, subplan: PgPtr<SubPlan>, plan: PgPtr<Plan>);
}
#[pg_guard]
extern "C" {
    pub fn cost_qual_eval(cost: PgPtr<QualCost>, quals: PgPtr<List>, root: PgPtr<PlannerInfo>);
}
#[pg_guard]
extern "C" {
    pub fn cost_qual_eval_node(cost: PgPtr<QualCost>, qual: PgPtr<Node>, root: PgPtr<PlannerInfo>);
}
#[pg_guard]
extern "C" {
    pub fn compute_semi_anti_join_factors(
        root: PgPtr<PlannerInfo>,
        joinrel: PgPtr<RelOptInfo>,
        outerrel: PgPtr<RelOptInfo>,
        innerrel: PgPtr<RelOptInfo>,
        jointype: JoinType,
        sjinfo: PgPtr<SpecialJoinInfo>,
        restrictlist: PgPtr<List>,
        semifactors: PgPtr<SemiAntiJoinFactors>,
    );
}
#[pg_guard]
extern "C" {
    pub fn set_baserel_size_estimates(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn get_parameterized_baserel_size(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        param_clauses: PgPtr<List>,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn get_parameterized_joinrel_size(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        outer_path: PgPtr<Path>,
        inner_path: PgPtr<Path>,
        sjinfo: PgPtr<SpecialJoinInfo>,
        restrict_clauses: PgPtr<List>,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn set_joinrel_size_estimates(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        outer_rel: PgPtr<RelOptInfo>,
        inner_rel: PgPtr<RelOptInfo>,
        sjinfo: PgPtr<SpecialJoinInfo>,
        restrictlist: PgPtr<List>,
    );
}
#[pg_guard]
extern "C" {
    pub fn set_subquery_size_estimates(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn set_function_size_estimates(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn set_values_size_estimates(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn set_cte_size_estimates(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>, cte_rows: f64);
}
#[pg_guard]
extern "C" {
    pub fn set_tablefunc_size_estimates(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn set_namedtuplestore_size_estimates(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn set_result_size_estimates(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn set_foreign_size_estimates(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn set_pathtarget_cost_width(
        root: PgPtr<PlannerInfo>,
        target: PgPtr<PathTarget>,
    ) -> PgPtr<PathTarget>;
}
#[pg_guard]
extern "C" {
    pub fn compute_bitmap_pages(
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        bitmapqual: PgPtr<Path>,
        loop_count: ::std::os::raw::c_int,
        cost: PgPtr<Cost>,
        tuple: PgPtr<f64>,
    ) -> f64;
}
#[repr(C)]
pub struct WindowFuncLists {
    pub numWindowFuncs: ::std::os::raw::c_int,
    pub maxWinRef: Index,
    pub windowFuncs: PgPtr<PgPtr<List>>,
}
#[pg_guard]
extern "C" {
    pub fn contain_agg_clause(clause: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_agg_clause_costs(
        root: PgPtr<PlannerInfo>,
        clause: PgPtr<Node>,
        aggsplit: AggSplit,
        costs: PgPtr<AggClauseCosts>,
    );
}
#[pg_guard]
extern "C" {
    pub fn contain_window_function(clause: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn find_window_functions(clause: PgPtr<Node>, maxWinRef: Index) -> PgPtr<WindowFuncLists>;
}
#[pg_guard]
extern "C" {
    pub fn expression_returns_set_rows(root: PgPtr<PlannerInfo>, clause: PgPtr<Node>) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn contain_subplans(clause: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn max_parallel_hazard(parse: PgPtr<Query>) -> ::std::os::raw::c_char;
}
#[pg_guard]
extern "C" {
    pub fn is_parallel_safe(root: PgPtr<PlannerInfo>, node: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn contain_nonstrict_functions(clause: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn contain_leaked_vars(clause: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn find_nonnullable_rels(clause: PgPtr<Node>) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn find_nonnullable_vars(clause: PgPtr<Node>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn find_forced_null_vars(clause: PgPtr<Node>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn find_forced_null_var(clause: PgPtr<Node>) -> PgPtr<Var>;
}
#[pg_guard]
extern "C" {
    pub fn is_pseudo_constant_clause(clause: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn is_pseudo_constant_clause_relids(clause: PgPtr<Node>, relids: PgPtr<Bitmapset>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn NumRelids(clause: PgPtr<Node>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn CommuteOpExpr(clause: PgPtr<OpExpr>);
}
#[pg_guard]
extern "C" {
    pub fn inline_set_returning_function(
        root: PgPtr<PlannerInfo>,
        rte: PgPtr<RangeTblEntry>,
    ) -> PgPtr<Query>;
}
#[pg_guard]
extern "C" {
    pub fn clause_selectivity(
        root: PgPtr<PlannerInfo>,
        clause: PgPtr<Node>,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: PgPtr<SpecialJoinInfo>,
    ) -> Selectivity;
}
#[pg_guard]
extern "C" {
    pub fn clauselist_selectivity_simple(
        root: PgPtr<PlannerInfo>,
        clauses: PgPtr<List>,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: PgPtr<SpecialJoinInfo>,
        estimatedclauses: PgPtr<Bitmapset>,
    ) -> Selectivity;
}
#[pg_guard]
extern "C" {
    pub fn clauselist_selectivity(
        root: PgPtr<PlannerInfo>,
        clauses: PgPtr<List>,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: PgPtr<SpecialJoinInfo>,
    ) -> Selectivity;
}
#[pg_guard]
extern "C" {
    pub static mut seq_page_cost: f64;
}
#[pg_guard]
extern "C" {
    pub static mut random_page_cost: f64;
}
#[pg_guard]
extern "C" {
    pub static mut cpu_tuple_cost: f64;
}
#[pg_guard]
extern "C" {
    pub static mut cpu_index_tuple_cost: f64;
}
#[pg_guard]
extern "C" {
    pub static mut cpu_operator_cost: f64;
}
#[pg_guard]
extern "C" {
    pub static mut parallel_tuple_cost: f64;
}
#[pg_guard]
extern "C" {
    pub static mut parallel_setup_cost: f64;
}
#[pg_guard]
extern "C" {
    pub static mut effective_cache_size: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn clamp_row_est(nrows: f64) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn is_pseudo_constant_for_index(expr: PgPtr<Node>, index: PgPtr<IndexOptInfo>) -> bool;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ForceParallelMode {
    FORCE_PARALLEL_OFF = 0,
    FORCE_PARALLEL_ON = 1,
    FORCE_PARALLEL_REGRESS = 2,
}
#[pg_guard]
extern "C" {
    pub static mut force_parallel_mode: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut parallel_leader_participation: bool;
}
#[pg_guard]
extern "C" {
    pub fn planner(
        parse: PgPtr<Query>,
        cursorOptions: ::std::os::raw::c_int,
        boundParams: PgPtr<ParamListInfoData>,
    ) -> PgPtr<PlannedStmt>;
}
#[pg_guard]
extern "C" {
    pub fn expression_planner(expr: PgPtr<Expr>) -> PgPtr<Expr>;
}
#[pg_guard]
extern "C" {
    pub fn expression_planner_with_deps(
        expr: PgPtr<Expr>,
        relationOids: PgPtr<PgPtr<List>>,
        invalItems: PgPtr<PgPtr<List>>,
    ) -> PgPtr<Expr>;
}
#[pg_guard]
extern "C" {
    pub fn plan_cluster_use_sort(tableOid: Oid, indexOid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn plan_create_index_workers(tableOid: Oid, indexOid: Oid) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn extract_query_dependencies(
        query: PgPtr<Node>,
        relationOids: PgPtr<PgPtr<List>>,
        invalItems: PgPtr<PgPtr<List>>,
        hasRowSecurity: PgPtr<bool>,
    );
}
#[pg_guard]
extern "C" {
    pub fn negate_clause(node: PgPtr<Node>) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn canonicalize_qual(qual: PgPtr<Expr>, is_check: bool) -> PgPtr<Expr>;
}
#[pg_guard]
extern "C" {
    pub fn contain_mutable_functions(clause: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn contain_volatile_functions(clause: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn contain_volatile_functions_not_nextval(clause: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn eval_const_expressions(root: PgPtr<PlannerInfo>, node: PgPtr<Node>) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn estimate_expression_value(root: PgPtr<PlannerInfo>, node: PgPtr<Node>) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn evaluate_expr(
        expr: PgPtr<Expr>,
        result_type: Oid,
        result_typmod: int32,
        result_collation: Oid,
    ) -> PgPtr<Expr>;
}
#[pg_guard]
extern "C" {
    pub fn expand_function_arguments(
        args: PgPtr<List>,
        result_type: Oid,
        func_tuple: PgPtr<HeapTupleData>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn predicate_implied_by(
        predicate_list: PgPtr<List>,
        clause_list: PgPtr<List>,
        weak: bool,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn predicate_refuted_by(
        predicate_list: PgPtr<List>,
        clause_list: PgPtr<List>,
        weak: bool,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn count_nonjunk_tlist_entries(tlist: PgPtr<List>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn get_sortgroupref_tle(sortref: Index, targetList: PgPtr<List>) -> PgPtr<TargetEntry>;
}
#[pg_guard]
extern "C" {
    pub fn get_sortgroupclause_tle(
        sgClause: PgPtr<SortGroupClause>,
        targetList: PgPtr<List>,
    ) -> PgPtr<TargetEntry>;
}
#[pg_guard]
extern "C" {
    pub fn get_sortgroupclause_expr(
        sgClause: PgPtr<SortGroupClause>,
        targetList: PgPtr<List>,
    ) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn get_sortgrouplist_exprs(sgClauses: PgPtr<List>, targetList: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn get_sortgroupref_clause(sortref: Index, clauses: PgPtr<List>) -> PgPtr<SortGroupClause>;
}
#[pg_guard]
extern "C" {
    pub fn get_sortgroupref_clause_noerr(
        sortref: Index,
        clauses: PgPtr<List>,
    ) -> PgPtr<SortGroupClause>;
}
#[pg_guard]
extern "C" {
    pub fn pull_varnos(node: PgPtr<Node>) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn pull_varnos_of_level(
        node: PgPtr<Node>,
        levelsup: ::std::os::raw::c_int,
    ) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn pull_varattnos(node: PgPtr<Node>, varno: Index, varattnos: PgPtr<PgPtr<Bitmapset>>);
}
#[pg_guard]
extern "C" {
    pub fn pull_vars_of_level(node: PgPtr<Node>, levelsup: ::std::os::raw::c_int) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn contain_var_clause(node: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn contain_vars_of_level(node: PgPtr<Node>, levelsup: ::std::os::raw::c_int) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn locate_var_of_level(
        node: PgPtr<Node>,
        levelsup: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pull_var_clause(node: PgPtr<Node>, flags: ::std::os::raw::c_int) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn flatten_join_alias_vars(query: PgPtr<Query>, node: PgPtr<Node>) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub static mut enable_geqo: bool;
}
#[pg_guard]
extern "C" {
    pub static mut geqo_threshold: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut min_parallel_table_scan_size: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut min_parallel_index_scan_size: ::std::os::raw::c_int;
}
pub type set_rel_pathlist_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        rti: Index,
        rte: PgPtr<RangeTblEntry>,
    ),
>;
#[pg_guard]
extern "C" {
    pub static mut set_rel_pathlist_hook: set_rel_pathlist_hook_type;
}
pub type set_join_pathlist_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        joinrel: PgPtr<RelOptInfo>,
        outerrel: PgPtr<RelOptInfo>,
        innerrel: PgPtr<RelOptInfo>,
        jointype: JoinType,
        extra: PgPtr<JoinPathExtraData>,
    ),
>;
#[pg_guard]
extern "C" {
    pub static mut set_join_pathlist_hook: set_join_pathlist_hook_type;
}
pub type join_search_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        levels_needed: ::std::os::raw::c_int,
        initial_rels: PgPtr<List>,
    ) -> PgPtr<RelOptInfo>,
>;
#[pg_guard]
extern "C" {
    pub static mut join_search_hook: join_search_hook_type;
}
#[pg_guard]
extern "C" {
    pub fn make_one_rel(root: PgPtr<PlannerInfo>, joinlist: PgPtr<List>) -> PgPtr<RelOptInfo>;
}
#[pg_guard]
extern "C" {
    pub fn standard_join_search(
        root: PgPtr<PlannerInfo>,
        levels_needed: ::std::os::raw::c_int,
        initial_rels: PgPtr<List>,
    ) -> PgPtr<RelOptInfo>;
}
#[pg_guard]
extern "C" {
    pub fn generate_gather_paths(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        override_rows: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn compute_parallel_worker(
        rel: PgPtr<RelOptInfo>,
        heap_pages: f64,
        index_pages: f64,
        max_workers: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn create_partial_bitmap_paths(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        bitmapqual: PgPtr<Path>,
    );
}
#[pg_guard]
extern "C" {
    pub fn generate_partitionwise_join_paths(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn create_index_paths(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn relation_has_unique_index_for(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        restrictlist: PgPtr<List>,
        exprlist: PgPtr<List>,
        oprlist: PgPtr<List>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn indexcol_is_bool_constant_for_query(
        index: PgPtr<IndexOptInfo>,
        indexcol: ::std::os::raw::c_int,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn match_index_to_operand(
        operand: PgPtr<Node>,
        indexcol: ::std::os::raw::c_int,
        index: PgPtr<IndexOptInfo>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn check_index_predicates(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn create_tidscan_paths(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn add_paths_to_joinrel(
        root: PgPtr<PlannerInfo>,
        joinrel: PgPtr<RelOptInfo>,
        outerrel: PgPtr<RelOptInfo>,
        innerrel: PgPtr<RelOptInfo>,
        jointype: JoinType,
        sjinfo: PgPtr<SpecialJoinInfo>,
        restrictlist: PgPtr<List>,
    );
}
#[pg_guard]
extern "C" {
    pub fn join_search_one_level(root: PgPtr<PlannerInfo>, level: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn make_join_rel(
        root: PgPtr<PlannerInfo>,
        rel1: PgPtr<RelOptInfo>,
        rel2: PgPtr<RelOptInfo>,
    ) -> PgPtr<RelOptInfo>;
}
#[pg_guard]
extern "C" {
    pub fn have_join_order_restriction(
        root: PgPtr<PlannerInfo>,
        rel1: PgPtr<RelOptInfo>,
        rel2: PgPtr<RelOptInfo>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn have_dangerous_phv(
        root: PgPtr<PlannerInfo>,
        outer_relids: PgPtr<Bitmapset>,
        inner_params: PgPtr<Bitmapset>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn mark_dummy_rel(rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn have_partkey_equi_join(
        joinrel: PgPtr<RelOptInfo>,
        rel1: PgPtr<RelOptInfo>,
        rel2: PgPtr<RelOptInfo>,
        jointype: JoinType,
        restrictlist: PgPtr<List>,
    ) -> bool;
}
pub type ec_matches_callback_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        ec: PgPtr<EquivalenceClass>,
        em: PgPtr<EquivalenceMember>,
        arg: PgPtr<::std::os::raw::c_void>,
    ) -> bool,
>;
#[pg_guard]
extern "C" {
    pub fn process_equivalence(
        root: PgPtr<PlannerInfo>,
        p_restrictinfo: PgPtr<PgPtr<RestrictInfo>>,
        below_outer_join: bool,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn canonicalize_ec_expression(
        expr: PgPtr<Expr>,
        req_type: Oid,
        req_collation: Oid,
    ) -> PgPtr<Expr>;
}
#[pg_guard]
extern "C" {
    pub fn reconsider_outer_join_clauses(root: PgPtr<PlannerInfo>);
}
#[pg_guard]
extern "C" {
    pub fn get_eclass_for_sort_expr(
        root: PgPtr<PlannerInfo>,
        expr: PgPtr<Expr>,
        nullable_relids: PgPtr<Bitmapset>,
        opfamilies: PgPtr<List>,
        opcintype: Oid,
        collation: Oid,
        sortref: Index,
        rel: PgPtr<Bitmapset>,
        create_it: bool,
    ) -> PgPtr<EquivalenceClass>;
}
#[pg_guard]
extern "C" {
    pub fn generate_base_implied_equalities(root: PgPtr<PlannerInfo>);
}
#[pg_guard]
extern "C" {
    pub fn generate_join_implied_equalities(
        root: PgPtr<PlannerInfo>,
        join_relids: PgPtr<Bitmapset>,
        outer_relids: PgPtr<Bitmapset>,
        inner_rel: PgPtr<RelOptInfo>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn generate_join_implied_equalities_for_ecs(
        root: PgPtr<PlannerInfo>,
        eclasses: PgPtr<List>,
        join_relids: PgPtr<Bitmapset>,
        outer_relids: PgPtr<Bitmapset>,
        inner_rel: PgPtr<RelOptInfo>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn exprs_known_equal(
        root: PgPtr<PlannerInfo>,
        item1: PgPtr<Node>,
        item2: PgPtr<Node>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn match_eclasses_to_foreign_key_col(
        root: PgPtr<PlannerInfo>,
        fkinfo: PgPtr<ForeignKeyOptInfo>,
        colno: ::std::os::raw::c_int,
    ) -> PgPtr<EquivalenceClass>;
}
#[pg_guard]
extern "C" {
    pub fn add_child_rel_equivalences(
        root: PgPtr<PlannerInfo>,
        appinfo: PgPtr<AppendRelInfo>,
        parent_rel: PgPtr<RelOptInfo>,
        child_rel: PgPtr<RelOptInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn add_child_join_rel_equivalences(
        root: PgPtr<PlannerInfo>,
        nappinfos: ::std::os::raw::c_int,
        appinfos: PgPtr<PgPtr<AppendRelInfo>>,
        parent_rel: PgPtr<RelOptInfo>,
        child_rel: PgPtr<RelOptInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn generate_implied_equalities_for_column(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        callback: ec_matches_callback_type,
        callback_arg: PgPtr<::std::os::raw::c_void>,
        prohibited_rels: PgPtr<Bitmapset>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn have_relevant_eclass_joinclause(
        root: PgPtr<PlannerInfo>,
        rel1: PgPtr<RelOptInfo>,
        rel2: PgPtr<RelOptInfo>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn has_relevant_eclass_joinclause(
        root: PgPtr<PlannerInfo>,
        rel1: PgPtr<RelOptInfo>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn eclass_useful_for_merging(
        root: PgPtr<PlannerInfo>,
        eclass: PgPtr<EquivalenceClass>,
        rel: PgPtr<RelOptInfo>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn is_redundant_derived_clause(rinfo: PgPtr<RestrictInfo>, clauselist: PgPtr<List>)
        -> bool;
}
#[pg_guard]
extern "C" {
    pub fn is_redundant_with_indexclauses(
        rinfo: PgPtr<RestrictInfo>,
        indexclauses: PgPtr<List>,
    ) -> bool;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum PathKeysComparison {
    PATHKEYS_EQUAL = 0,
    PATHKEYS_BETTER1 = 1,
    PATHKEYS_BETTER2 = 2,
    PATHKEYS_DIFFERENT = 3,
}
#[pg_guard]
extern "C" {
    pub fn compare_pathkeys(keys1: PgPtr<List>, keys2: PgPtr<List>) -> PathKeysComparison;
}
#[pg_guard]
extern "C" {
    pub fn pathkeys_contained_in(keys1: PgPtr<List>, keys2: PgPtr<List>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_cheapest_path_for_pathkeys(
        paths: PgPtr<List>,
        pathkeys: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
        cost_criterion: CostSelector,
        require_parallel_safe: bool,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn get_cheapest_fractional_path_for_pathkeys(
        paths: PgPtr<List>,
        pathkeys: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
        fraction: f64,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn get_cheapest_parallel_safe_total_inner(paths: PgPtr<List>) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn build_index_pathkeys(
        root: PgPtr<PlannerInfo>,
        index: PgPtr<IndexOptInfo>,
        scandir: ScanDirection,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn build_partition_pathkeys(
        root: PgPtr<PlannerInfo>,
        partrel: PgPtr<RelOptInfo>,
        scandir: ScanDirection,
        partialkeys: PgPtr<bool>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn build_expression_pathkey(
        root: PgPtr<PlannerInfo>,
        expr: PgPtr<Expr>,
        nullable_relids: PgPtr<Bitmapset>,
        opno: Oid,
        rel: PgPtr<Bitmapset>,
        create_it: bool,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn convert_subquery_pathkeys(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subquery_pathkeys: PgPtr<List>,
        subquery_tlist: PgPtr<List>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn build_join_pathkeys(
        root: PgPtr<PlannerInfo>,
        joinrel: PgPtr<RelOptInfo>,
        jointype: JoinType,
        outer_pathkeys: PgPtr<List>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn make_pathkeys_for_sortclauses(
        root: PgPtr<PlannerInfo>,
        sortclauses: PgPtr<List>,
        tlist: PgPtr<List>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn initialize_mergeclause_eclasses(
        root: PgPtr<PlannerInfo>,
        restrictinfo: PgPtr<RestrictInfo>,
    );
}
#[pg_guard]
extern "C" {
    pub fn update_mergeclause_eclasses(root: PgPtr<PlannerInfo>, restrictinfo: PgPtr<RestrictInfo>);
}
#[pg_guard]
extern "C" {
    pub fn find_mergeclauses_for_outer_pathkeys(
        root: PgPtr<PlannerInfo>,
        pathkeys: PgPtr<List>,
        restrictinfos: PgPtr<List>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn select_outer_pathkeys_for_merge(
        root: PgPtr<PlannerInfo>,
        mergeclauses: PgPtr<List>,
        joinrel: PgPtr<RelOptInfo>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn make_inner_pathkeys_for_merge(
        root: PgPtr<PlannerInfo>,
        mergeclauses: PgPtr<List>,
        outer_pathkeys: PgPtr<List>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn trim_mergeclauses_for_inner_pathkeys(
        root: PgPtr<PlannerInfo>,
        mergeclauses: PgPtr<List>,
        pathkeys: PgPtr<List>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn truncate_useless_pathkeys(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        pathkeys: PgPtr<List>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn has_useful_pathkeys(root: PgPtr<PlannerInfo>, rel: PgPtr<RelOptInfo>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn make_canonical_pathkey(
        root: PgPtr<PlannerInfo>,
        eclass: PgPtr<EquivalenceClass>,
        opfamily: Oid,
        strategy: ::std::os::raw::c_int,
        nulls_first: bool,
    ) -> PgPtr<PathKey>;
}
#[pg_guard]
extern "C" {
    pub fn add_paths_to_append_rel(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        live_childrels: PgPtr<List>,
    );
}
#[pg_guard]
extern "C" {
    pub fn compare_path_costs(
        path1: PgPtr<Path>,
        path2: PgPtr<Path>,
        criterion: CostSelector,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn compare_fractional_path_costs(
        path1: PgPtr<Path>,
        path2: PgPtr<Path>,
        fraction: f64,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn set_cheapest(parent_rel: PgPtr<RelOptInfo>);
}
#[pg_guard]
extern "C" {
    pub fn add_path(parent_rel: PgPtr<RelOptInfo>, new_path: PgPtr<Path>);
}
#[pg_guard]
extern "C" {
    pub fn add_path_precheck(
        parent_rel: PgPtr<RelOptInfo>,
        startup_cost: Cost,
        total_cost: Cost,
        pathkeys: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn add_partial_path(parent_rel: PgPtr<RelOptInfo>, new_path: PgPtr<Path>);
}
#[pg_guard]
extern "C" {
    pub fn add_partial_path_precheck(
        parent_rel: PgPtr<RelOptInfo>,
        total_cost: Cost,
        pathkeys: PgPtr<List>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn create_seqscan_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        required_outer: PgPtr<Bitmapset>,
        parallel_workers: ::std::os::raw::c_int,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn create_samplescan_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn create_index_path(
        root: PgPtr<PlannerInfo>,
        index: PgPtr<IndexOptInfo>,
        indexclauses: PgPtr<List>,
        indexorderbys: PgPtr<List>,
        indexorderbycols: PgPtr<List>,
        pathkeys: PgPtr<List>,
        indexscandir: ScanDirection,
        indexonly: bool,
        required_outer: PgPtr<Bitmapset>,
        loop_count: f64,
        partial_path: bool,
    ) -> PgPtr<IndexPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_bitmap_heap_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        bitmapqual: PgPtr<Path>,
        required_outer: PgPtr<Bitmapset>,
        loop_count: f64,
        parallel_degree: ::std::os::raw::c_int,
    ) -> PgPtr<BitmapHeapPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_bitmap_and_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        bitmapquals: PgPtr<List>,
    ) -> PgPtr<BitmapAndPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_bitmap_or_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        bitmapquals: PgPtr<List>,
    ) -> PgPtr<BitmapOrPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_tidscan_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        tidquals: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<TidPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_append_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpaths: PgPtr<List>,
        partial_subpaths: PgPtr<List>,
        pathkeys: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
        parallel_workers: ::std::os::raw::c_int,
        parallel_aware: bool,
        partitioned_rels: PgPtr<List>,
        rows: f64,
    ) -> PgPtr<AppendPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_merge_append_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpaths: PgPtr<List>,
        pathkeys: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
        partitioned_rels: PgPtr<List>,
    ) -> PgPtr<MergeAppendPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_group_result_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        target: PgPtr<PathTarget>,
        havingqual: PgPtr<List>,
    ) -> PgPtr<GroupResultPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_material_path(
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
    ) -> PgPtr<MaterialPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_unique_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        sjinfo: PgPtr<SpecialJoinInfo>,
    ) -> PgPtr<UniquePath>;
}
#[pg_guard]
extern "C" {
    pub fn create_gather_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        target: PgPtr<PathTarget>,
        required_outer: PgPtr<Bitmapset>,
        rows: PgPtr<f64>,
    ) -> PgPtr<GatherPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_gather_merge_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        target: PgPtr<PathTarget>,
        pathkeys: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
        rows: PgPtr<f64>,
    ) -> PgPtr<GatherMergePath>;
}
#[pg_guard]
extern "C" {
    pub fn create_subqueryscan_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        pathkeys: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<SubqueryScanPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_functionscan_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        pathkeys: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn create_valuesscan_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn create_tablefuncscan_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn create_ctescan_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn create_namedtuplestorescan_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn create_resultscan_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn create_worktablescan_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn create_foreignscan_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        target: PgPtr<PathTarget>,
        rows: f64,
        startup_cost: Cost,
        total_cost: Cost,
        pathkeys: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
        fdw_outerpath: PgPtr<Path>,
        fdw_private: PgPtr<List>,
    ) -> PgPtr<ForeignPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_foreign_join_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        target: PgPtr<PathTarget>,
        rows: f64,
        startup_cost: Cost,
        total_cost: Cost,
        pathkeys: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
        fdw_outerpath: PgPtr<Path>,
        fdw_private: PgPtr<List>,
    ) -> PgPtr<ForeignPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_foreign_upper_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        target: PgPtr<PathTarget>,
        rows: f64,
        startup_cost: Cost,
        total_cost: Cost,
        pathkeys: PgPtr<List>,
        fdw_outerpath: PgPtr<Path>,
        fdw_private: PgPtr<List>,
    ) -> PgPtr<ForeignPath>;
}
#[pg_guard]
extern "C" {
    pub fn calc_nestloop_required_outer(
        outerrelids: PgPtr<Bitmapset>,
        outer_paramrels: PgPtr<Bitmapset>,
        innerrelids: PgPtr<Bitmapset>,
        inner_paramrels: PgPtr<Bitmapset>,
    ) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn calc_non_nestloop_required_outer(
        outer_path: PgPtr<Path>,
        inner_path: PgPtr<Path>,
    ) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn create_nestloop_path(
        root: PgPtr<PlannerInfo>,
        joinrel: PgPtr<RelOptInfo>,
        jointype: JoinType,
        workspace: PgPtr<JoinCostWorkspace>,
        extra: PgPtr<JoinPathExtraData>,
        outer_path: PgPtr<Path>,
        inner_path: PgPtr<Path>,
        restrict_clauses: PgPtr<List>,
        pathkeys: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<NestPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_mergejoin_path(
        root: PgPtr<PlannerInfo>,
        joinrel: PgPtr<RelOptInfo>,
        jointype: JoinType,
        workspace: PgPtr<JoinCostWorkspace>,
        extra: PgPtr<JoinPathExtraData>,
        outer_path: PgPtr<Path>,
        inner_path: PgPtr<Path>,
        restrict_clauses: PgPtr<List>,
        pathkeys: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
        mergeclauses: PgPtr<List>,
        outersortkeys: PgPtr<List>,
        innersortkeys: PgPtr<List>,
    ) -> PgPtr<MergePath>;
}
#[pg_guard]
extern "C" {
    pub fn create_hashjoin_path(
        root: PgPtr<PlannerInfo>,
        joinrel: PgPtr<RelOptInfo>,
        jointype: JoinType,
        workspace: PgPtr<JoinCostWorkspace>,
        extra: PgPtr<JoinPathExtraData>,
        outer_path: PgPtr<Path>,
        inner_path: PgPtr<Path>,
        parallel_hash: bool,
        restrict_clauses: PgPtr<List>,
        required_outer: PgPtr<Bitmapset>,
        hashclauses: PgPtr<List>,
    ) -> PgPtr<HashPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_projection_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        target: PgPtr<PathTarget>,
    ) -> PgPtr<ProjectionPath>;
}
#[pg_guard]
extern "C" {
    pub fn apply_projection_to_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        path: PgPtr<Path>,
        target: PgPtr<PathTarget>,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn create_set_projection_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        target: PgPtr<PathTarget>,
    ) -> PgPtr<ProjectSetPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_sort_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        pathkeys: PgPtr<List>,
        limit_tuples: f64,
    ) -> PgPtr<SortPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_group_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        groupClause: PgPtr<List>,
        qual: PgPtr<List>,
        numGroups: f64,
    ) -> PgPtr<GroupPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_upper_unique_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        numCols: ::std::os::raw::c_int,
        numGroups: f64,
    ) -> PgPtr<UpperUniquePath>;
}
#[pg_guard]
extern "C" {
    pub fn create_agg_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        target: PgPtr<PathTarget>,
        aggstrategy: AggStrategy,
        aggsplit: AggSplit,
        groupClause: PgPtr<List>,
        qual: PgPtr<List>,
        aggcosts: PgPtr<AggClauseCosts>,
        numGroups: f64,
    ) -> PgPtr<AggPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_groupingsets_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        having_qual: PgPtr<List>,
        aggstrategy: AggStrategy,
        rollups: PgPtr<List>,
        agg_costs: PgPtr<AggClauseCosts>,
        numGroups: f64,
    ) -> PgPtr<GroupingSetsPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_minmaxagg_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        target: PgPtr<PathTarget>,
        mmaggregates: PgPtr<List>,
        quals: PgPtr<List>,
    ) -> PgPtr<MinMaxAggPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_windowagg_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        target: PgPtr<PathTarget>,
        windowFuncs: PgPtr<List>,
        winclause: PgPtr<WindowClause>,
    ) -> PgPtr<WindowAggPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_setop_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        cmd: SetOpCmd,
        strategy: SetOpStrategy,
        distinctList: PgPtr<List>,
        flagColIdx: AttrNumber,
        firstFlag: ::std::os::raw::c_int,
        numGroups: f64,
        outputRows: f64,
    ) -> PgPtr<SetOpPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_recursiveunion_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        leftpath: PgPtr<Path>,
        rightpath: PgPtr<Path>,
        target: PgPtr<PathTarget>,
        distinctList: PgPtr<List>,
        wtParam: ::std::os::raw::c_int,
        numGroups: f64,
    ) -> PgPtr<RecursiveUnionPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_lockrows_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        rowMarks: PgPtr<List>,
        epqParam: ::std::os::raw::c_int,
    ) -> PgPtr<LockRowsPath>;
}
#[pg_guard]
extern "C" {
    pub fn create_modifytable_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        operation: CmdType,
        canSetTag: bool,
        nominalRelation: Index,
        rootRelation: Index,
        partColsUpdated: bool,
        resultRelations: PgPtr<List>,
        subpaths: PgPtr<List>,
        subroots: PgPtr<List>,
        withCheckOptionLists: PgPtr<List>,
        returningLists: PgPtr<List>,
        rowMarks: PgPtr<List>,
        onconflict: PgPtr<OnConflictExpr>,
        epqParam: ::std::os::raw::c_int,
    ) -> PgPtr<ModifyTablePath>;
}
#[pg_guard]
extern "C" {
    pub fn create_limit_path(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
        subpath: PgPtr<Path>,
        limitOffset: PgPtr<Node>,
        limitCount: PgPtr<Node>,
        offset_est: int64,
        count_est: int64,
    ) -> PgPtr<LimitPath>;
}
#[pg_guard]
extern "C" {
    pub fn adjust_limit_rows_costs(
        rows: PgPtr<f64>,
        startup_cost: PgPtr<Cost>,
        total_cost: PgPtr<Cost>,
        offset_est: int64,
        count_est: int64,
    );
}
#[pg_guard]
extern "C" {
    pub fn reparameterize_path(
        root: PgPtr<PlannerInfo>,
        path: PgPtr<Path>,
        required_outer: PgPtr<Bitmapset>,
        loop_count: f64,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn reparameterize_path_by_child(
        root: PgPtr<PlannerInfo>,
        path: PgPtr<Path>,
        child_rel: PgPtr<RelOptInfo>,
    ) -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn setup_simple_rel_arrays(root: PgPtr<PlannerInfo>);
}
#[pg_guard]
extern "C" {
    pub fn setup_append_rel_array(root: PgPtr<PlannerInfo>);
}
#[pg_guard]
extern "C" {
    pub fn expand_planner_arrays(root: PgPtr<PlannerInfo>, add_size: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn build_simple_rel(
        root: PgPtr<PlannerInfo>,
        relid: ::std::os::raw::c_int,
        parent: PgPtr<RelOptInfo>,
    ) -> PgPtr<RelOptInfo>;
}
#[pg_guard]
extern "C" {
    pub fn find_base_rel(
        root: PgPtr<PlannerInfo>,
        relid: ::std::os::raw::c_int,
    ) -> PgPtr<RelOptInfo>;
}
#[pg_guard]
extern "C" {
    pub fn find_join_rel(root: PgPtr<PlannerInfo>, relids: PgPtr<Bitmapset>) -> PgPtr<RelOptInfo>;
}
#[pg_guard]
extern "C" {
    pub fn build_join_rel(
        root: PgPtr<PlannerInfo>,
        joinrelids: PgPtr<Bitmapset>,
        outer_rel: PgPtr<RelOptInfo>,
        inner_rel: PgPtr<RelOptInfo>,
        sjinfo: PgPtr<SpecialJoinInfo>,
        restrictlist_ptr: PgPtr<PgPtr<List>>,
    ) -> PgPtr<RelOptInfo>;
}
#[pg_guard]
extern "C" {
    pub fn min_join_parameterization(
        root: PgPtr<PlannerInfo>,
        joinrelids: PgPtr<Bitmapset>,
        outer_rel: PgPtr<RelOptInfo>,
        inner_rel: PgPtr<RelOptInfo>,
    ) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn fetch_upper_rel(
        root: PgPtr<PlannerInfo>,
        kind: UpperRelationKind,
        relids: PgPtr<Bitmapset>,
    ) -> PgPtr<RelOptInfo>;
}
#[pg_guard]
extern "C" {
    pub fn find_childrel_parents(
        root: PgPtr<PlannerInfo>,
        rel: PgPtr<RelOptInfo>,
    ) -> PgPtr<Bitmapset>;
}
#[pg_guard]
extern "C" {
    pub fn get_baserel_parampathinfo(
        root: PgPtr<PlannerInfo>,
        baserel: PgPtr<RelOptInfo>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<ParamPathInfo>;
}
#[pg_guard]
extern "C" {
    pub fn get_joinrel_parampathinfo(
        root: PgPtr<PlannerInfo>,
        joinrel: PgPtr<RelOptInfo>,
        outer_path: PgPtr<Path>,
        inner_path: PgPtr<Path>,
        sjinfo: PgPtr<SpecialJoinInfo>,
        required_outer: PgPtr<Bitmapset>,
        restrict_clauses: PgPtr<PgPtr<List>>,
    ) -> PgPtr<ParamPathInfo>;
}
#[pg_guard]
extern "C" {
    pub fn get_appendrel_parampathinfo(
        appendrel: PgPtr<RelOptInfo>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<ParamPathInfo>;
}
#[pg_guard]
extern "C" {
    pub fn find_param_path_info(
        rel: PgPtr<RelOptInfo>,
        required_outer: PgPtr<Bitmapset>,
    ) -> PgPtr<ParamPathInfo>;
}
#[pg_guard]
extern "C" {
    pub fn build_child_join_rel(
        root: PgPtr<PlannerInfo>,
        outer_rel: PgPtr<RelOptInfo>,
        inner_rel: PgPtr<RelOptInfo>,
        parent_joinrel: PgPtr<RelOptInfo>,
        restrictlist: PgPtr<List>,
        sjinfo: PgPtr<SpecialJoinInfo>,
        jointype: JoinType,
    ) -> PgPtr<RelOptInfo>;
}
pub type planner_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        parse: PgPtr<Query>,
        cursorOptions: ::std::os::raw::c_int,
        boundParams: PgPtr<ParamListInfoData>,
    ) -> PgPtr<PlannedStmt>,
>;
#[pg_guard]
extern "C" {
    pub static mut planner_hook: planner_hook_type;
}
pub type create_upper_paths_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        stage: UpperRelationKind,
        input_rel: PgPtr<RelOptInfo>,
        output_rel: PgPtr<RelOptInfo>,
        extra: PgPtr<::std::os::raw::c_void>,
    ),
>;
#[pg_guard]
extern "C" {
    pub static mut create_upper_paths_hook: create_upper_paths_hook_type;
}
#[pg_guard]
extern "C" {
    pub fn standard_planner(
        parse: PgPtr<Query>,
        cursorOptions: ::std::os::raw::c_int,
        boundParams: PgPtr<ParamListInfoData>,
    ) -> PgPtr<PlannedStmt>;
}
#[pg_guard]
extern "C" {
    pub fn subquery_planner(
        glob: PgPtr<PlannerGlobal>,
        parse: PgPtr<Query>,
        parent_root: PgPtr<PlannerInfo>,
        hasRecursion: bool,
        tuple_fraction: f64,
    ) -> PgPtr<PlannerInfo>;
}
#[pg_guard]
extern "C" {
    pub fn select_rowmark_type(
        rte: PgPtr<RangeTblEntry>,
        strength: LockClauseStrength,
    ) -> RowMarkType;
}
#[pg_guard]
extern "C" {
    pub fn limit_needed(parse: PgPtr<Query>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn mark_partial_aggref(agg: PgPtr<Aggref>, aggsplit: AggSplit);
}
#[pg_guard]
extern "C" {
    pub fn get_cheapest_fractional_path(rel: PgPtr<RelOptInfo>, tuple_fraction: f64)
        -> PgPtr<Path>;
}
#[pg_guard]
extern "C" {
    pub fn preprocess_phv_expression(root: PgPtr<PlannerInfo>, expr: PgPtr<Expr>) -> PgPtr<Expr>;
}
#[pg_guard]
extern "C" {
    pub fn make_restrictinfo(
        clause: PgPtr<Expr>,
        is_pushed_down: bool,
        outerjoin_delayed: bool,
        pseudoconstant: bool,
        security_level: Index,
        required_relids: PgPtr<Bitmapset>,
        outer_relids: PgPtr<Bitmapset>,
        nullable_relids: PgPtr<Bitmapset>,
    ) -> PgPtr<RestrictInfo>;
}
#[pg_guard]
extern "C" {
    pub fn commute_restrictinfo(rinfo: PgPtr<RestrictInfo>, comm_op: Oid) -> PgPtr<RestrictInfo>;
}
#[pg_guard]
extern "C" {
    pub fn restriction_is_or_clause(restrictinfo: PgPtr<RestrictInfo>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn restriction_is_securely_promotable(
        restrictinfo: PgPtr<RestrictInfo>,
        rel: PgPtr<RelOptInfo>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_actual_clauses(restrictinfo_list: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn extract_actual_clauses(
        restrictinfo_list: PgPtr<List>,
        pseudoconstant: bool,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn extract_actual_join_clauses(
        restrictinfo_list: PgPtr<List>,
        joinrelids: PgPtr<Bitmapset>,
        joinquals: PgPtr<PgPtr<List>>,
        otherquals: PgPtr<PgPtr<List>>,
    );
}
#[pg_guard]
extern "C" {
    pub fn join_clause_is_movable_to(
        rinfo: PgPtr<RestrictInfo>,
        baserel: PgPtr<RelOptInfo>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn join_clause_is_movable_into(
        rinfo: PgPtr<RestrictInfo>,
        currentrelids: PgPtr<Bitmapset>,
        current_and_outer: PgPtr<Bitmapset>,
    ) -> bool;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum FuncDetailCode {
    FUNCDETAIL_NOTFOUND = 0,
    FUNCDETAIL_MULTIPLE = 1,
    FUNCDETAIL_NORMAL = 2,
    FUNCDETAIL_PROCEDURE = 3,
    FUNCDETAIL_AGGREGATE = 4,
    FUNCDETAIL_WINDOWFUNC = 5,
    FUNCDETAIL_COERCION = 6,
}
#[pg_guard]
extern "C" {
    pub fn ParseFuncOrColumn(
        pstate: PgPtr<ParseState>,
        funcname: PgPtr<List>,
        fargs: PgPtr<List>,
        last_srf: PgPtr<Node>,
        fn_: PgPtr<FuncCall>,
        proc_call: bool,
        location: ::std::os::raw::c_int,
    ) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn func_get_detail(
        funcname: PgPtr<List>,
        fargs: PgPtr<List>,
        fargnames: PgPtr<List>,
        nargs: ::std::os::raw::c_int,
        argtypes: PgPtr<Oid>,
        expand_variadic: bool,
        expand_defaults: bool,
        funcid: PgPtr<Oid>,
        rettype: PgPtr<Oid>,
        retset: PgPtr<bool>,
        nvargs: PgPtr<::std::os::raw::c_int>,
        vatype: PgPtr<Oid>,
        true_typeids: PgPtr<PgPtr<Oid>>,
        argdefaults: PgPtr<PgPtr<List>>,
    ) -> FuncDetailCode;
}
#[pg_guard]
extern "C" {
    pub fn func_match_argtypes(
        nargs: ::std::os::raw::c_int,
        input_typeids: PgPtr<Oid>,
        raw_candidates: PgPtr<_FuncCandidateList>,
        candidates: PgPtr<PgPtr<_FuncCandidateList>>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn func_select_candidate(
        nargs: ::std::os::raw::c_int,
        input_typeids: PgPtr<Oid>,
        candidates: PgPtr<_FuncCandidateList>,
    ) -> PgPtr<_FuncCandidateList>;
}
#[pg_guard]
extern "C" {
    pub fn make_fn_arguments(
        pstate: PgPtr<ParseState>,
        fargs: PgPtr<List>,
        actual_arg_types: PgPtr<Oid>,
        declared_arg_types: PgPtr<Oid>,
    );
}
#[pg_guard]
extern "C" {
    pub fn funcname_signature_string(
        funcname: PgPtr<::std::os::raw::c_char>,
        nargs: ::std::os::raw::c_int,
        argnames: PgPtr<List>,
        argtypes: PgPtr<Oid>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn func_signature_string(
        funcname: PgPtr<List>,
        nargs: ::std::os::raw::c_int,
        argnames: PgPtr<List>,
        argtypes: PgPtr<Oid>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn LookupFuncName(
        funcname: PgPtr<List>,
        nargs: ::std::os::raw::c_int,
        argtypes: PgPtr<Oid>,
        missing_ok: bool,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn LookupFuncWithArgs(
        objtype: ObjectType,
        func: PgPtr<ObjectWithArgs>,
        missing_ok: bool,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn check_srf_call_placement(
        pstate: PgPtr<ParseState>,
        last_srf: PgPtr<Node>,
        location: ::std::os::raw::c_int,
    );
}
pub type Type = PgPtr<HeapTupleData>;
#[pg_guard]
extern "C" {
    pub fn LookupTypeName(
        pstate: PgPtr<ParseState>,
        typeName: PgPtr<TypeName>,
        typmod_p: PgPtr<int32>,
        missing_ok: bool,
    ) -> Type;
}
#[pg_guard]
extern "C" {
    pub fn LookupTypeNameExtended(
        pstate: PgPtr<ParseState>,
        typeName: PgPtr<TypeName>,
        typmod_p: PgPtr<int32>,
        temp_ok: bool,
        missing_ok: bool,
    ) -> Type;
}
#[pg_guard]
extern "C" {
    pub fn LookupTypeNameOid(
        pstate: PgPtr<ParseState>,
        typeName: PgPtr<TypeName>,
        missing_ok: bool,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn typenameType(
        pstate: PgPtr<ParseState>,
        typeName: PgPtr<TypeName>,
        typmod_p: PgPtr<int32>,
    ) -> Type;
}
#[pg_guard]
extern "C" {
    pub fn typenameTypeId(pstate: PgPtr<ParseState>, typeName: PgPtr<TypeName>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn typenameTypeIdAndMod(
        pstate: PgPtr<ParseState>,
        typeName: PgPtr<TypeName>,
        typeid_p: PgPtr<Oid>,
        typmod_p: PgPtr<int32>,
    );
}
#[pg_guard]
extern "C" {
    pub fn TypeNameToString(typeName: PgPtr<TypeName>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn TypeNameListToString(typenames: PgPtr<List>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn LookupCollation(
        pstate: PgPtr<ParseState>,
        collnames: PgPtr<List>,
        location: ::std::os::raw::c_int,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn GetColumnDefCollation(
        pstate: PgPtr<ParseState>,
        coldef: PgPtr<ColumnDef>,
        typeOid: Oid,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn typeidType(id: Oid) -> Type;
}
#[pg_guard]
extern "C" {
    pub fn typeTypeId(tp: Type) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn typeLen(t: Type) -> int16;
}
#[pg_guard]
extern "C" {
    pub fn typeByVal(t: Type) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn typeTypeName(t: Type) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn typeTypeRelid(typ: Type) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn typeTypeCollation(typ: Type) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn stringTypeDatum(
        tp: Type,
        string: PgPtr<::std::os::raw::c_char>,
        atttypmod: int32,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn typeidTypeRelid(type_id: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn typeOrDomainTypeRelid(type_id: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn typeStringToTypeName(str_: PgPtr<::std::os::raw::c_char>) -> PgPtr<TypeName>;
}
#[pg_guard]
extern "C" {
    pub fn parseTypeString(
        str_: PgPtr<::std::os::raw::c_char>,
        typeid_p: PgPtr<Oid>,
        typmod_p: PgPtr<int32>,
        missing_ok: bool,
    );
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum BackslashQuoteType {
    BACKSLASH_QUOTE_OFF = 0,
    BACKSLASH_QUOTE_ON = 1,
    BACKSLASH_QUOTE_SAFE_ENCODING = 2,
}
#[pg_guard]
extern "C" {
    pub static mut backslash_quote: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut escape_string_warning: bool;
}
#[pg_guard]
extern "C" {
    pub static mut standard_conforming_strings: bool;
}
#[pg_guard]
extern "C" {
    pub fn raw_parser(str_: PgPtr<::std::os::raw::c_char>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn SystemFuncName(name: PgPtr<::std::os::raw::c_char>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn SystemTypeName(name: PgPtr<::std::os::raw::c_char>) -> PgPtr<TypeName>;
}
#[pg_guard]
extern "C" {
    pub fn QueryRewrite(parsetree: PgPtr<Query>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn AcquireRewriteLocks(
        parsetree: PgPtr<Query>,
        forExecute: bool,
        forUpdatePushedDown: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn build_column_default(
        rel: PgPtr<RelationData>,
        attrno: ::std::os::raw::c_int,
    ) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn rewriteTargetListUD(
        parsetree: PgPtr<Query>,
        target_rte: PgPtr<RangeTblEntry>,
        target_relation: PgPtr<RelationData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_view_query(view: PgPtr<RelationData>) -> PgPtr<Query>;
}
#[pg_guard]
extern "C" {
    pub fn view_query_is_auto_updatable(
        viewquery: PgPtr<Query>,
        check_cols: bool,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn relation_is_updatable(
        reloid: Oid,
        outer_reloids: PgPtr<List>,
        include_triggers: bool,
        include_cols: PgPtr<Bitmapset>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn standby_redo(record: PgPtr<XLogReaderState>);
}
#[pg_guard]
extern "C" {
    pub fn standby_desc(buf: PgPtr<StringInfoData>, record: PgPtr<XLogReaderState>);
}
#[pg_guard]
extern "C" {
    pub fn standby_identify(info: uint8) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn standby_desc_invalidations(
        buf: PgPtr<StringInfoData>,
        nmsgs: ::std::os::raw::c_int,
        msgs: PgPtr<SharedInvalidationMessage>,
        dbId: Oid,
        tsId: Oid,
        relcacheInitFileInval: bool,
    );
}
#[repr(C)]
pub struct xl_standby_locks {
    pub nlocks: ::std::os::raw::c_int,
    pub locks: __IncompleteArrayField<xl_standby_lock>,
}
#[repr(C)]
pub struct xl_running_xacts {
    pub xcnt: ::std::os::raw::c_int,
    pub subxcnt: ::std::os::raw::c_int,
    pub subxid_overflow: bool,
    pub nextXid: TransactionId,
    pub oldestRunningXid: TransactionId,
    pub latestCompletedXid: TransactionId,
    pub xids: __IncompleteArrayField<TransactionId>,
}
#[repr(C)]
pub struct xl_invalidations {
    pub dbId: Oid,
    pub tsId: Oid,
    pub relcacheInitFileInval: bool,
    pub nmsgs: ::std::os::raw::c_int,
    pub msgs: __IncompleteArrayField<SharedInvalidationMessage>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ProcSignalReason {
    PROCSIG_CATCHUP_INTERRUPT = 0,
    PROCSIG_NOTIFY_INTERRUPT = 1,
    PROCSIG_PARALLEL_MESSAGE = 2,
    PROCSIG_WALSND_INIT_STOPPING = 3,
    PROCSIG_RECOVERY_CONFLICT_DATABASE = 4,
    PROCSIG_RECOVERY_CONFLICT_TABLESPACE = 5,
    PROCSIG_RECOVERY_CONFLICT_LOCK = 6,
    PROCSIG_RECOVERY_CONFLICT_SNAPSHOT = 7,
    PROCSIG_RECOVERY_CONFLICT_BUFFERPIN = 8,
    PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK = 9,
    NUM_PROCSIGNALS = 10,
}
#[pg_guard]
extern "C" {
    pub fn ProcSignalShmemSize() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn ProcSignalShmemInit();
}
#[pg_guard]
extern "C" {
    pub fn ProcSignalInit(pss_idx: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn SendProcSignal(
        pid: pid_t,
        reason: ProcSignalReason,
        backendId: BackendId,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn procsignal_sigusr1_handler(postgres_signal_arg: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub static mut vacuum_defer_cleanup_age: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut max_standby_archive_delay: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut max_standby_streaming_delay: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn InitRecoveryTransactionEnvironment();
}
#[pg_guard]
extern "C" {
    pub fn ShutdownRecoveryTransactionEnvironment();
}
#[pg_guard]
extern "C" {
    pub fn ResolveRecoveryConflictWithSnapshot(latestRemovedXid: TransactionId, node: RelFileNode);
}
#[pg_guard]
extern "C" {
    pub fn ResolveRecoveryConflictWithTablespace(tsid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn ResolveRecoveryConflictWithDatabase(dbid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn ResolveRecoveryConflictWithLock(locktag: LOCKTAG);
}
#[pg_guard]
extern "C" {
    pub fn ResolveRecoveryConflictWithBufferPin();
}
#[pg_guard]
extern "C" {
    pub fn CheckRecoveryConflictDeadlock();
}
#[pg_guard]
extern "C" {
    pub fn StandbyDeadLockHandler();
}
#[pg_guard]
extern "C" {
    pub fn StandbyTimeoutHandler();
}
#[pg_guard]
extern "C" {
    pub fn StandbyLockTimeoutHandler();
}
#[pg_guard]
extern "C" {
    pub fn StandbyAcquireAccessExclusiveLock(xid: TransactionId, dbOid: Oid, relOid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn StandbyReleaseLockTree(
        xid: TransactionId,
        nsubxids: ::std::os::raw::c_int,
        subxids: PgPtr<TransactionId>,
    );
}
#[pg_guard]
extern "C" {
    pub fn StandbyReleaseAllLocks();
}
#[pg_guard]
extern "C" {
    pub fn StandbyReleaseOldLocks(oldxid: TransactionId);
}
#[repr(C)]
pub struct RunningTransactionsData {
    pub xcnt: ::std::os::raw::c_int,
    pub subxcnt: ::std::os::raw::c_int,
    pub subxid_overflow: bool,
    pub nextXid: TransactionId,
    pub oldestRunningXid: TransactionId,
    pub latestCompletedXid: TransactionId,
    pub xids: PgPtr<TransactionId>,
}
pub type RunningTransactions = PgPtr<RunningTransactionsData>;
#[pg_guard]
extern "C" {
    pub fn LogAccessExclusiveLock(dbOid: Oid, relOid: Oid);
}
#[pg_guard]
extern "C" {
    pub fn LogAccessExclusiveLockPrepare();
}
#[pg_guard]
extern "C" {
    pub fn LogStandbySnapshot() -> XLogRecPtr;
}
#[pg_guard]
extern "C" {
    pub fn LogStandbyInvalidations(
        nmsgs: ::std::os::raw::c_int,
        msgs: PgPtr<SharedInvalidationMessage>,
        relcacheInitFileInval: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn ProcArrayShmemSize() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn CreateSharedProcArray();
}
#[pg_guard]
extern "C" {
    pub fn ProcArrayAdd(proc_: PgPtr<PGPROC>);
}
#[pg_guard]
extern "C" {
    pub fn ProcArrayRemove(proc_: PgPtr<PGPROC>, latestXid: TransactionId);
}
#[pg_guard]
extern "C" {
    pub fn ProcArrayEndTransaction(proc_: PgPtr<PGPROC>, latestXid: TransactionId);
}
#[pg_guard]
extern "C" {
    pub fn ProcArrayClearTransaction(proc_: PgPtr<PGPROC>);
}
#[pg_guard]
extern "C" {
    pub fn ProcArrayInitRecovery(initializedUptoXID: TransactionId);
}
#[pg_guard]
extern "C" {
    pub fn ProcArrayApplyRecoveryInfo(running: PgPtr<RunningTransactionsData>);
}
#[pg_guard]
extern "C" {
    pub fn ProcArrayApplyXidAssignment(
        topxid: TransactionId,
        nsubxids: ::std::os::raw::c_int,
        subxids: PgPtr<TransactionId>,
    );
}
#[pg_guard]
extern "C" {
    pub fn RecordKnownAssignedTransactionIds(xid: TransactionId);
}
#[pg_guard]
extern "C" {
    pub fn ExpireTreeKnownAssignedTransactionIds(
        xid: TransactionId,
        nsubxids: ::std::os::raw::c_int,
        subxids: PgPtr<TransactionId>,
        max_xid: TransactionId,
    );
}
#[pg_guard]
extern "C" {
    pub fn ExpireAllKnownAssignedTransactionIds();
}
#[pg_guard]
extern "C" {
    pub fn ExpireOldKnownAssignedTransactionIds(xid: TransactionId);
}
#[pg_guard]
extern "C" {
    pub fn GetMaxSnapshotXidCount() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn GetMaxSnapshotSubxidCount() -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn GetSnapshotData(snapshot: PgPtr<SnapshotData>) -> PgPtr<SnapshotData>;
}
#[pg_guard]
extern "C" {
    pub fn ProcArrayInstallImportedXmin(
        xmin: TransactionId,
        sourcevxid: PgPtr<VirtualTransactionId>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn ProcArrayInstallRestoredXmin(xmin: TransactionId, proc_: PgPtr<PGPROC>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetRunningTransactionData() -> PgPtr<RunningTransactionsData>;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdIsInProgress(xid: TransactionId) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdIsActive(xid: TransactionId) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetOldestXmin(rel: PgPtr<RelationData>, flags: ::std::os::raw::c_int) -> TransactionId;
}
#[pg_guard]
extern "C" {
    pub fn GetOldestActiveTransactionId() -> TransactionId;
}
#[pg_guard]
extern "C" {
    pub fn GetOldestSafeDecodingTransactionId(catalogOnly: bool) -> TransactionId;
}
#[pg_guard]
extern "C" {
    pub fn GetVirtualXIDsDelayingChkpt(
        nvxids: PgPtr<::std::os::raw::c_int>,
    ) -> PgPtr<VirtualTransactionId>;
}
#[pg_guard]
extern "C" {
    pub fn HaveVirtualXIDsDelayingChkpt(
        vxids: PgPtr<VirtualTransactionId>,
        nvxids: ::std::os::raw::c_int,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn BackendPidGetProc(pid: ::std::os::raw::c_int) -> PgPtr<PGPROC>;
}
#[pg_guard]
extern "C" {
    pub fn BackendPidGetProcWithLock(pid: ::std::os::raw::c_int) -> PgPtr<PGPROC>;
}
#[pg_guard]
extern "C" {
    pub fn BackendXidGetPid(xid: TransactionId) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn IsBackendPid(pid: ::std::os::raw::c_int) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetCurrentVirtualXIDs(
        limitXmin: TransactionId,
        excludeXmin0: bool,
        allDbs: bool,
        excludeVacuum: ::std::os::raw::c_int,
        nvxids: PgPtr<::std::os::raw::c_int>,
    ) -> PgPtr<VirtualTransactionId>;
}
#[pg_guard]
extern "C" {
    pub fn GetConflictingVirtualXIDs(
        limitXmin: TransactionId,
        dbOid: Oid,
    ) -> PgPtr<VirtualTransactionId>;
}
#[pg_guard]
extern "C" {
    pub fn CancelVirtualTransaction(vxid: VirtualTransactionId, sigmode: ProcSignalReason)
        -> pid_t;
}
#[pg_guard]
extern "C" {
    pub fn MinimumActiveBackends(min: ::std::os::raw::c_int) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn CountDBBackends(databaseid: Oid) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn CountDBConnections(databaseid: Oid) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn CancelDBBackends(databaseid: Oid, sigmode: ProcSignalReason, conflictPending: bool);
}
#[pg_guard]
extern "C" {
    pub fn CountUserBackends(roleid: Oid) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn CountOtherDBBackends(
        databaseId: Oid,
        nbackends: PgPtr<::std::os::raw::c_int>,
        nprepared: PgPtr<::std::os::raw::c_int>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn XidCacheRemoveRunningXids(
        xid: TransactionId,
        nxids: ::std::os::raw::c_int,
        xids: PgPtr<TransactionId>,
        latestXid: TransactionId,
    );
}
#[pg_guard]
extern "C" {
    pub fn ProcArraySetReplicationSlotXmin(
        xmin: TransactionId,
        catalog_xmin: TransactionId,
        already_locked: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn ProcArrayGetReplicationSlotXmin(
        xmin: PgPtr<TransactionId>,
        catalog_xmin: PgPtr<TransactionId>,
    );
}
pub type pg_on_exit_callback =
    ::std::option::Option<unsafe extern "C" fn(code: ::std::os::raw::c_int, arg: Datum)>;
pub type shmem_startup_hook_type = ::std::option::Option<unsafe extern "C" fn()>;
#[pg_guard]
extern "C" {
    pub static mut proc_exit_inprogress: bool;
}
#[pg_guard]
extern "C" {
    pub static mut shmem_exit_inprogress: bool;
}
#[pg_guard]
extern "C" {
    pub fn proc_exit(code: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn shmem_exit(code: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn on_proc_exit(function: pg_on_exit_callback, arg: Datum);
}
#[pg_guard]
extern "C" {
    pub fn on_shmem_exit(function: pg_on_exit_callback, arg: Datum);
}
#[pg_guard]
extern "C" {
    pub fn before_shmem_exit(function: pg_on_exit_callback, arg: Datum);
}
#[pg_guard]
extern "C" {
    pub fn cancel_before_shmem_exit(function: pg_on_exit_callback, arg: Datum);
}
#[pg_guard]
extern "C" {
    pub fn on_exit_reset();
}
#[pg_guard]
extern "C" {
    pub static mut shmem_startup_hook: shmem_startup_hook_type;
}
#[pg_guard]
extern "C" {
    pub fn CreateSharedMemoryAndSemaphores(port: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub static mut whereToSendOutput: CommandDest;
}
#[pg_guard]
extern "C" {
    pub static mut debug_query_string: PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut max_stack_depth: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub static mut PostAuthDelay: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum LogStmtLevel {
    LOGSTMT_NONE = 0,
    LOGSTMT_DDL = 1,
    LOGSTMT_MOD = 2,
    LOGSTMT_ALL = 3,
}
#[pg_guard]
extern "C" {
    pub static mut log_statement: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_parse_query(query_string: PgPtr<::std::os::raw::c_char>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn pg_analyze_and_rewrite(
        parsetree: PgPtr<RawStmt>,
        query_string: PgPtr<::std::os::raw::c_char>,
        paramTypes: PgPtr<Oid>,
        numParams: ::std::os::raw::c_int,
        queryEnv: PgPtr<QueryEnvironment>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn pg_analyze_and_rewrite_params(
        parsetree: PgPtr<RawStmt>,
        query_string: PgPtr<::std::os::raw::c_char>,
        parserSetup: ParserSetupHook,
        parserSetupArg: PgPtr<::std::os::raw::c_void>,
        queryEnv: PgPtr<QueryEnvironment>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn pg_plan_query(
        querytree: PgPtr<Query>,
        cursorOptions: ::std::os::raw::c_int,
        boundParams: PgPtr<ParamListInfoData>,
    ) -> PgPtr<PlannedStmt>;
}
#[pg_guard]
extern "C" {
    pub fn pg_plan_queries(
        querytrees: PgPtr<List>,
        cursorOptions: ::std::os::raw::c_int,
        boundParams: PgPtr<ParamListInfoData>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn check_max_stack_depth(
        newval: PgPtr<::std::os::raw::c_int>,
        extra: PgPtr<PgPtr<::std::os::raw::c_void>>,
        source: GucSource,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn assign_max_stack_depth(
        newval: ::std::os::raw::c_int,
        extra: PgPtr<::std::os::raw::c_void>,
    );
}
#[pg_guard]
extern "C" {
    pub fn die(postgres_signal_arg: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn quickdie(postgres_signal_arg: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn StatementCancelHandler(postgres_signal_arg: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn FloatExceptionHandler(postgres_signal_arg: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn RecoveryConflictInterrupt(reason: ProcSignalReason);
}
#[pg_guard]
extern "C" {
    pub fn ProcessClientReadInterrupt(blocked: bool);
}
#[pg_guard]
extern "C" {
    pub fn ProcessClientWriteInterrupt(blocked: bool);
}
#[pg_guard]
extern "C" {
    pub fn process_postgres_switches(
        argc: ::std::os::raw::c_int,
        argv: PgPtr<PgPtr<::std::os::raw::c_char>>,
        ctx: GucContext,
        dbname: PgPtr<PgPtr<::std::os::raw::c_char>>,
    );
}
#[pg_guard]
extern "C" {
    pub fn PostgresMain(
        argc: ::std::os::raw::c_int,
        argv: PgPtr<PgPtr<::std::os::raw::c_char>>,
        dbname: PgPtr<::std::os::raw::c_char>,
        username: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_stack_depth_rlimit() -> ::std::os::raw::c_long;
}
#[pg_guard]
extern "C" {
    pub fn ResetUsage();
}
#[pg_guard]
extern "C" {
    pub fn ShowUsage(title: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn check_log_duration(
        msec_str: PgPtr<::std::os::raw::c_char>,
        was_logged: bool,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn set_debug_options(
        debug_flag: ::std::os::raw::c_int,
        context: GucContext,
        source: GucSource,
    );
}
#[pg_guard]
extern "C" {
    pub fn set_plan_disabling_options(
        arg: PgPtr<::std::os::raw::c_char>,
        context: GucContext,
        source: GucSource,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_stats_option_name(
        arg: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum ProcessUtilityContext {
    PROCESS_UTILITY_TOPLEVEL = 0,
    PROCESS_UTILITY_QUERY = 1,
    PROCESS_UTILITY_QUERY_NONATOMIC = 2,
    PROCESS_UTILITY_SUBCOMMAND = 3,
}
pub type ProcessUtility_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        pstmt: PgPtr<PlannedStmt>,
        queryString: PgPtr<::std::os::raw::c_char>,
        context: ProcessUtilityContext,
        params: PgPtr<ParamListInfoData>,
        queryEnv: PgPtr<QueryEnvironment>,
        dest: PgPtr<DestReceiver>,
        completionTag: PgPtr<::std::os::raw::c_char>,
    ),
>;
#[pg_guard]
extern "C" {
    pub static mut ProcessUtility_hook: ProcessUtility_hook_type;
}
#[pg_guard]
extern "C" {
    pub fn ProcessUtility(
        pstmt: PgPtr<PlannedStmt>,
        queryString: PgPtr<::std::os::raw::c_char>,
        context: ProcessUtilityContext,
        params: PgPtr<ParamListInfoData>,
        queryEnv: PgPtr<QueryEnvironment>,
        dest: PgPtr<DestReceiver>,
        completionTag: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn standard_ProcessUtility(
        pstmt: PgPtr<PlannedStmt>,
        queryString: PgPtr<::std::os::raw::c_char>,
        context: ProcessUtilityContext,
        params: PgPtr<ParamListInfoData>,
        queryEnv: PgPtr<QueryEnvironment>,
        dest: PgPtr<DestReceiver>,
        completionTag: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn UtilityReturnsTuples(parsetree: PgPtr<Node>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn UtilityTupleDescriptor(parsetree: PgPtr<Node>) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn UtilityContainsQuery(parsetree: PgPtr<Node>) -> PgPtr<Query>;
}
#[pg_guard]
extern "C" {
    pub fn CreateCommandTag(parsetree: PgPtr<Node>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn GetCommandLogLevel(parsetree: PgPtr<Node>) -> LogStmtLevel;
}
#[pg_guard]
extern "C" {
    pub fn CommandIsReadOnly(pstmt: PgPtr<PlannedStmt>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn heap_tableam_handler(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteaout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn charout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namein(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nameout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2vectorin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2vectorout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regprocin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regprocout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tidin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tidout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xidin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xidout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cidin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cidout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidvectorin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidvectorout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn boollt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn boolgt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn booleq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn chareq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nameeq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn texteq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xideq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cideq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn charne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn charle(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn chargt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn charge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn chartoi4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn i4tochar(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nameregexeq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn boolne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ddl_command_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ddl_command_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ddl_command_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pgsql_version(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ddl_command_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn eqsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn neqsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn scalarltsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn scalargtsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn eqjoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn neqjoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn scalarltjoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn scalargtjoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn unknownin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn unknownout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_fac(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_above_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_below_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_overlap(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_above(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_left(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_right(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_below(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn on_pb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn on_ppath(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_center(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn areasel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn areajoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2mod(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4mod(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int24eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int42eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int24lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int42lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int24gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int42gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int24ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int42ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int24le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int42le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int24ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int42ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int24mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int42mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int24div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int42div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int24pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int42pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int24mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int42mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oideq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_same(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_contain(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_left(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_overleft(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_overright(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_right(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_contained(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_contain_pt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_node_tree_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_node_tree_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_node_tree_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_node_tree_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4um(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4abs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4um(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2um(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8um(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8abs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_center(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_center(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_center(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dround(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dtrunc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dsqrt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dcbrt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dpow(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dexp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dlog1(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn i2tod(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn i2tof(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dtoi2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ftoi2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_distance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nameeqtext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namelttext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nameletext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namegetext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namegttext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namenetext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btnametextcmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn texteqname(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textltname(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textlename(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textgename(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textgtname(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textnename(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bttextnamecmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nameconcatoid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn table_am_handler_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn table_am_handler_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timeofday(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_nextoid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_combine(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inter_sl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inter_lb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float48mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float48div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float48pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float48mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float84mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float84div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float84pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float84mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float48eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float48ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float48lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float48le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float48gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float48ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float84eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float84ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float84lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float84le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float84gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float84ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ftod(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dtof(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn i2toi4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn i4toi2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_jit_available(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn i4tod(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dtoi4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn i4tof(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ftoi4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn width_bucket_float8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn index_am_handler_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn index_am_handler_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashmacaddr8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hash_aclitem(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bthandler(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashhandler(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gisthandler(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ginhandler(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spghandler(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn brinhandler(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn scalarlesel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn scalargesel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn amvalidate(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_same(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_contain(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_left(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_overleft(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_overright(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_right(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_contained(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_overlap(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btint2cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btint4cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btfloat4cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btfloat8cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btoidcmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btcharcmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btnamecmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bttextcmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_distance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_interpt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dist_ps(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dist_pb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dist_sb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn close_ps(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn close_pb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn close_sb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn on_ps(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_distance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dist_ppath(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn on_sb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inter_sb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_to_array_null(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_append(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_prepend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btarraycmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_cat(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_to_text_null(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn scalarlejoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_to_array(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_to_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn scalargejoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashmacaddr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashtext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn rtrim1(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btoidvectorcmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn name_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn name_bpchar(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchar_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashinet(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashint4extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hash_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_num_nulls(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_num_nonnulls(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashint2extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashint8extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashfloat4extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashfloat8extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashoidextended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashcharextended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashnameextended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashtextextended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashint2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashint4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashfloat4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashfloat8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashoid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashchar(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashname(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashvarlena(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashoidvector(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8um(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int84eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int84ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int84lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int84gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int84le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int84ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int84(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int48(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn i8tod(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dtoi8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_abbrev(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cidr_abbrev(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_set_masklen(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidvectorne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hash_array(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cidr_set_masklen(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_indexam_has_property(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_index_has_property(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_index_column_has_property(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn i8tof(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ftoi8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namelt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namele(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namegt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namege(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namene(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchar(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varchar(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_indexam_progress_phasename(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidvectorlt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidvectorle(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidvectoreq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidvectorge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidvectorgt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_network(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_netmask(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_masklen(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_broadcast(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_host(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn current_user(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_family(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int82(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_create(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidlt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidle(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteaoctetlen(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteaGetByte(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteaSetByte(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteaGetBit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteaSetBit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dist_pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dist_lb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dist_sl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dist_cpoly(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_distance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_show(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn session_user(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_dims(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_ndims(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteaoverlay(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteaoverlay_no_len(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_trunc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int28(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_import(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_export(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4inc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_import_with_oid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashvarlenaextended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashoidvectorextended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hash_aclitem_extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashmacaddrextended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashinetextended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hash_numeric_extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashmacaddr8extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hash_array_extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_client_encoding(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn current_query(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int82pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int82mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int82mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int82div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int28pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btint8cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_mul_flt4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_div_flt4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn flt4_mul_cash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textpos(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textlike(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textnlike(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int48eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int48ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int48lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int48gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int48le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int48ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namelike(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namenlike(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn char_bpchar(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn current_database(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4_mul_cash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2_mul_cash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_mul_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_div_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_mul_int2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_div_int2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lower(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn upper(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn initcap(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lpad(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn rpad(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ltrim(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn rtrim(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_substr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn translate(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ltrim1(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_substr_no_len(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btrim(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btrim1(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_mul_flt8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_div_flt8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cashlarger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cashsmaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn flt8_mul_cash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_sub(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_subeq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_sup(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_supeq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_words(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn generate_series_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn generate_series_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int28mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int28mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_char(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8mod(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn char_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int28div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashint8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_open(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_close(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_loread(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lowrite(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_lseek(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_creat(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_tell(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn on_pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn on_sl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn close_pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn close_sl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn close_lb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_unlink(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashbpcharextended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_inter(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_area(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_width(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_height(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_distance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_area(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_intersect(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_diagonal(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_n_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_n_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_n_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_n_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_n_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_length(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_vert(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_horiz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_distance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_slope(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_construct(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_intersect(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_parallel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_perp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_vertical(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_horizontal(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_truncate(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textlike_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn texticregexeq_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn texticlike_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_izone(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_point_compress(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn aclitemin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn aclitemout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn aclinsert(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn aclremove(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn aclcontains(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn getdatabaseencoding(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpcharin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpcharout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varcharin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varcharout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchareq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpcharlt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpcharle(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchargt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpcharge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpcharne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn aclitem_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchar_larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchar_smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_prepared_xact(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn generate_series_step_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn generate_series_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn generate_series_step_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn generate_series_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpcharcmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_regclass(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashbpchar(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn format_type(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_pli(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_mii(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_add_pt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_sub_pt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_mul_pt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_div_pt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_zone(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_um(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_part(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_part(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_subset_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_justify_hours(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xid_age(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_pl_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_mi_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn generate_subscripts(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn generate_subscripts_nodir(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_fill(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dlog10(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_age(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_scale(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_trunc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_trunc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8inc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8abs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn texticregexeq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn texticregexne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nameicregexeq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nameicregexne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn boolin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn boolout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteain(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn charin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn charlt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn unique_key_recheck(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4abs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nameregexne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2abs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textregexeq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textregexne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textlen(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textcat(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn PG_char_to_encoding(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tidne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cidr_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn parse_ident(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_column_size(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn overlaps_timetz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn datetime_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_part(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int84pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int84mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int84mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int84div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int48pl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int48mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int48mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int48div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn quote_ident(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn quote_literal(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_trunc_zone(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_fill_with_lower_bounds(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn i8tooid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidtoi8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn quote_nullable(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn suppress_redundant_updates_trigger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tideq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn currtid_byreloid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn currtid_byrelname(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_justify_days(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn datetimetz_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn now(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn positionsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn positionjoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn contsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn contjoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn overlaps_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn overlaps_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpcharlen(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidvectortypes(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_hostmask(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textregexeq_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn makeaclitem(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lock_status(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_finite(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textoctetlen(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpcharoctetlen(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_part(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_constraintdef(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_timetz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_finite(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_finite(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_backend_start(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_backend_client_addr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_backend_client_port(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn current_schema(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn current_schemas(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textoverlay(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textoverlay_no_len(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_parallel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_perp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_vertical(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_horizontal(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_center(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn points_box(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_add(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_sub(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cidr_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_contain_pt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pt_contained_poly(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_isclosed(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_isopen(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_npoints(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_close(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_open(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_add(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_add_pt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_sub_pt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_mul_pt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_div_pt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn construct_point(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_add(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_sub(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_npoints(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_box(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_path(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_poly(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_poly(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_same(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_contain(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_left(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_overleft(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_overright(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_right(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_contained(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_overlap(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_below(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_above(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_area(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_diameter(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_radius(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_distance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cr_circle(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_circle(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_poly(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dist_pc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_contain_pt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pt_contained_circle(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_circle(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_box(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_length(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn close_ls(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn close_lseg(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_construct_pp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_interpt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_intersect(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bit_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bit_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_ruledef(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nextval_oid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn currval_oid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn setval_oid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varbit_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varbit_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn biteq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitgt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitle(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitlt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitcmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn PG_encoding_to_char(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn drandom(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn setseed(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dasin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dacos(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn datan(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn datan2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dsin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dcos(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dtan(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dcot(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn degrees(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn radians(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dpi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_typeof(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ascii(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn chr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn repeat(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn similar_escape(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn mul_d_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn texticlike(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn texticnlike(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nameiclike(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nameicnlike(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn like_escape(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidgt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_viewdef_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_viewdef(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_userbyid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_indexdef(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_check_ins(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_check_upd(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_cascade_del(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_cascade_upd(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_restrict_del(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_restrict_upd(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_setnull_del(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_setnull_upd(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_setdefault_del(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_setdefault_upd(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_noaction_del(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn RI_FKey_noaction_upd(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_triggerdef(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_serial_sequence(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bit_and(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bit_or(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitxor(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitnot(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitshiftleft(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitshiftright(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitcat(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitsubstr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitlength(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitoctetlength(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitfromint4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bittoint4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_keywords(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varbit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_hash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn aclexplode(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_mi_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn boolle(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn boolge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btboolcmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_hash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_hash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitposition(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitsubstr_no_len(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_abs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_sign(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_round(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_trunc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_ceil(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_floor(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn length_in_encoding(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_convert_from(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_to_cidr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_expr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_convert_to(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_add(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_sub(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_mul(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_div(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_mod(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_sqrt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_exp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_ln(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_log(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_power(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_float4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_float8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_pl_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_mi_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_pl_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_mi_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_inc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn setval3_oid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_to_char(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_to_char(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_uminus(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_to_char(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4_to_char(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_to_char(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4_to_char(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_to_char(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_to_number(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_int2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_convert(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn iclikesel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn icnlikesel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn iclikejoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn icnlikejoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regexeqsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn likesel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn icregexeqsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regexnesel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nlikesel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn icregexnesel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regexeqjoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn likejoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn icregexeqjoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regexnejoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn nlikejoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn icregexnejoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_avg(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_var_samp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_stddev_samp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_avg(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_var_samp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_stddev_samp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2_sum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4_sum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_sum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_avg(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_ascii_default(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_ascii_enc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_ascii_encname(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int28eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int28ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int28lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int28gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int28le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int28ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int82eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int82ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int82lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int82gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int82le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int82ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2and(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2or(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2xor(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2not(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2shl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2shr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4and(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4or(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4xor(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4not(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4shl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4shr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8and(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8or(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8xor(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8not(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8shl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8shr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8up(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2up(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4up(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4up(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8up(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_uplus(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_table_privilege_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_table_privilege_name_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_table_privilege_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_table_privilege_id_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_table_privilege_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_table_privilege_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_numscans(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_tuples_returned(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_tuples_fetched(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_tuples_inserted(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_tuples_updated(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_tuples_deleted(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_blocks_fetched(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_blocks_hit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_backend_idset(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_backend_pid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_backend_dbid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_backend_userid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_backend_activity(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_numbackends(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_xact_commit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_xact_rollback(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_blocks_fetched(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_blocks_hit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_encode(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_decode(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteaeq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bytealt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteale(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteagt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteage(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteane(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteacmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_scale(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2_avg_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4_avg_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_avg(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidlarger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidsmaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_scale(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_scale(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_scale(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_tuples_hot_updated(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_div_trunc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bytealike(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteanlike(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn like_escape_bytea(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteacat(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bytea_substr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bytea_substr_no_len(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteapos(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteatrim(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_trunc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_part(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_activity(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_backend_pid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_pl_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_mi_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_conf_load_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_zone(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_izone(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_hash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_timetz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_to_char(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn aggregate_dummy(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_age(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_zone(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_izone(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_pl_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_mi_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textregexsubstr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitfromint8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bittoint8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn show_config_by_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn set_config_by_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_table_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_type_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_function_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_operator_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_opclass_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn show_all_settings(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn replace_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn split_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_hex32(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_hex64(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_lower(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_upper(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_conversion_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_backend_activity_start(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_terminate_backend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_functiondef(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_pattern_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_pattern_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_function_arguments(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_pattern_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_pattern_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_function_result(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bttext_pattern_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_database_size_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn width_bucket_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_cancel_backend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_start_backup(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stop_backup(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchar_pattern_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchar_pattern_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_length(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchar_pattern_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchar_pattern_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_point_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btbpchar_pattern_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_sequence_privilege_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_sequence_privilege_name_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_sequence_privilege_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_sequence_privilege_id_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_sequence_privilege_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_sequence_privilege_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btint48cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btint84cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btint24cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btint42cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btint28cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btint82cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btfloat48cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btfloat84cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_client_addr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_client_port(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_server_addr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_server_port(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regprocedurein(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regprocedureout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regoperin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regoperout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regoperatorin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regoperatorout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regclassin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regclassout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regtypein(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regtypeout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_clear_snapshot(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_function_identity_arguments(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashtid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashtidextended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn fmgr_internal_validator(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn fmgr_c_validator(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn fmgr_sql_validator(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_database_privilege_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_database_privilege_name_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_database_privilege_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_database_privilege_id_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_database_privilege_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_database_privilege_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_function_privilege_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_function_privilege_name_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_function_privilege_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_function_privilege_id_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_function_privilege_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_function_privilege_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_language_privilege_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_language_privilege_name_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_language_privilege_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_language_privilege_id_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_language_privilege_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_language_privilege_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_schema_privilege_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_schema_privilege_name_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_schema_privilege_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_schema_privilege_id_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_schema_privilege_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_schema_privilege_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_reset(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textregexreplace_noopt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textregexreplace(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_total_relation_size(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_size_pretty(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_options_to_table(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cstring_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cstring_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn any_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn any_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn anyarray_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn anyarray_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn void_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn void_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn trigger_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn trigger_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn language_handler_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn language_handler_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn internal_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn internal_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn opaque_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn opaque_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dceil(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dfloor(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dsign(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn md5_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn anyelement_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn anyelement_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn postgresql_fdw_validator(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_encoding_max_length_sql(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn md5_bytea(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_tablespace_size_oid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_tablespace_size_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_database_size_oid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_unnest(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_relation_size(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_agg_transfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_agg_finalfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_lt_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_le_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_eq_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_gt_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_ge_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_ne_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_cmp_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_lt_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_le_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_eq_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_gt_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_ge_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_ne_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_cmp_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_lt_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_le_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_eq_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_gt_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_ge_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_ne_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_cmp_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_lt_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_le_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_eq_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_gt_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_ge_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_ne_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_cmp_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_tablespace_privilege_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_tablespace_privilege_name_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_tablespace_privilege_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_tablespace_privilege_id_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_tablespace_privilege_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_tablespace_privilege_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn shell_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn shell_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2vectorrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2vectorsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bytearecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn byteasend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn textsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn unknownrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn unknownsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidvectorrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn oidvectorsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namerecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn namesend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float4send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpcharrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpcharsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varcharrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varcharsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn charrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn charsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn boolrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn boolsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tidrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tidsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xidrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xidsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cidrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cidsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regprocrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regprocsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regprocedurerecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regproceduresend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regoperrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regopersend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regoperatorrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regoperatorsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regclassrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regclasssend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regtyperecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regtypesend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bit_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bit_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varbit_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varbit_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dsinh(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dcosh(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dtanh(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dasinh(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dacosh(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn datanh(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lseg_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn path_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn line_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cidr_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cidr_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cstring_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cstring_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn anyarray_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn anyarray_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_ruledef_ext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_viewdef_name_ext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_viewdef_ext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_indexdef_ext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_constraintdef_ext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_expr_ext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_prepared_statement(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_cursor(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_var_pop(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_stddev_pop(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_var_pop(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn booland_statefunc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn boolor_statefunc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_lt_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_le_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_eq_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_gt_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_ge_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_ne_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_cmp_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_lt_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_le_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_eq_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_gt_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_ge_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_ne_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptz_cmp_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_tablespace_databases(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4_bool(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bool_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn lastval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_postmaster_start_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_blocking_pids(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_below(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_overbelow(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_overabove(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn box_above(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_below(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_overbelow(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_overabove(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn poly_above(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_box_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_float8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_box_penalty(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_box_picksplit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_box_union(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_box_same(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_poly_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_poly_compress(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_overbelow(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn circle_overabove(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_circle_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_circle_compress(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_stddev_pop(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn domain_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn domain_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_timezone_abbrevs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xmlexists(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_reload_conf(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_rotate_logfile_v2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_file_1arg(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_read_file_off_len(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ls_dir_1arg(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_sleep(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inetnot(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inetand(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inetor(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inetpl(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inetmi_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inetmi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn statement_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn clock_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_cmp_prefix(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_has_role_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_has_role_name_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_has_role_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_has_role_id_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_has_role_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_has_role_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_justify_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_triggerdef_ext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dasind(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dacosd(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn datand(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn datan2d(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dsind(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dcosd(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dtand(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dcotd(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stop_backup_v2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_avg_serialize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_avg_deserialize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ginarrayextract(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ginarrayconsistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_avg_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn arrayoverlap(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn arraycontains(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn arraycontained(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_tuples_returned(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_tuples_fetched(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_tuples_inserted(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_tuples_updated(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_tuples_deleted(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regexp_matches_no_flags(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regexp_matches(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regexp_split_to_table_no_flags(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regexp_split_to_table(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regexp_split_to_array_no_flags(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regexp_split_to_array(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_bgwriter_timed_checkpoints(fcinfo: PgPtr<FunctionCallInfoBaseData>)
        -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_bgwriter_requested_checkpoints(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_bgwriter_buf_written_checkpoints(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_bgwriter_buf_written_clean(fcinfo: PgPtr<FunctionCallInfoBaseData>)
        -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_bgwriter_maxwritten_clean(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ginqueryarrayextract(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_buf_written_backend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn anynonarray_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn anynonarray_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_last_vacuum_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_last_autovacuum_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_last_analyze_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_last_autoanalyze_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_avg_combine(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_avg_serialize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_avg_deserialize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_backend_wait_event_type(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tidgt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tidlt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tidge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tidle(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bttidcmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tidlarger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tidsmaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8inc_any(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8inc_float8_float8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_regr_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_regr_sxx(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_regr_syy(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_regr_sxy(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_regr_avgx(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_regr_avgy(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_regr_r2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_regr_slope(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_regr_intercept(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_covar_pop(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_covar_samp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_corr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_blk_read_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_blk_write_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_switch_wal(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_current_wal_lsn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_walfile_name_offset(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_walfile_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_current_wal_insert_lsn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_backend_wait_event(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_my_temp_schema(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_is_other_temp_schema(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_timezone_names(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_backend_xact_start(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_avg_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_buf_alloc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_live_tuples(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_dead_tuples(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_lock_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_lock_shared_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_try_advisory_lock_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_try_advisory_lock_shared_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_unlock_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_unlock_shared_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_lock_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_lock_shared_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_try_advisory_lock_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_try_advisory_lock_shared_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_unlock_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_unlock_shared_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_unlock_all(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xml_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xml_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xmlcomment(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn texttoxml(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xmlvalidate(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xml_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xml_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xmlconcat2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varbittypmodin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn intervaltypmodin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn intervaltypmodout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptypmodin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptypmodout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptztypmodin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamptztypmodout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetypmodin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetypmodout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetztypmodin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetztypmodout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchartypmodin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchartypmodout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varchartypmodin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varchartypmodout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numerictypmodin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numerictypmodout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bittypmodin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bittypmodout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varbittypmodout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xmltotext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn table_to_xml(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn query_to_xml(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cursor_to_xml(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn table_to_xmlschema(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn query_to_xmlschema(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cursor_to_xmlschema(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn table_to_xml_and_xmlschema(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn query_to_xml_and_xmlschema(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xpath(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn schema_to_xml(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn schema_to_xmlschema(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn schema_to_xml_and_xmlschema(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn database_to_xml(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn database_to_xmlschema(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn database_to_xml_and_xmlschema(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn txid_snapshot_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn txid_snapshot_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn txid_snapshot_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn txid_snapshot_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn txid_current(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn txid_current_snapshot(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn txid_snapshot_xmin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn txid_snapshot_xmax(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn txid_snapshot_xip(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn txid_visible_in_snapshot(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_hash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn booltext(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_function_calls(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_function_total_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_function_self_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btrecordcmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_table_size(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_indexes_size(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_relation_filenode(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_name_name(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_name_id(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_id_name(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_id_id(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_name(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_server_privilege_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_server_privilege_name_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_server_privilege_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_server_privilege_id_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_server_privilege_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_server_privilege_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_column_privilege_name_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_column_privilege_name_name_attnum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_column_privilege_name_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_column_privilege_name_id_attnum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_column_privilege_id_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_column_privilege_id_name_attnum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_column_privilege_id_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_column_privilege_id_id_attnum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_column_privilege_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_column_privilege_name_attnum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_column_privilege_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_column_privilege_id_attnum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_any_column_privilege_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_any_column_privilege_name_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_any_column_privilege_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_any_column_privilege_id_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_any_column_privilege_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_any_column_privilege_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitoverlay(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitoverlay_no_len(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitgetbit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bitsetbit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_relation_filepath(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_listening_channels(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_notify(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_xact_numscans(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_xact_tuples_returned(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_xact_tuples_fetched(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_xact_tuples_inserted(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_xact_tuples_updated(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_xact_tuples_deleted(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_xact_tuples_hot_updated(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_xact_blocks_fetched(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_xact_blocks_hit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_xact_function_calls(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_xact_function_total_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_xact_function_self_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xpath_exists(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xml_is_well_formed(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xml_is_well_formed_document(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xml_is_well_formed_content(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_vacuum_count(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_autovacuum_count(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_analyze_count(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_autoanalyze_count(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_concat(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_concat_ws(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_left(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_right(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_reverse(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_buf_fsync_backend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_point_distance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_conflict_tablespace(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_conflict_lock(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_conflict_snapshot(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_conflict_bufferpin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_conflict_startup_deadlock(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_conflict_all(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_wal_replay_pause(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_wal_replay_resume(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_is_wal_replay_paused(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_stat_reset_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_bgwriter_stat_reset_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ginarrayextract_2args(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_extract_tsvector_2args(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_sequence_parameters(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_available_extensions(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_available_extension_versions(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_extension_update_paths(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_extension_config_dump(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_extract_tsquery_5args(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_tsquery_consistent_6args(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_xact_lock_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_xact_lock_shared_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_try_advisory_xact_lock_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_try_advisory_xact_lock_shared_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_xact_lock_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_advisory_xact_lock_shared_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_try_advisory_xact_lock_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_try_advisory_xact_lock_shared_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varchar_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_create_restore_point(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_wal_senders(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_row_number(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_rank(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_dense_rank(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_percent_rank(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_cume_dist(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_ntile(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_lag(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_lag_with_offset(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_lag_with_offset_and_default(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_lead(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_lead_with_offset(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_lead_with_offset_and_default(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_first_value(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_last_value(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn window_nth_value(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn fdw_handler_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn fdw_handler_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn void_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn void_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btint2sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btint4sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btint8sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btfloat4sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btfloat8sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btoidsortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btnamesortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn date_sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_type_privilege_name_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_type_privilege_name_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_type_privilege_id_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_type_privilege_id_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_type_privilege_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn has_type_privilege_id(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_not(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_and(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_or(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_temp_files(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_temp_bytes(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_deadlocks(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_to_json(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_to_json_pretty(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn row_to_json(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn row_to_json_pretty(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn varbit_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_viewdef_wrap(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_checkpoint_write_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_checkpoint_sync_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_collation_for(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_trigger_depth(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_wal_lsn_diff(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_size_pretty_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_remove(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_replace(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn rangesel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_lseek64(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_tell64(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_truncate64(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_agg_transfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_agg_finalfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_json(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_mod_since_analyze(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_sum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_cardinality(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_object_agg_transfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_image_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_image_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_image_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_image_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_image_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn record_image_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btrecordimagecmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_archiver(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_object_agg_finalfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_build_array(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_build_array_noargs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_build_object(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_build_object_noargs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_object(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_object_two_arg(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_to_record(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_to_recordset(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_array_length(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_each(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_populate_record(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_typeof(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_object_field_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_array_element(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_array_element_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_extract_path(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn width_bucket_array(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_array_elements(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_mi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_hash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bttextsortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn generate_series_step_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn generate_series_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_strip_nulls(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_strip_nulls(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_object(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_object_two_arg(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_agg_transfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_agg_finalfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_object_agg_transfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_object_agg_finalfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_build_array(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_build_array_noargs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_build_object(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_build_object_noargs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dist_ppoly(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_position(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_position_start(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_positions(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_circle_distance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_scale(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_point_fetch(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gist_poly_distance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dist_cpoint(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dist_polyp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_read_file_v2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn show_config_by_name_missing_ok(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_read_binary_file(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_notification_queue_usage(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ls_dir(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn row_security_active(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn row_security_active_name(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_concat(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_delete(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_delete_idx(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_delete_path(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_set(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_pretty(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_file(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn xidneq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsm_handler_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsm_handler_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsm_bernoulli_handler(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsm_system_handler(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_wal_receiver(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_progress_info(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_filter(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_setweight_by_filter(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_delete_str(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_unnest(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_delete_arr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4_avg_combine(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_combine(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_to_array(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_to_tsvector(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bpchar_sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn show_all_file_settings(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_current_wal_flush_lsn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bytea_sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bttext_pattern_sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn btbpchar_pattern_sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_size_bytes(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_serialize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_deserialize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_avg_combine(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_poly_combine(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_poly_serialize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_poly_deserialize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_combine(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn float8_regr_combine(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_delete_array(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_mul_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_div_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn txid_current_if_assigned(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_partkeydef(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ls_logdir(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ls_waldir(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ndistinct_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ndistinct_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ndistinct_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ndistinct_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr_sortsupport(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn txid_status(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_safe_snapshot_blocking_pids(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_isolation_test_session_is_blocked(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_identify_object_as_address(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn brin_minmax_opcinfo(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn brin_minmax_add_value(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn brin_minmax_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn brin_minmax_union(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_avg_accum_inv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_poly_sum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_poly_avg(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_poly_var_pop(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_poly_var_samp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_poly_stddev_pop(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_poly_stddev_samp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regexp_match_no_flags(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regexp_match(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_mul_cash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_config(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_hba_file_rules(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_statistics_obj_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_dependencies_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_dependencies_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_dependencies_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_dependencies_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_partition_constraintdef(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_hash_extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timetz_hash_extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_hash_extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn uuid_hash_extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_lsn_hash_extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashenumextended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_statisticsobjdef(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_hash_extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hash_range_extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_hash_extended(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn sha224_bytea(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn sha256_bytea(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn sha384_bytea(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn sha512_bytea(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_partition_tree(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_partition_root(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_partition_ancestors(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_checksum_failures(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stats_ext_mcvlist_items(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_db_checksum_last_failure(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_promote(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn prefixsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn prefixjoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_control_system(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_control_checkpoint(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_control_recovery(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_control_init(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_import_system_collations(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_collation_actual_version(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_int2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_float4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_filenode_relation(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_from_bytea(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_get(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_get_fragment(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn be_lo_put(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn make_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn make_timestamptz(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn make_timestamptz_at_timezone(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn make_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_array_elements_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_range_quad_config(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_range_quad_choose(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_range_quad_picksplit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_range_quad_inner_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_range_quad_leaf_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_populate_recordset(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_regoperator(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_object_field(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_regprocedure(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_compare_jsonb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_extract_jsonb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_extract_jsonb_query(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_consistent_jsonb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_extract_jsonb_path(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_extract_jsonb_query_path(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_consistent_jsonb_path(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_triconsistent_jsonb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_triconsistent_jsonb_path(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_to_record(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_to_recordset(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_regoper(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_regtype(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_regproc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_regclass(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bool_accum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bool_accum_inv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bool_alltrue(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bool_anytrue(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn anyenum_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn anyenum_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hashenum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_first(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_last(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_range_bounds(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_range_all(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn enum_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn string_agg_transfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn string_agg_finalfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_describe_object(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_format(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_format_nv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bytea_string_agg_transfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn bytea_string_agg_finalfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8dec(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8dec_any(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_accum_inv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_accum_inv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_overlap(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_gist_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_gist_union(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_gist_compress(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_bool(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_gist_penalty(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_gist_picksplit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_gist_same(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn networksel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn networkjoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_larger(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_smaller(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_event_trigger_dropped_objects(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2_accum_inv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4_accum_inv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_accum_inv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2_avg_accum_inv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4_avg_accum_inv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int2int4_sum(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_gist_fetch(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_logical_emit_message_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_logical_emit_message_bytea(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_insert(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_xact_commit_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_upgrade_set_next_pg_type_oid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_last_committed_xact(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_upgrade_set_next_array_pg_type_oid(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_upgrade_set_next_toast_pg_type_oid(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_upgrade_set_next_heap_pg_class_oid(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_upgrade_set_next_index_pg_class_oid(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_upgrade_set_next_toast_pg_class_oid(
        fcinfo: PgPtr<FunctionCallInfoBaseData>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_upgrade_set_next_pg_enum_oid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_upgrade_set_next_pg_authid_oid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_upgrade_create_empty_extension(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn event_trigger_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn event_trigger_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvectorin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvectorout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsqueryin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsqueryout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_strip(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_setweight(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_concat(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_match_vq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_match_qv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvectorsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvectorrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquerysend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsqueryrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsvectorin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsvectorout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsvector_compress(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsvector_decompress(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsvector_picksplit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsvector_union(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsvector_same(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsvector_penalty(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsvector_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_extract_tsvector(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_extract_tsquery(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_tsquery_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_and(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_or(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_not(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_numnode(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquerytree(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_rewrite(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_rewrite_query(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsmatchsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsmatchjoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_typanalyze(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_stat1(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_stat2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsq_mcontains(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsq_mcontained(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsquery_compress(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn text_starts_with(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsquery_picksplit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsquery_union(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsquery_same(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsquery_penalty(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsquery_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_rank_wttf(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_rank_wtt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_rank_ttf(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_rank_tt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_rankcd_wttf(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_rankcd_wtt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_rankcd_ttf(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_rankcd_tt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_length(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_token_type_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_token_type_byname(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_parse_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_parse_byname(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn prsd_start(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn prsd_nexttoken(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn prsd_end(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn prsd_headline(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn prsd_lextype(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_lexize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_cmp_tslexeme(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dsimple_init(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dsimple_lexize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dsynonym_init(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dsynonym_lexize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dispell_init(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn dispell_lexize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regconfigin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regconfigout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regconfigrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regconfigsend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn thesaurus_init(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn thesaurus_lexize(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_headline_byid_opt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_headline_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_tsvector_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_tsquery_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn plainto_tsquery_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_tsvector(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_tsquery(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn plainto_tsquery(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_update_trigger_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsvector_update_trigger_bycolumn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_headline_opt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_headline(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ts_parser_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ts_dict_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ts_config_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn get_current_ts_config(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_match_tt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_match_tq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ts_template_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regdictionaryin(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regdictionaryout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regdictionaryrecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regdictionarysend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_reset_shared(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_reset_single_table_counters(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_reset_single_function_counters(fcinfo: PgPtr<FunctionCallInfoBaseData>)
        -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_tablespace_location(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_create_physical_replication_slot(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_drop_replication_slot(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_replication_slots(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_logical_slot_get_changes(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_logical_slot_get_binary_changes(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_logical_slot_peek_changes(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_logical_slot_peek_binary_changes(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_create_logical_replication_slot(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_jsonb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_snapshot_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_clean_pending_list(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsvector_consistent_oldsig(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_extract_tsquery_oldsig(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_tsquery_consistent_oldsig(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gtsquery_consistent_oldsig(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_spg_config(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_spg_choose(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_spg_picksplit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_spg_inner_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_spg_leaf_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_current_logfile(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_current_logfile_1arg(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_function_arg_default(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_export_snapshot(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_is_in_recovery(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4_cash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8_cash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_is_in_backup(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_backup_start_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_collation_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_typanalyze(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn arraycontsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn arraycontjoinsel(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_multixact_members(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_last_wal_receive_lsn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_last_wal_replay_lsn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_div_cash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn cash_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numeric_cash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_read_file_all(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_read_binary_file_off_len(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_read_binary_file_all(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_opfamily_is_visible(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_last_xact_replay_timestamp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn anyrange_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn anyrange_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_identify_object(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_constructor2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_constructor3(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_relation_is_updatable(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_column_is_updatable(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn make_date(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn make_time(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_lower(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_upper(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_empty(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_lower_inc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_upper_inc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_lower_inf(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_upper_inf(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_overlaps(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_contains_elem(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_contains(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn elem_contained_by_range(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_contained_by(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_adjacent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_before(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_after(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_overleft(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_overright(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_union(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_intersect(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_minus(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_gist_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_gist_union(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_replication_slot_advance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_gist_penalty(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_gist_picksplit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_gist_same(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hash_range(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4range_canonical(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn daterange_canonical(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_typanalyze(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn timestamp_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn interval_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ginarraytriconsistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn gin_tsquery_triconsistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int4range_subdiff(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8range_subdiff(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn numrange_subdiff(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn daterange_subdiff(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn int8range_canonical(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsrange_subdiff(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tstzrange_subdiff(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_object_keys(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_each_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn mxid_age(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_extract_path_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn acldefault_sql(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn time_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_object_field(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_object_field_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_array_element(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_array_element_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_extract_path(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn brin_summarize_new_values(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_extract_path_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_object_address(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_array_elements(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_array_length(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_object_keys(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_each(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_each_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_populate_record(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_populate_recordset(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_typeof(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_array_elements_text(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ordered_set_transition(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ordered_set_transition_multi(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn percentile_disc_final(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn percentile_cont_float8_final(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn percentile_cont_interval_final(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn percentile_disc_multi_final(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn percentile_cont_float8_multi_final(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn percentile_cont_interval_multi_final(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn mode_final(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hypothetical_rank_final(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hypothetical_percent_rank_final(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hypothetical_cume_dist_final(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn hypothetical_dense_rank_final(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn generate_series_int4_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn generate_series_int8_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_unnest_support(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn brin_summarize_range(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonpath_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonpath_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonpath_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonpath_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_path_exists(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_path_query(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_path_query_array(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_path_query_first(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_path_match(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_path_exists_opr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_path_match_opr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn brin_desummarize_range(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_quad_config(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_quad_choose(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_quad_picksplit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_quad_inner_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_quad_leaf_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_kd_config(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_kd_choose(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_kd_picksplit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_kd_inner_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_text_config(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_text_choose(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_text_picksplit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_text_inner_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_text_leaf_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_sequence_last_value(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_hash(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_contains(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_exists(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_exists_any(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_exists_all(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_contained(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_agg_array_transfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn array_agg_array_finalfn(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn range_merge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_merge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn boxes_bound_box(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn inet_same_family(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_upgrade_set_record_init_privs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regnamespacein(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regnamespaceout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_regnamespace(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regnamespacerecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regnamespacesend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn point_box(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regroleout(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn to_regrole(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regrolerecv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regrolesend(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn regrolein(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_rotate_logfile(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_read_file(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn binary_upgrade_set_missing_value(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn brin_inclusion_opcinfo(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn brin_inclusion_add_value(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn brin_inclusion_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn brin_inclusion_union(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_trunc(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_eq(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_lt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_le(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_gt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_ge(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_ne(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_cmp(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_not(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_and(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_or(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddrtomacaddr8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8tomacaddr(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn macaddr8_set7bit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_int8_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_int4_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_int4_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_int4_int2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_int2_int8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_int2_int4(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_int2_int2(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_date_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_timestamp_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_timestamptz_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_interval_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_time_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_timetz_interval(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_float8_float8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_float4_float8(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn in_range_numeric_numeric(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_headline_jsonb_byid_opt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_headline_jsonb_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_headline_jsonb_opt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_headline_jsonb(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_headline_json_byid_opt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_headline_json_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_headline_json_opt(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn ts_headline_json(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_string_to_tsvector(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_string_to_tsvector(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_string_to_tsvector_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_string_to_tsvector_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_to_tsvector(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn jsonb_to_tsvector_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_to_tsvector(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn json_to_tsvector_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_copy_physical_replication_slot_a(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_copy_physical_replication_slot_b(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_copy_logical_replication_slot_a(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_copy_logical_replication_slot_b(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_copy_logical_replication_slot_c(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_event_trigger_table_rewrite_oid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_event_trigger_table_rewrite_reason(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_event_trigger_ddl_commands(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn phraseto_tsquery(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_phrase(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn tsquery_phrase_distance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn phraseto_tsquery_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn websearch_to_tsquery_byid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn websearch_to_tsquery(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_bbox_quad_config(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_poly_quad_compress(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_box_quad_config(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_box_quad_choose(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_box_quad_picksplit(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_box_quad_inner_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn spg_box_quad_leaf_consistent(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_mcv_list_in(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_mcv_list_out(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_mcv_list_recv(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_mcv_list_send(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn satisfies_hash_partition(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ls_tmpdir_noargs(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ls_tmpdir_1arg(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_ls_archive_statusdir(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_replication_origin_create(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_replication_origin_drop(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_replication_origin_oid(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_replication_origin_session_setup(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_replication_origin_session_reset(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_replication_origin_session_is_setup(fcinfo: PgPtr<FunctionCallInfoBaseData>)
        -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_replication_origin_session_progress(fcinfo: PgPtr<FunctionCallInfoBaseData>)
        -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_replication_origin_xact_setup(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_replication_origin_xact_reset(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_replication_origin_advance(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_replication_origin_progress(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_show_replication_origin_status(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_stat_get_subscription(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_get_replica_identity_index(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn pg_relation_is_publishable(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn parse_bool(value: PgPtr<::std::os::raw::c_char>, result: PgPtr<bool>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn parse_bool_with_len(
        value: PgPtr<::std::os::raw::c_char>,
        len: usize,
        result: PgPtr<bool>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn domain_check(
        value: Datum,
        isnull: bool,
        domainType: Oid,
        extra: PgPtr<PgPtr<::std::os::raw::c_void>>,
        mcxt: PgPtr<MemoryContextData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn errdatatype(datatypeOid: Oid) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn errdomainconstraint(
        datatypeOid: Oid,
        conname: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn hex_encode(
        src: PgPtr<::std::os::raw::c_char>,
        len: ::std::os::raw::c_uint,
        dst: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_uint;
}
#[pg_guard]
extern "C" {
    pub fn hex_decode(
        src: PgPtr<::std::os::raw::c_char>,
        len: ::std::os::raw::c_uint,
        dst: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_uint;
}
#[pg_guard]
extern "C" {
    pub fn buildint2vector(int2s: PgPtr<int16>, n: ::std::os::raw::c_int) -> PgPtr<int2vector>;
}
#[pg_guard]
extern "C" {
    pub fn namecpy(n1: PgPtr<NameData>, n2: PgPtr<NameData>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn namestrcpy(
        name: PgPtr<NameData>,
        str_: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn namestrcmp(
        name: PgPtr<NameData>,
        str_: PgPtr<::std::os::raw::c_char>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn pg_atoi(
        s: PgPtr<::std::os::raw::c_char>,
        size: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
    ) -> int32;
}
#[pg_guard]
extern "C" {
    pub fn pg_strtoint16(s: PgPtr<::std::os::raw::c_char>) -> int16;
}
#[pg_guard]
extern "C" {
    pub fn pg_strtoint32(s: PgPtr<::std::os::raw::c_char>) -> int32;
}
#[pg_guard]
extern "C" {
    pub fn pg_itoa(i: int16, a: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn pg_ltoa(l: int32, a: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn pg_lltoa(ll: int64, a: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn pg_ltostr_zeropad(
        str_: PgPtr<::std::os::raw::c_char>,
        value: int32,
        minwidth: int32,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pg_ltostr(
        str_: PgPtr<::std::os::raw::c_char>,
        value: int32,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn pg_strtouint64(
        str_: PgPtr<::std::os::raw::c_char>,
        endptr: PgPtr<PgPtr<::std::os::raw::c_char>>,
        base: ::std::os::raw::c_int,
    ) -> uint64;
}
#[pg_guard]
extern "C" {
    pub fn buildoidvector(oids: PgPtr<Oid>, n: ::std::os::raw::c_int) -> PgPtr<oidvector>;
}
#[pg_guard]
extern "C" {
    pub fn oidparse(node: PgPtr<Node>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn oid_cmp(
        p1: PgPtr<::std::os::raw::c_void>,
        p2: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn regexp_fixed_prefix(
        text_re: PgPtr<text>,
        case_insensitive: bool,
        collation: Oid,
        exact: PgPtr<bool>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub static mut quote_all_identifiers: bool;
}
#[pg_guard]
extern "C" {
    pub fn quote_identifier(ident: PgPtr<::std::os::raw::c_char>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn quote_qualified_identifier(
        qualifier: PgPtr<::std::os::raw::c_char>,
        ident: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn generate_operator_clause(
        buf: PgPtr<StringInfoData>,
        leftop: PgPtr<::std::os::raw::c_char>,
        leftoptype: Oid,
        opoid: Oid,
        rightop: PgPtr<::std::os::raw::c_char>,
        rightoptype: Oid,
    );
}
#[pg_guard]
extern "C" {
    pub fn bpchartruelen(
        s: PgPtr<::std::os::raw::c_char>,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn cstring_to_text(s: PgPtr<::std::os::raw::c_char>) -> PgPtr<text>;
}
#[pg_guard]
extern "C" {
    pub fn cstring_to_text_with_len(
        s: PgPtr<::std::os::raw::c_char>,
        len: ::std::os::raw::c_int,
    ) -> PgPtr<text>;
}
#[pg_guard]
extern "C" {
    pub fn text_to_cstring(t: PgPtr<text>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn text_to_cstring_buffer(
        src: PgPtr<text>,
        dst: PgPtr<::std::os::raw::c_char>,
        dst_len: usize,
    );
}
#[pg_guard]
extern "C" {
    pub fn xidComparator(
        arg1: PgPtr<::std::os::raw::c_void>,
        arg2: PgPtr<::std::os::raw::c_void>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn inet_cidr_ntop(
        af: ::std::os::raw::c_int,
        src: PgPtr<::std::os::raw::c_void>,
        bits: ::std::os::raw::c_int,
        dst: PgPtr<::std::os::raw::c_char>,
        size: usize,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn inet_net_pton(
        af: ::std::os::raw::c_int,
        src: PgPtr<::std::os::raw::c_char>,
        dst: PgPtr<::std::os::raw::c_void>,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn convert_network_to_scalar(value: Datum, typid: Oid, failure: PgPtr<bool>) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn network_scan_first(in_: Datum) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn network_scan_last(in_: Datum) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn clean_ipv6_addr(addr_family: ::std::os::raw::c_int, addr: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn numeric_float8_no_overflow(fcinfo: PgPtr<FunctionCallInfoBaseData>) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn format_type_extended(
        type_oid: Oid,
        typemod: int32,
        flags: bits16,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn format_type_be(type_oid: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn format_type_be_qualified(type_oid: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn format_type_with_typemod(type_oid: Oid, typemod: int32)
        -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn type_maximum_size(type_oid: Oid, typemod: int32) -> int32;
}
#[pg_guard]
extern "C" {
    pub fn quote_literal_cstr(
        rawstr: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<::std::os::raw::c_char>;
}
pub type DateADT = int32;
pub type TimeADT = int64;
#[repr(C)]
pub struct TimeTzADT {
    pub time: TimeADT,
    pub zone: int32,
}
#[pg_guard]
extern "C" {
    pub fn anytime_typmod_check(istz: bool, typmod: int32) -> int32;
}
#[pg_guard]
extern "C" {
    pub fn date2timestamp_no_overflow(dateVal: DateADT) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn EncodeSpecialDate(dt: DateADT, str_: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn GetSQLCurrentDate() -> DateADT;
}
#[pg_guard]
extern "C" {
    pub fn GetSQLCurrentTime(typmod: int32) -> PgPtr<TimeTzADT>;
}
#[pg_guard]
extern "C" {
    pub fn GetSQLLocalTime(typmod: int32) -> TimeADT;
}
#[pg_guard]
extern "C" {
    pub fn time2tm(time: TimeADT, tm: PgPtr<pg_tm>, fsec: PgPtr<fsec_t>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn timetz2tm(
        time: PgPtr<TimeTzADT>,
        tm: PgPtr<pg_tm>,
        fsec: PgPtr<fsec_t>,
        tzp: PgPtr<::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn time_overflows(
        hour: ::std::os::raw::c_int,
        min: ::std::os::raw::c_int,
        sec: ::std::os::raw::c_int,
        fsec: fsec_t,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn float_time_overflows(
        hour: ::std::os::raw::c_int,
        min: ::std::os::raw::c_int,
        sec: f64,
    ) -> bool;
}
#[repr(C)]
pub struct Point {
    pub x: float8,
    pub y: float8,
}
#[repr(C)]
pub struct LSEG {
    pub p: [Point; 2usize],
}
#[repr(C)]
pub struct PATH {
    pub vl_len_: int32,
    pub npts: int32,
    pub closed: int32,
    pub dummy: int32,
    pub p: __IncompleteArrayField<Point>,
}
#[repr(C)]
pub struct LINE {
    pub A: float8,
    pub B: float8,
    pub C: float8,
}
#[repr(C)]
pub struct BOX {
    pub high: Point,
    pub low: Point,
}
#[repr(C)]
pub struct POLYGON {
    pub vl_len_: int32,
    pub npts: int32,
    pub boundbox: BOX,
    pub p: __IncompleteArrayField<Point>,
}
#[repr(C)]
pub struct CIRCLE {
    pub center: Point,
    pub radius: float8,
}
#[pg_guard]
extern "C" {
    pub fn pg_hypot(x: float8, y: float8) -> float8;
}
#[pg_guard]
extern "C" {
    pub fn escape_json(buf: PgPtr<StringInfoData>, str_: PgPtr<::std::os::raw::c_char>);
}
#[repr(C)]
pub struct NumericData {
    _unused: [u8; 0],
}
pub type Numeric = PgPtr<NumericData>;
#[pg_guard]
extern "C" {
    pub fn numeric_is_nan(num: PgPtr<NumericData>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn numeric_maximum_size(typmod: int32) -> int32;
}
#[pg_guard]
extern "C" {
    pub fn numeric_out_sci(
        num: PgPtr<NumericData>,
        scale: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn numeric_normalize(num: PgPtr<NumericData>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn numeric_add_opt_error(
        num1: PgPtr<NumericData>,
        num2: PgPtr<NumericData>,
        have_error: PgPtr<bool>,
    ) -> PgPtr<NumericData>;
}
#[pg_guard]
extern "C" {
    pub fn numeric_sub_opt_error(
        num1: PgPtr<NumericData>,
        num2: PgPtr<NumericData>,
        have_error: PgPtr<bool>,
    ) -> PgPtr<NumericData>;
}
#[pg_guard]
extern "C" {
    pub fn numeric_mul_opt_error(
        num1: PgPtr<NumericData>,
        num2: PgPtr<NumericData>,
        have_error: PgPtr<bool>,
    ) -> PgPtr<NumericData>;
}
#[pg_guard]
extern "C" {
    pub fn numeric_div_opt_error(
        num1: PgPtr<NumericData>,
        num2: PgPtr<NumericData>,
        have_error: PgPtr<bool>,
    ) -> PgPtr<NumericData>;
}
#[pg_guard]
extern "C" {
    pub fn numeric_mod_opt_error(
        num1: PgPtr<NumericData>,
        num2: PgPtr<NumericData>,
        have_error: PgPtr<bool>,
    ) -> PgPtr<NumericData>;
}
#[pg_guard]
extern "C" {
    pub fn numeric_int4_opt_error(num: PgPtr<NumericData>, error: PgPtr<bool>) -> int32;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum JsonbIteratorToken {
    WJB_DONE = 0,
    WJB_KEY = 1,
    WJB_VALUE = 2,
    WJB_ELEM = 3,
    WJB_BEGIN_ARRAY = 4,
    WJB_END_ARRAY = 5,
    WJB_BEGIN_OBJECT = 6,
    WJB_END_OBJECT = 7,
}
pub type JEntry = uint32;
#[repr(C)]
pub struct JsonbContainer {
    pub header: uint32,
    pub children: __IncompleteArrayField<JEntry>,
}
#[repr(C)]
pub struct Jsonb {
    pub vl_len_: int32,
    pub root: JsonbContainer,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum jbvType {
    jbvNull = 0,
    jbvString = 1,
    jbvNumeric = 2,
    jbvBool = 3,
    jbvArray = 16,
    jbvObject = 17,
    jbvBinary = 18,
}
#[repr(C)]
pub struct JsonbValue {
    pub type_: jbvType,
    pub val: JsonbValue__bindgen_ty_1,
}
#[repr(C)]
pub struct JsonbValue__bindgen_ty_1 {
    pub numeric: __BindgenUnionField<PgPtr<NumericData>>,
    pub boolean: __BindgenUnionField<bool>,
    pub string: __BindgenUnionField<JsonbValue__bindgen_ty_1__bindgen_ty_1>,
    pub array: __BindgenUnionField<JsonbValue__bindgen_ty_1__bindgen_ty_2>,
    pub object: __BindgenUnionField<JsonbValue__bindgen_ty_1__bindgen_ty_3>,
    pub binary: __BindgenUnionField<JsonbValue__bindgen_ty_1__bindgen_ty_4>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::std::os::raw::c_int,
    pub val: PgPtr<::std::os::raw::c_char>,
}
#[repr(C)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_2 {
    pub nElems: ::std::os::raw::c_int,
    pub elems: PgPtr<JsonbValue>,
    pub rawScalar: bool,
}
#[repr(C)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_3 {
    pub nPairs: ::std::os::raw::c_int,
    pub pairs: PgPtr<JsonbPair>,
}
#[repr(C)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_4 {
    pub len: ::std::os::raw::c_int,
    pub data: PgPtr<JsonbContainer>,
}
#[repr(C)]
pub struct JsonbPair {
    pub key: JsonbValue,
    pub value: JsonbValue,
    pub order: uint32,
}
#[repr(C)]
pub struct JsonbParseState {
    pub contVal: JsonbValue,
    pub size: Size,
    pub next: PgPtr<JsonbParseState>,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum JsonbIterState {
    JBI_ARRAY_START = 0,
    JBI_ARRAY_ELEM = 1,
    JBI_OBJECT_START = 2,
    JBI_OBJECT_KEY = 3,
    JBI_OBJECT_VALUE = 4,
}
#[repr(C)]
pub struct JsonbIterator {
    pub container: PgPtr<JsonbContainer>,
    pub nElems: uint32,
    pub isScalar: bool,
    pub children: PgPtr<JEntry>,
    pub dataProper: PgPtr<::std::os::raw::c_char>,
    pub curIndex: ::std::os::raw::c_int,
    pub curDataOffset: uint32,
    pub curValueOffset: uint32,
    pub state: JsonbIterState,
    pub parent: PgPtr<JsonbIterator>,
}
#[pg_guard]
extern "C" {
    pub fn getJsonbOffset(jc: PgPtr<JsonbContainer>, index: ::std::os::raw::c_int) -> uint32;
}
#[pg_guard]
extern "C" {
    pub fn getJsonbLength(jc: PgPtr<JsonbContainer>, index: ::std::os::raw::c_int) -> uint32;
}
#[pg_guard]
extern "C" {
    pub fn compareJsonbContainers(
        a: PgPtr<JsonbContainer>,
        b: PgPtr<JsonbContainer>,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn findJsonbValueFromContainer(
        sheader: PgPtr<JsonbContainer>,
        flags: uint32,
        key: PgPtr<JsonbValue>,
    ) -> PgPtr<JsonbValue>;
}
#[pg_guard]
extern "C" {
    pub fn getIthJsonbValueFromContainer(
        sheader: PgPtr<JsonbContainer>,
        i: uint32,
    ) -> PgPtr<JsonbValue>;
}
#[pg_guard]
extern "C" {
    pub fn pushJsonbValue(
        pstate: PgPtr<PgPtr<JsonbParseState>>,
        seq: JsonbIteratorToken,
        jbVal: PgPtr<JsonbValue>,
    ) -> PgPtr<JsonbValue>;
}
#[pg_guard]
extern "C" {
    pub fn JsonbIteratorInit(container: PgPtr<JsonbContainer>) -> PgPtr<JsonbIterator>;
}
#[pg_guard]
extern "C" {
    pub fn JsonbIteratorNext(
        it: PgPtr<PgPtr<JsonbIterator>>,
        val: PgPtr<JsonbValue>,
        skipNested: bool,
    ) -> JsonbIteratorToken;
}
#[pg_guard]
extern "C" {
    pub fn JsonbValueToJsonb(val: PgPtr<JsonbValue>) -> PgPtr<Jsonb>;
}
#[pg_guard]
extern "C" {
    pub fn JsonbDeepContains(
        val: PgPtr<PgPtr<JsonbIterator>>,
        mContained: PgPtr<PgPtr<JsonbIterator>>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn JsonbHashScalarValue(scalarVal: PgPtr<JsonbValue>, hash: PgPtr<uint32>);
}
#[pg_guard]
extern "C" {
    pub fn JsonbHashScalarValueExtended(
        scalarVal: PgPtr<JsonbValue>,
        hash: PgPtr<uint64>,
        seed: uint64,
    );
}
#[pg_guard]
extern "C" {
    pub fn JsonbToCString(
        out: PgPtr<StringInfoData>,
        in_: PgPtr<JsonbContainer>,
        estimated_len: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn JsonbToCStringIndent(
        out: PgPtr<StringInfoData>,
        in_: PgPtr<JsonbContainer>,
        estimated_len: ::std::os::raw::c_int,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn JsonbExtractScalar(jbc: PgPtr<JsonbContainer>, res: PgPtr<JsonbValue>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn JsonbTypeName(jb: PgPtr<JsonbValue>) -> PgPtr<::std::os::raw::c_char>;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SysCacheIdentifier {
    AGGFNOID = 0,
    AMNAME = 1,
    AMOID = 2,
    AMOPOPID = 3,
    AMOPSTRATEGY = 4,
    AMPROCNUM = 5,
    ATTNAME = 6,
    ATTNUM = 7,
    AUTHMEMMEMROLE = 8,
    AUTHMEMROLEMEM = 9,
    AUTHNAME = 10,
    AUTHOID = 11,
    CASTSOURCETARGET = 12,
    CLAAMNAMENSP = 13,
    CLAOID = 14,
    COLLNAMEENCNSP = 15,
    COLLOID = 16,
    CONDEFAULT = 17,
    CONNAMENSP = 18,
    CONSTROID = 19,
    CONVOID = 20,
    DATABASEOID = 21,
    DEFACLROLENSPOBJ = 22,
    ENUMOID = 23,
    ENUMTYPOIDNAME = 24,
    EVENTTRIGGERNAME = 25,
    EVENTTRIGGEROID = 26,
    FOREIGNDATAWRAPPERNAME = 27,
    FOREIGNDATAWRAPPEROID = 28,
    FOREIGNSERVERNAME = 29,
    FOREIGNSERVEROID = 30,
    FOREIGNTABLEREL = 31,
    INDEXRELID = 32,
    LANGNAME = 33,
    LANGOID = 34,
    NAMESPACENAME = 35,
    NAMESPACEOID = 36,
    OPERNAMENSP = 37,
    OPEROID = 38,
    OPFAMILYAMNAMENSP = 39,
    OPFAMILYOID = 40,
    PARTRELID = 41,
    PROCNAMEARGSNSP = 42,
    PROCOID = 43,
    PUBLICATIONNAME = 44,
    PUBLICATIONOID = 45,
    PUBLICATIONREL = 46,
    PUBLICATIONRELMAP = 47,
    RANGETYPE = 48,
    RELNAMENSP = 49,
    RELOID = 50,
    REPLORIGIDENT = 51,
    REPLORIGNAME = 52,
    RULERELNAME = 53,
    SEQRELID = 54,
    STATEXTDATASTXOID = 55,
    STATEXTNAMENSP = 56,
    STATEXTOID = 57,
    STATRELATTINH = 58,
    SUBSCRIPTIONNAME = 59,
    SUBSCRIPTIONOID = 60,
    SUBSCRIPTIONRELMAP = 61,
    TABLESPACEOID = 62,
    TRFOID = 63,
    TRFTYPELANG = 64,
    TSCONFIGMAP = 65,
    TSCONFIGNAMENSP = 66,
    TSCONFIGOID = 67,
    TSDICTNAMENSP = 68,
    TSDICTOID = 69,
    TSPARSERNAMENSP = 70,
    TSPARSEROID = 71,
    TSTEMPLATENAMENSP = 72,
    TSTEMPLATEOID = 73,
    TYPENAMENSP = 74,
    TYPEOID = 75,
    USERMAPPINGOID = 76,
    USERMAPPINGUSERSERVER = 77,
}
#[pg_guard]
extern "C" {
    pub fn InitCatalogCache();
}
#[pg_guard]
extern "C" {
    pub fn InitCatalogCachePhase2();
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCache(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCache1(cacheId: ::std::os::raw::c_int, key1: Datum) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCache2(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCache3(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCache4(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn ReleaseSysCache(tuple: PgPtr<HeapTupleData>);
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCacheCopy(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCacheExists(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn GetSysCacheOid(
        cacheId: ::std::os::raw::c_int,
        oidcol: AttrNumber,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCacheAttName(
        relid: Oid,
        attname: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCacheCopyAttName(
        relid: Oid,
        attname: PgPtr<::std::os::raw::c_char>,
    ) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCacheExistsAttName(relid: Oid, attname: PgPtr<::std::os::raw::c_char>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCacheAttNum(relid: Oid, attnum: int16) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCacheCopyAttNum(relid: Oid, attnum: int16) -> PgPtr<HeapTupleData>;
}
#[pg_guard]
extern "C" {
    pub fn SysCacheGetAttr(
        cacheId: ::std::os::raw::c_int,
        tup: PgPtr<HeapTupleData>,
        attributeNumber: AttrNumber,
        isNull: PgPtr<bool>,
    ) -> Datum;
}
#[pg_guard]
extern "C" {
    pub fn GetSysCacheHashValue(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> uint32;
}
#[repr(C)]
pub struct catclist {
    _unused: [u8; 0],
}
#[pg_guard]
extern "C" {
    pub fn SearchSysCacheList(
        cacheId: ::std::os::raw::c_int,
        nkeys: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
    ) -> PgPtr<catclist>;
}
#[pg_guard]
extern "C" {
    pub fn SysCacheInvalidate(cacheId: ::std::os::raw::c_int, hashValue: uint32);
}
#[pg_guard]
extern "C" {
    pub fn RelationInvalidatesSnapshotsOnly(relid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn RelationHasSysCache(relid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn RelationSupportsSysCache(relid: Oid) -> bool;
}
#[repr(C)]
pub struct OpBtreeInterpretation {
    pub opfamily_id: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub oplefttype: Oid,
    pub oprighttype: Oid,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum IOFuncSelector {
    IOFunc_input = 0,
    IOFunc_output = 1,
    IOFunc_receive = 2,
    IOFunc_send = 3,
}
#[repr(C)]
pub struct AttStatsSlot {
    pub staop: Oid,
    pub stacoll: Oid,
    pub valuetype: Oid,
    pub values: PgPtr<Datum>,
    pub nvalues: ::std::os::raw::c_int,
    pub numbers: PgPtr<float4>,
    pub nnumbers: ::std::os::raw::c_int,
    pub values_arr: PgPtr<::std::os::raw::c_void>,
    pub numbers_arr: PgPtr<::std::os::raw::c_void>,
}
pub type get_attavgwidth_hook_type =
    ::std::option::Option<unsafe extern "C" fn(relid: Oid, attnum: AttrNumber) -> int32>;
#[pg_guard]
extern "C" {
    pub static mut get_attavgwidth_hook: get_attavgwidth_hook_type;
}
#[pg_guard]
extern "C" {
    pub fn op_in_opfamily(opno: Oid, opfamily: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_op_opfamily_strategy(opno: Oid, opfamily: Oid) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn get_op_opfamily_sortfamily(opno: Oid, opfamily: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_op_opfamily_properties(
        opno: Oid,
        opfamily: Oid,
        ordering_op: bool,
        strategy: PgPtr<::std::os::raw::c_int>,
        lefttype: PgPtr<Oid>,
        righttype: PgPtr<Oid>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_opfamily_member(
        opfamily: Oid,
        lefttype: Oid,
        righttype: Oid,
        strategy: int16,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_ordering_op_properties(
        opno: Oid,
        opfamily: PgPtr<Oid>,
        opcintype: PgPtr<Oid>,
        strategy: PgPtr<int16>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_equality_op_for_ordering_op(opno: Oid, reverse: PgPtr<bool>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_ordering_op_for_equality_op(opno: Oid, use_lhs_type: bool) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_mergejoin_opfamilies(opno: Oid) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn get_compatible_hash_operators(
        opno: Oid,
        lhs_opno: PgPtr<Oid>,
        rhs_opno: PgPtr<Oid>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_op_hash_functions(
        opno: Oid,
        lhs_procno: PgPtr<RegProcedure>,
        rhs_procno: PgPtr<RegProcedure>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_op_btree_interpretation(opno: Oid) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn equality_ops_are_compatible(opno1: Oid, opno2: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_opfamily_proc(opfamily: Oid, lefttype: Oid, righttype: Oid, procnum: int16) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_attname(
        relid: Oid,
        attnum: AttrNumber,
        missing_ok: bool,
    ) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn get_attnum(relid: Oid, attname: PgPtr<::std::os::raw::c_char>) -> AttrNumber;
}
#[pg_guard]
extern "C" {
    pub fn get_attgenerated(relid: Oid, attnum: AttrNumber) -> ::std::os::raw::c_char;
}
#[pg_guard]
extern "C" {
    pub fn get_atttype(relid: Oid, attnum: AttrNumber) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_atttypetypmodcoll(
        relid: Oid,
        attnum: AttrNumber,
        typid: PgPtr<Oid>,
        typmod: PgPtr<int32>,
        collid: PgPtr<Oid>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_collation_name(colloid: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn get_collation_isdeterministic(colloid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_constraint_name(conoid: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn get_language_name(langoid: Oid, missing_ok: bool) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn get_opclass_family(opclass: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_opclass_input_type(opclass: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_opclass_opfamily_and_input_type(
        opclass: Oid,
        opfamily: PgPtr<Oid>,
        opcintype: PgPtr<Oid>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_opcode(opno: Oid) -> RegProcedure;
}
#[pg_guard]
extern "C" {
    pub fn get_opname(opno: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn get_op_rettype(opno: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn op_input_types(opno: Oid, lefttype: PgPtr<Oid>, righttype: PgPtr<Oid>);
}
#[pg_guard]
extern "C" {
    pub fn op_mergejoinable(opno: Oid, inputtype: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn op_hashjoinable(opno: Oid, inputtype: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn op_strict(opno: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn op_volatile(opno: Oid) -> ::std::os::raw::c_char;
}
#[pg_guard]
extern "C" {
    pub fn get_commutator(opno: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_negator(opno: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_oprrest(opno: Oid) -> RegProcedure;
}
#[pg_guard]
extern "C" {
    pub fn get_oprjoin(opno: Oid) -> RegProcedure;
}
#[pg_guard]
extern "C" {
    pub fn get_func_name(funcid: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn get_func_namespace(funcid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_func_rettype(funcid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_func_nargs(funcid: Oid) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn get_func_signature(
        funcid: Oid,
        argtypes: PgPtr<PgPtr<Oid>>,
        nargs: PgPtr<::std::os::raw::c_int>,
    ) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_func_variadictype(funcid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_func_retset(funcid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn func_strict(funcid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn func_volatile(funcid: Oid) -> ::std::os::raw::c_char;
}
#[pg_guard]
extern "C" {
    pub fn func_parallel(funcid: Oid) -> ::std::os::raw::c_char;
}
#[pg_guard]
extern "C" {
    pub fn get_func_prokind(funcid: Oid) -> ::std::os::raw::c_char;
}
#[pg_guard]
extern "C" {
    pub fn get_func_leakproof(funcid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_func_support(funcid: Oid) -> RegProcedure;
}
#[pg_guard]
extern "C" {
    pub fn get_relname_relid(relname: PgPtr<::std::os::raw::c_char>, relnamespace: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_rel_name(relid: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn get_rel_namespace(relid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_rel_type_id(relid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_rel_relkind(relid: Oid) -> ::std::os::raw::c_char;
}
#[pg_guard]
extern "C" {
    pub fn get_rel_relispartition(relid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_rel_tablespace(relid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_rel_persistence(relid: Oid) -> ::std::os::raw::c_char;
}
#[pg_guard]
extern "C" {
    pub fn get_transform_fromsql(typid: Oid, langid: Oid, trftypes: PgPtr<List>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_transform_tosql(typid: Oid, langid: Oid, trftypes: PgPtr<List>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_typisdefined(typid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_typlen(typid: Oid) -> int16;
}
#[pg_guard]
extern "C" {
    pub fn get_typbyval(typid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_typlenbyval(typid: Oid, typlen: PgPtr<int16>, typbyval: PgPtr<bool>);
}
#[pg_guard]
extern "C" {
    pub fn get_typlenbyvalalign(
        typid: Oid,
        typlen: PgPtr<int16>,
        typbyval: PgPtr<bool>,
        typalign: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn getTypeIOParam(typeTuple: PgPtr<HeapTupleData>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_type_io_data(
        typid: Oid,
        which_func: IOFuncSelector,
        typlen: PgPtr<int16>,
        typbyval: PgPtr<bool>,
        typalign: PgPtr<::std::os::raw::c_char>,
        typdelim: PgPtr<::std::os::raw::c_char>,
        typioparam: PgPtr<Oid>,
        func: PgPtr<Oid>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_typstorage(typid: Oid) -> ::std::os::raw::c_char;
}
#[pg_guard]
extern "C" {
    pub fn get_typdefault(typid: Oid) -> PgPtr<Node>;
}
#[pg_guard]
extern "C" {
    pub fn get_typtype(typid: Oid) -> ::std::os::raw::c_char;
}
#[pg_guard]
extern "C" {
    pub fn type_is_rowtype(typid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn type_is_enum(typid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn type_is_range(typid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_type_category_preferred(
        typid: Oid,
        typcategory: PgPtr<::std::os::raw::c_char>,
        typispreferred: PgPtr<bool>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_typ_typrelid(typid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_element_type(typid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_array_type(typid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_promoted_array_type(typid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_base_element_type(typid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn getTypeInputInfo(type_: Oid, typInput: PgPtr<Oid>, typIOParam: PgPtr<Oid>);
}
#[pg_guard]
extern "C" {
    pub fn getTypeOutputInfo(type_: Oid, typOutput: PgPtr<Oid>, typIsVarlena: PgPtr<bool>);
}
#[pg_guard]
extern "C" {
    pub fn getTypeBinaryInputInfo(type_: Oid, typReceive: PgPtr<Oid>, typIOParam: PgPtr<Oid>);
}
#[pg_guard]
extern "C" {
    pub fn getTypeBinaryOutputInfo(type_: Oid, typSend: PgPtr<Oid>, typIsVarlena: PgPtr<bool>);
}
#[pg_guard]
extern "C" {
    pub fn get_typmodin(typid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_typcollation(typid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn type_is_collatable(typid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn getBaseType(typid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn getBaseTypeAndTypmod(typid: Oid, typmod: PgPtr<int32>) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_typavgwidth(typid: Oid, typmod: int32) -> int32;
}
#[pg_guard]
extern "C" {
    pub fn get_attavgwidth(relid: Oid, attnum: AttrNumber) -> int32;
}
#[pg_guard]
extern "C" {
    pub fn get_attstatsslot(
        sslot: PgPtr<AttStatsSlot>,
        statstuple: PgPtr<HeapTupleData>,
        reqkind: ::std::os::raw::c_int,
        reqop: Oid,
        flags: ::std::os::raw::c_int,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn free_attstatsslot(sslot: PgPtr<AttStatsSlot>);
}
#[pg_guard]
extern "C" {
    pub fn get_namespace_name(nspid: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn get_namespace_name_or_temp(nspid: Oid) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn get_range_subtype(rangeOid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_range_collation(rangeOid: Oid) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_index_column_opclass(index_oid: Oid, attno: ::std::os::raw::c_int) -> Oid;
}
#[pg_guard]
extern "C" {
    pub fn get_index_isreplident(index_oid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_index_isvalid(index_oid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_index_isclustered(index_oid: Oid) -> bool;
}
#[repr(C)]
pub struct VariableStatData {
    pub var: PgPtr<Node>,
    pub rel: PgPtr<RelOptInfo>,
    pub statsTuple: PgPtr<HeapTupleData>,
    pub freefunc: ::std::option::Option<unsafe extern "C" fn(tuple: PgPtr<HeapTupleData>)>,
    pub vartype: Oid,
    pub atttype: Oid,
    pub atttypmod: int32,
    pub isunique: bool,
    pub acl_ok: bool,
}
#[repr(C)]
pub struct GenericCosts {
    pub indexStartupCost: Cost,
    pub indexTotalCost: Cost,
    pub indexSelectivity: Selectivity,
    pub indexCorrelation: f64,
    pub numIndexPages: f64,
    pub numIndexTuples: f64,
    pub spc_random_page_cost: f64,
    pub num_sa_scans: f64,
}
pub type get_relation_stats_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        rte: PgPtr<RangeTblEntry>,
        attnum: AttrNumber,
        vardata: PgPtr<VariableStatData>,
    ) -> bool,
>;
#[pg_guard]
extern "C" {
    pub static mut get_relation_stats_hook: get_relation_stats_hook_type;
}
pub type get_index_stats_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: PgPtr<PlannerInfo>,
        indexOid: Oid,
        indexattnum: AttrNumber,
        vardata: PgPtr<VariableStatData>,
    ) -> bool,
>;
#[pg_guard]
extern "C" {
    pub static mut get_index_stats_hook: get_index_stats_hook_type;
}
#[pg_guard]
extern "C" {
    pub fn examine_variable(
        root: PgPtr<PlannerInfo>,
        node: PgPtr<Node>,
        varRelid: ::std::os::raw::c_int,
        vardata: PgPtr<VariableStatData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn statistic_proc_security_check(vardata: PgPtr<VariableStatData>, func_oid: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_restriction_variable(
        root: PgPtr<PlannerInfo>,
        args: PgPtr<List>,
        varRelid: ::std::os::raw::c_int,
        vardata: PgPtr<VariableStatData>,
        other: PgPtr<PgPtr<Node>>,
        varonleft: PgPtr<bool>,
    ) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn get_join_variables(
        root: PgPtr<PlannerInfo>,
        args: PgPtr<List>,
        sjinfo: PgPtr<SpecialJoinInfo>,
        vardata1: PgPtr<VariableStatData>,
        vardata2: PgPtr<VariableStatData>,
        join_is_reversed: PgPtr<bool>,
    );
}
#[pg_guard]
extern "C" {
    pub fn get_variable_numdistinct(
        vardata: PgPtr<VariableStatData>,
        isdefault: PgPtr<bool>,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn mcv_selectivity(
        vardata: PgPtr<VariableStatData>,
        opproc: PgPtr<FmgrInfo>,
        constval: Datum,
        varonleft: bool,
        sumcommonp: PgPtr<f64>,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn mcv_selectivity_ext(
        vardata: PgPtr<VariableStatData>,
        opproc: PgPtr<FmgrInfo>,
        collation: Oid,
        constval: Datum,
        varonleft: bool,
        sumcommonp: PgPtr<f64>,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn histogram_selectivity(
        vardata: PgPtr<VariableStatData>,
        opproc: PgPtr<FmgrInfo>,
        constval: Datum,
        varonleft: bool,
        min_hist_size: ::std::os::raw::c_int,
        n_skip: ::std::os::raw::c_int,
        hist_size: PgPtr<::std::os::raw::c_int>,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn histogram_selectivity_ext(
        vardata: PgPtr<VariableStatData>,
        opproc: PgPtr<FmgrInfo>,
        collation: Oid,
        constval: Datum,
        varonleft: bool,
        min_hist_size: ::std::os::raw::c_int,
        n_skip: ::std::os::raw::c_int,
        hist_size: PgPtr<::std::os::raw::c_int>,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn ineq_histogram_selectivity(
        root: PgPtr<PlannerInfo>,
        vardata: PgPtr<VariableStatData>,
        opproc: PgPtr<FmgrInfo>,
        isgt: bool,
        iseq: bool,
        constval: Datum,
        consttype: Oid,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn ineq_histogram_selectivity_ext(
        root: PgPtr<PlannerInfo>,
        vardata: PgPtr<VariableStatData>,
        opproc: PgPtr<FmgrInfo>,
        isgt: bool,
        iseq: bool,
        collation: Oid,
        constval: Datum,
        consttype: Oid,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn var_eq_const(
        vardata: PgPtr<VariableStatData>,
        oproid: Oid,
        constval: Datum,
        constisnull: bool,
        varonleft: bool,
        negate: bool,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn var_eq_const_ext(
        vardata: PgPtr<VariableStatData>,
        oproid: Oid,
        collation: Oid,
        constval: Datum,
        constisnull: bool,
        varonleft: bool,
        negate: bool,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn var_eq_non_const(
        vardata: PgPtr<VariableStatData>,
        oproid: Oid,
        other: PgPtr<Node>,
        varonleft: bool,
        negate: bool,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn boolvarsel(
        root: PgPtr<PlannerInfo>,
        arg: PgPtr<Node>,
        varRelid: ::std::os::raw::c_int,
    ) -> Selectivity;
}
#[pg_guard]
extern "C" {
    pub fn booltestsel(
        root: PgPtr<PlannerInfo>,
        booltesttype: BoolTestType,
        arg: PgPtr<Node>,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: PgPtr<SpecialJoinInfo>,
    ) -> Selectivity;
}
#[pg_guard]
extern "C" {
    pub fn nulltestsel(
        root: PgPtr<PlannerInfo>,
        nulltesttype: NullTestType,
        arg: PgPtr<Node>,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: PgPtr<SpecialJoinInfo>,
    ) -> Selectivity;
}
#[pg_guard]
extern "C" {
    pub fn scalararraysel(
        root: PgPtr<PlannerInfo>,
        clause: PgPtr<ScalarArrayOpExpr>,
        is_join_clause: bool,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: PgPtr<SpecialJoinInfo>,
    ) -> Selectivity;
}
#[pg_guard]
extern "C" {
    pub fn estimate_array_length(arrayexpr: PgPtr<Node>) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn rowcomparesel(
        root: PgPtr<PlannerInfo>,
        clause: PgPtr<RowCompareExpr>,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: PgPtr<SpecialJoinInfo>,
    ) -> Selectivity;
}
#[pg_guard]
extern "C" {
    pub fn mergejoinscansel(
        root: PgPtr<PlannerInfo>,
        clause: PgPtr<Node>,
        opfamily: Oid,
        strategy: ::std::os::raw::c_int,
        nulls_first: bool,
        leftstart: PgPtr<Selectivity>,
        leftend: PgPtr<Selectivity>,
        rightstart: PgPtr<Selectivity>,
        rightend: PgPtr<Selectivity>,
    );
}
#[pg_guard]
extern "C" {
    pub fn estimate_num_groups(
        root: PgPtr<PlannerInfo>,
        groupExprs: PgPtr<List>,
        input_rows: f64,
        pgset: PgPtr<PgPtr<List>>,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn estimate_hash_bucket_stats(
        root: PgPtr<PlannerInfo>,
        hashkey: PgPtr<Node>,
        nbuckets: f64,
        mcv_freq: PgPtr<Selectivity>,
        bucketsize_frac: PgPtr<Selectivity>,
    );
}
#[pg_guard]
extern "C" {
    pub fn estimate_hashagg_tablesize(
        path: PgPtr<Path>,
        agg_costs: PgPtr<AggClauseCosts>,
        dNumGroups: f64,
    ) -> f64;
}
#[pg_guard]
extern "C" {
    pub fn get_quals_from_indexclauses(indexclauses: PgPtr<List>) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn index_other_operands_eval_cost(
        root: PgPtr<PlannerInfo>,
        indexquals: PgPtr<List>,
    ) -> Cost;
}
#[pg_guard]
extern "C" {
    pub fn add_predicate_to_index_quals(
        index: PgPtr<IndexOptInfo>,
        indexQuals: PgPtr<List>,
    ) -> PgPtr<List>;
}
#[pg_guard]
extern "C" {
    pub fn genericcostestimate(
        root: PgPtr<PlannerInfo>,
        path: PgPtr<IndexPath>,
        loop_count: f64,
        costs: PgPtr<GenericCosts>,
    );
}
#[pg_guard]
extern "C" {
    pub fn scalararraysel_containment(
        root: PgPtr<PlannerInfo>,
        leftop: PgPtr<Node>,
        rightop: PgPtr<Node>,
        elemtype: Oid,
        isEquality: bool,
        useOr: bool,
        varRelid: ::std::os::raw::c_int,
    ) -> Selectivity;
}
#[pg_guard]
extern "C" {
    pub static mut old_snapshot_threshold: ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SnapMgrShmemSize() -> Size;
}
#[pg_guard]
extern "C" {
    pub fn SnapMgrInit();
}
#[pg_guard]
extern "C" {
    pub fn GetSnapshotCurrentTimestamp() -> TimestampTz;
}
#[pg_guard]
extern "C" {
    pub fn GetOldSnapshotThresholdTimestamp() -> TimestampTz;
}
#[pg_guard]
extern "C" {
    pub static mut FirstSnapshotSet: bool;
}
#[pg_guard]
extern "C" {
    pub static mut TransactionXmin: TransactionId;
}
#[pg_guard]
extern "C" {
    pub static mut RecentXmin: TransactionId;
}
#[pg_guard]
extern "C" {
    pub static mut RecentGlobalXmin: TransactionId;
}
#[pg_guard]
extern "C" {
    pub static mut RecentGlobalDataXmin: TransactionId;
}
#[pg_guard]
extern "C" {
    pub static mut SnapshotSelfData: SnapshotData;
}
#[pg_guard]
extern "C" {
    pub static mut SnapshotAnyData: SnapshotData;
}
#[pg_guard]
extern "C" {
    pub static mut CatalogSnapshotData: SnapshotData;
}
#[pg_guard]
extern "C" {
    pub fn GetTransactionSnapshot() -> PgPtr<SnapshotData>;
}
#[pg_guard]
extern "C" {
    pub fn GetLatestSnapshot() -> PgPtr<SnapshotData>;
}
#[pg_guard]
extern "C" {
    pub fn SnapshotSetCommandId(curcid: CommandId);
}
#[pg_guard]
extern "C" {
    pub fn GetOldestSnapshot() -> PgPtr<SnapshotData>;
}
#[pg_guard]
extern "C" {
    pub fn GetCatalogSnapshot(relid: Oid) -> PgPtr<SnapshotData>;
}
#[pg_guard]
extern "C" {
    pub fn GetNonHistoricCatalogSnapshot(relid: Oid) -> PgPtr<SnapshotData>;
}
#[pg_guard]
extern "C" {
    pub fn InvalidateCatalogSnapshot();
}
#[pg_guard]
extern "C" {
    pub fn InvalidateCatalogSnapshotConditionally();
}
#[pg_guard]
extern "C" {
    pub fn PushActiveSnapshot(snapshot: PgPtr<SnapshotData>);
}
#[pg_guard]
extern "C" {
    pub fn PushCopiedSnapshot(snapshot: PgPtr<SnapshotData>);
}
#[pg_guard]
extern "C" {
    pub fn UpdateActiveSnapshotCommandId();
}
#[pg_guard]
extern "C" {
    pub fn PopActiveSnapshot();
}
#[pg_guard]
extern "C" {
    pub fn GetActiveSnapshot() -> PgPtr<SnapshotData>;
}
#[pg_guard]
extern "C" {
    pub fn ActiveSnapshotSet() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn RegisterSnapshot(snapshot: PgPtr<SnapshotData>) -> PgPtr<SnapshotData>;
}
#[pg_guard]
extern "C" {
    pub fn UnregisterSnapshot(snapshot: PgPtr<SnapshotData>);
}
#[pg_guard]
extern "C" {
    pub fn RegisterSnapshotOnOwner(
        snapshot: PgPtr<SnapshotData>,
        owner: PgPtr<ResourceOwnerData>,
    ) -> PgPtr<SnapshotData>;
}
#[pg_guard]
extern "C" {
    pub fn UnregisterSnapshotFromOwner(
        snapshot: PgPtr<SnapshotData>,
        owner: PgPtr<ResourceOwnerData>,
    );
}
#[pg_guard]
extern "C" {
    pub fn GetFullRecentGlobalXmin() -> FullTransactionId;
}
#[pg_guard]
extern "C" {
    pub fn AtSubCommit_Snapshot(level: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn AtSubAbort_Snapshot(level: ::std::os::raw::c_int);
}
#[pg_guard]
extern "C" {
    pub fn AtEOXact_Snapshot(isCommit: bool, resetXmin: bool);
}
#[pg_guard]
extern "C" {
    pub fn ImportSnapshot(idstr: PgPtr<::std::os::raw::c_char>);
}
#[pg_guard]
extern "C" {
    pub fn XactHasExportedSnapshots() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn DeleteAllExportedSnapshotFiles();
}
#[pg_guard]
extern "C" {
    pub fn ThereAreNoPriorRegisteredSnapshots() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn TransactionIdLimitedForOldSnapshots(
        recentXmin: TransactionId,
        relation: PgPtr<RelationData>,
    ) -> TransactionId;
}
#[pg_guard]
extern "C" {
    pub fn MaintainOldSnapshotTimeMapping(whenTaken: TimestampTz, xmin: TransactionId);
}
#[pg_guard]
extern "C" {
    pub fn ExportSnapshot(snapshot: PgPtr<SnapshotData>) -> PgPtr<::std::os::raw::c_char>;
}
#[pg_guard]
extern "C" {
    pub fn XidInMVCCSnapshot(xid: TransactionId, snapshot: PgPtr<SnapshotData>) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn HistoricSnapshotGetTupleCids() -> PgPtr<HTAB>;
}
#[pg_guard]
extern "C" {
    pub fn SetupHistoricSnapshot(snapshot_now: PgPtr<SnapshotData>, tuplecids: PgPtr<HTAB>);
}
#[pg_guard]
extern "C" {
    pub fn TeardownHistoricSnapshot(is_error: bool);
}
#[pg_guard]
extern "C" {
    pub fn HistoricSnapshotActive() -> bool;
}
#[pg_guard]
extern "C" {
    pub fn EstimateSnapshotSpace(snapshot: PgPtr<SnapshotData>) -> Size;
}
#[pg_guard]
extern "C" {
    pub fn SerializeSnapshot(
        snapshot: PgPtr<SnapshotData>,
        start_address: PgPtr<::std::os::raw::c_char>,
    );
}
#[pg_guard]
extern "C" {
    pub fn RestoreSnapshot(start_address: PgPtr<::std::os::raw::c_char>) -> PgPtr<SnapshotData>;
}
#[pg_guard]
extern "C" {
    pub fn RestoreTransactionSnapshot(
        snapshot: PgPtr<SnapshotData>,
        master_pgproc: PgPtr<::std::os::raw::c_void>,
    );
}
#[repr(C)]
pub struct DomainConstraintCache {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct TypeCacheEnumData {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct TypeCacheEntry {
    pub type_id: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub typstorage: ::std::os::raw::c_char,
    pub typtype: ::std::os::raw::c_char,
    pub typrelid: Oid,
    pub typelem: Oid,
    pub typcollation: Oid,
    pub btree_opf: Oid,
    pub btree_opintype: Oid,
    pub hash_opf: Oid,
    pub hash_opintype: Oid,
    pub eq_opr: Oid,
    pub lt_opr: Oid,
    pub gt_opr: Oid,
    pub cmp_proc: Oid,
    pub hash_proc: Oid,
    pub hash_extended_proc: Oid,
    pub eq_opr_finfo: FmgrInfo,
    pub cmp_proc_finfo: FmgrInfo,
    pub hash_proc_finfo: FmgrInfo,
    pub hash_extended_proc_finfo: FmgrInfo,
    pub tupDesc: PgPtr<TupleDescData>,
    pub tupDesc_identifier: uint64,
    pub rngelemtype: PgPtr<TypeCacheEntry>,
    pub rng_collation: Oid,
    pub rng_cmp_proc_finfo: FmgrInfo,
    pub rng_canonical_finfo: FmgrInfo,
    pub rng_subdiff_finfo: FmgrInfo,
    pub domainBaseType: Oid,
    pub domainBaseTypmod: int32,
    pub domainData: PgPtr<DomainConstraintCache>,
    pub flags: ::std::os::raw::c_int,
    pub enumData: PgPtr<TypeCacheEnumData>,
    pub nextDomain: PgPtr<TypeCacheEntry>,
}
#[repr(C)]
pub struct DomainConstraintRef {
    pub constraints: PgPtr<List>,
    pub refctx: PgPtr<MemoryContextData>,
    pub tcache: PgPtr<TypeCacheEntry>,
    pub need_exprstate: bool,
    pub dcc: PgPtr<DomainConstraintCache>,
    pub callback: MemoryContextCallback,
}
#[repr(C)]
pub struct SharedRecordTypmodRegistry {
    _unused: [u8; 0],
}
#[pg_guard]
extern "C" {
    pub fn lookup_type_cache(type_id: Oid, flags: ::std::os::raw::c_int) -> PgPtr<TypeCacheEntry>;
}
#[pg_guard]
extern "C" {
    pub fn InitDomainConstraintRef(
        type_id: Oid,
        ref_: PgPtr<DomainConstraintRef>,
        refctx: PgPtr<MemoryContextData>,
        need_exprstate: bool,
    );
}
#[pg_guard]
extern "C" {
    pub fn UpdateDomainConstraintRef(ref_: PgPtr<DomainConstraintRef>);
}
#[pg_guard]
extern "C" {
    pub fn DomainHasConstraints(type_id: Oid) -> bool;
}
#[pg_guard]
extern "C" {
    pub fn lookup_rowtype_tupdesc(type_id: Oid, typmod: int32) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn lookup_rowtype_tupdesc_noerror(
        type_id: Oid,
        typmod: int32,
        noError: bool,
    ) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn lookup_rowtype_tupdesc_copy(type_id: Oid, typmod: int32) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn lookup_rowtype_tupdesc_domain(
        type_id: Oid,
        typmod: int32,
        noError: bool,
    ) -> PgPtr<TupleDescData>;
}
#[pg_guard]
extern "C" {
    pub fn assign_record_type_typmod(tupDesc: PgPtr<TupleDescData>);
}
#[pg_guard]
extern "C" {
    pub fn assign_record_type_identifier(type_id: Oid, typmod: int32) -> uint64;
}
#[pg_guard]
extern "C" {
    pub fn compare_values_of_enum(
        tcache: PgPtr<TypeCacheEntry>,
        arg1: Oid,
        arg2: Oid,
    ) -> ::std::os::raw::c_int;
}
#[pg_guard]
extern "C" {
    pub fn SharedRecordTypmodRegistryEstimate() -> usize;
}
#[pg_guard]
extern "C" {
    pub fn SharedRecordTypmodRegistryInit(
        arg1: PgPtr<SharedRecordTypmodRegistry>,
        segment: PgPtr<dsm_segment>,
        area: PgPtr<dsa_area>,
    );
}
#[pg_guard]
extern "C" {
    pub fn SharedRecordTypmodRegistryAttach(arg1: PgPtr<SharedRecordTypmodRegistry>);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: PgPtr<::std::os::raw::c_void>,
    pub reg_save_area: PgPtr<::std::os::raw::c_void>,
}
#[repr(C)]
pub struct AttrMissing {
    pub _address: u8,
}
#[repr(C)]
pub struct JitContext {
    pub _address: u8,
}
#[repr(C)]
pub struct JitInstrumentation {
    pub _address: u8,
}
#[repr(C)]
pub struct SharedJitInstrumentation {
    pub _address: u8,
}
#[repr(C)]
pub struct PartitionTupleRouting {
    pub _address: u8,
}
#[repr(C)]
pub struct binaryheap {
    pub _address: u8,
}
#[repr(C)]
pub struct TsmRoutine {
    pub _address: u8,
}
#[repr(C)]
pub struct TableFuncRoutine {
    pub _address: u8,
}
#[repr(C)]
pub struct WindowObjectData {
    pub _address: u8,
}
#[repr(C)]
pub struct ParallelExecutorInfo {
    pub _address: u8,
}
#[repr(C)]
pub struct TupleQueueReader {
    pub _address: u8,
}
#[repr(C)]
pub struct ResourceOwnerData {
    pub _address: u8,
}
#[repr(C)]
pub struct SMgrRelationData {
    pub _address: u8,
}
#[repr(C)]
pub struct RowSecurityDesc {
    pub _address: u8,
}
impl New for PgPtr<sigval> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sigval>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sigval>()) }
    }
}
impl New for PgPtr<sigevent> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sigevent>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sigevent>()) }
    }
}
impl New for PgPtr<sigaction> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sigaction>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sigaction>()) }
    }
}
impl New for PgPtr<sigvec> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sigvec>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sigvec>()) }
    }
}
impl New for PgPtr<sigstack> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sigstack>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sigstack>()) }
    }
}
impl New for PgPtr<timeval> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<timeval>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<timeval>()) }
    }
}
impl New for PgPtr<rusage> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<rusage>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<rusage>()) }
    }
}
impl New for PgPtr<rusage_info_v0> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<rusage_info_v0>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<rusage_info_v0>()) }
    }
}
impl New for PgPtr<rusage_info_v1> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<rusage_info_v1>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<rusage_info_v1>()) }
    }
}
impl New for PgPtr<rusage_info_v2> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<rusage_info_v2>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<rusage_info_v2>()) }
    }
}
impl New for PgPtr<rusage_info_v3> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<rusage_info_v3>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<rusage_info_v3>()) }
    }
}
impl New for PgPtr<rusage_info_v4> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<rusage_info_v4>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<rusage_info_v4>()) }
    }
}
impl New for PgPtr<rlimit> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<rlimit>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<rlimit>()) }
    }
}
impl New for PgPtr<proc_rlimit_control_wakeupmon> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<proc_rlimit_control_wakeupmon>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<proc_rlimit_control_wakeupmon>()) }
    }
}
impl New for PgPtr<wait> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<wait>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<wait>()) }
    }
}
impl New for PgPtr<wait__bindgen_ty_1> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<wait__bindgen_ty_1>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<wait__bindgen_ty_1>()) }
    }
}
impl New for PgPtr<wait__bindgen_ty_2> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<wait__bindgen_ty_2>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<wait__bindgen_ty_2>()) }
    }
}
impl New for PgPtr<div_t> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<div_t>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<div_t>()) }
    }
}
impl New for PgPtr<ldiv_t> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ldiv_t>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ldiv_t>()) }
    }
}
impl New for PgPtr<lldiv_t> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<lldiv_t>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<lldiv_t>()) }
    }
}
impl New for PgPtr<fd_set> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<fd_set>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<fd_set>()) }
    }
}
impl New for PgPtr<lconv> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<lconv>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<lconv>()) }
    }
}
impl New for PgPtr<IntArray> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IntArray>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IntArray>()) }
    }
}
impl New for PgPtr<varlena> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<varlena>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<varlena>()) }
    }
}
impl New for PgPtr<int2vector> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<int2vector>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<int2vector>()) }
    }
}
impl New for PgPtr<oidvector> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<oidvector>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<oidvector>()) }
    }
}
impl New for PgPtr<nameData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<nameData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<nameData>()) }
    }
}
impl New for PgPtr<PGAlignedBlock> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PGAlignedBlock>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PGAlignedBlock>()) }
    }
}
impl New for PgPtr<PGAlignedXLogBlock> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PGAlignedXLogBlock>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PGAlignedXLogBlock>()) }
    }
}
impl New for PgPtr<iovec> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<iovec>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<iovec>()) }
    }
}
impl New for PgPtr<sa_endpoints> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sa_endpoints>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sa_endpoints>()) }
    }
}
impl New for PgPtr<linger> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<linger>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<linger>()) }
    }
}
impl New for PgPtr<so_np_extensions> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<so_np_extensions>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<so_np_extensions>()) }
    }
}
impl New for PgPtr<sockaddr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sockaddr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sockaddr>()) }
    }
}
impl New for PgPtr<sockproto> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sockproto>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sockproto>()) }
    }
}
impl New for PgPtr<sockaddr_storage> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sockaddr_storage>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sockaddr_storage>()) }
    }
}
impl New for PgPtr<msghdr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<msghdr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<msghdr>()) }
    }
}
impl New for PgPtr<cmsghdr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<cmsghdr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<cmsghdr>()) }
    }
}
impl New for PgPtr<sf_hdtr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sf_hdtr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sf_hdtr>()) }
    }
}
impl New for PgPtr<in_addr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<in_addr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<in_addr>()) }
    }
}
impl New for PgPtr<sockaddr_in> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sockaddr_in>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sockaddr_in>()) }
    }
}
impl New for PgPtr<ip_opts> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ip_opts>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ip_opts>()) }
    }
}
impl New for PgPtr<ip_mreq> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ip_mreq>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ip_mreq>()) }
    }
}
impl New for PgPtr<ip_mreqn> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ip_mreqn>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ip_mreqn>()) }
    }
}
impl New for PgPtr<ip_mreq_source> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ip_mreq_source>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ip_mreq_source>()) }
    }
}
impl New for PgPtr<group_req> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<group_req>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<group_req>()) }
    }
}
impl New for PgPtr<group_source_req> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<group_source_req>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<group_source_req>()) }
    }
}
impl New for PgPtr<in_pktinfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<in_pktinfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<in_pktinfo>()) }
    }
}
impl New for PgPtr<in6_addr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<in6_addr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<in6_addr>()) }
    }
}
impl New for PgPtr<in6_addr__bindgen_ty_1> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<in6_addr__bindgen_ty_1>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<in6_addr__bindgen_ty_1>()) }
    }
}
impl New for PgPtr<sockaddr_in6> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sockaddr_in6>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sockaddr_in6>()) }
    }
}
impl New for PgPtr<ipv6_mreq> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ipv6_mreq>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ipv6_mreq>()) }
    }
}
impl New for PgPtr<in6_pktinfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<in6_pktinfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<in6_pktinfo>()) }
    }
}
impl New for PgPtr<ip6_mtuinfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ip6_mtuinfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ip6_mtuinfo>()) }
    }
}
impl New for PgPtr<hostent> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<hostent>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<hostent>()) }
    }
}
impl New for PgPtr<netent> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<netent>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<netent>()) }
    }
}
impl New for PgPtr<servent> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<servent>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<servent>()) }
    }
}
impl New for PgPtr<protoent> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<protoent>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<protoent>()) }
    }
}
impl New for PgPtr<addrinfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<addrinfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<addrinfo>()) }
    }
}
impl New for PgPtr<rpcent> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<rpcent>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<rpcent>()) }
    }
}
impl New for PgPtr<passwd> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<passwd>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<passwd>()) }
    }
}
impl New for PgPtr<exception> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<exception>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<exception>()) }
    }
}
impl New for PgPtr<ErrorContextCallback> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ErrorContextCallback>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ErrorContextCallback>()) }
    }
}
impl New for PgPtr<ErrorData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ErrorData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ErrorData>()) }
    }
}
impl New for PgPtr<MemoryContextCallback> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MemoryContextCallback>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MemoryContextCallback>()) }
    }
}
impl New for PgPtr<varatt_external> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<varatt_external>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<varatt_external>()) }
    }
}
impl New for PgPtr<varatt_indirect> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<varatt_indirect>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<varatt_indirect>()) }
    }
}
impl New for PgPtr<varatt_expanded> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<varatt_expanded>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<varatt_expanded>()) }
    }
}
impl New for PgPtr<varattrib_4b> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<varattrib_4b>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<varattrib_4b>()) }
    }
}
impl New for PgPtr<varattrib_4b__bindgen_ty_1> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<varattrib_4b__bindgen_ty_1>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<varattrib_4b__bindgen_ty_1>()) }
    }
}
impl New for PgPtr<varattrib_4b__bindgen_ty_2> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<varattrib_4b__bindgen_ty_2>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<varattrib_4b__bindgen_ty_2>()) }
    }
}
impl New for PgPtr<varattrib_1b> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<varattrib_1b>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<varattrib_1b>()) }
    }
}
impl New for PgPtr<varattrib_1b_e> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<varattrib_1b_e>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<varattrib_1b_e>()) }
    }
}
impl New for PgPtr<NullableDatum> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<NullableDatum>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<NullableDatum>()) }
    }
}
impl New for PgPtr<FmgrInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FmgrInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FmgrInfo>()) }
    }
}
impl New for PgPtr<FunctionCallInfoBaseData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FunctionCallInfoBaseData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FunctionCallInfoBaseData>()) }
    }
}
impl New for PgPtr<Pg_finfo_record> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Pg_finfo_record>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Pg_finfo_record>()) }
    }
}
impl New for PgPtr<Pg_magic_struct> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Pg_magic_struct>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Pg_magic_struct>()) }
    }
}
impl New for PgPtr<FormData_pg_attribute> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FormData_pg_attribute>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FormData_pg_attribute>()) }
    }
}
impl New for PgPtr<Node> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Node>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Node>()) }
    }
}
impl New for PgPtr<ListCell> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ListCell>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ListCell>()) }
    }
}
impl New for PgPtr<ListCell__bindgen_ty_1> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ListCell__bindgen_ty_1>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ListCell__bindgen_ty_1>()) }
    }
}
impl New for PgPtr<AttrDefault> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AttrDefault>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AttrDefault>()) }
    }
}
impl New for PgPtr<ConstrCheck> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ConstrCheck>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ConstrCheck>()) }
    }
}
impl New for PgPtr<TupleConstr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TupleConstr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TupleConstr>()) }
    }
}
impl New for PgPtr<TupleDescData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TupleDescData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TupleDescData>()) }
    }
}
impl New for PgPtr<BlockIdData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BlockIdData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BlockIdData>()) }
    }
}
impl New for PgPtr<ItemIdData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ItemIdData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ItemIdData>()) }
    }
}
impl New for PgPtr<ItemPointerData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ItemPointerData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ItemPointerData>()) }
    }
}
impl New for PgPtr<HeapTupleData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HeapTupleData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HeapTupleData>()) }
    }
}
impl New for PgPtr<flock> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<flock>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<flock>()) }
    }
}
impl New for PgPtr<timespec> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<timespec>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<timespec>()) }
    }
}
impl New for PgPtr<flocktimeout> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<flocktimeout>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<flocktimeout>()) }
    }
}
impl New for PgPtr<radvisory> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<radvisory>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<radvisory>()) }
    }
}
impl New for PgPtr<fcodeblobs> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<fcodeblobs>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<fcodeblobs>()) }
    }
}
impl New for PgPtr<fsignatures> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<fsignatures>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<fsignatures>()) }
    }
}
impl New for PgPtr<fchecklv> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<fchecklv>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<fchecklv>()) }
    }
}
impl New for PgPtr<fstore> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<fstore>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<fstore>()) }
    }
}
impl New for PgPtr<fpunchhole> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<fpunchhole>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<fpunchhole>()) }
    }
}
impl New for PgPtr<ftrimactivefile> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ftrimactivefile>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ftrimactivefile>()) }
    }
}
impl New for PgPtr<fspecread> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<fspecread>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<fspecread>()) }
    }
}
impl New for PgPtr<fbootstraptransfer> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<fbootstraptransfer>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<fbootstraptransfer>()) }
    }
}
impl New for PgPtr<log2phys> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<log2phys>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<log2phys>()) }
    }
}
impl New for PgPtr<FullTransactionId> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FullTransactionId>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FullTransactionId>()) }
    }
}
impl New for PgPtr<VariableCacheData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<VariableCacheData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<VariableCacheData>()) }
    }
}
impl New for PgPtr<PageXLogRecPtr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PageXLogRecPtr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PageXLogRecPtr>()) }
    }
}
impl New for PgPtr<PageHeaderData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PageHeaderData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PageHeaderData>()) }
    }
}
impl New for PgPtr<HeapTupleFields> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HeapTupleFields>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HeapTupleFields>()) }
    }
}
impl New for PgPtr<HeapTupleFields__bindgen_ty_1> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HeapTupleFields__bindgen_ty_1>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HeapTupleFields__bindgen_ty_1>()) }
    }
}
impl New for PgPtr<DatumTupleFields> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DatumTupleFields>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DatumTupleFields>()) }
    }
}
impl New for PgPtr<HeapTupleHeaderData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HeapTupleHeaderData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HeapTupleHeaderData>()) }
    }
}
impl New for PgPtr<HeapTupleHeaderData__bindgen_ty_1> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HeapTupleHeaderData__bindgen_ty_1>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HeapTupleHeaderData__bindgen_ty_1>()) }
    }
}
impl New for PgPtr<MinimalTupleData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MinimalTupleData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MinimalTupleData>()) }
    }
}
impl New for PgPtr<BufferAccessStrategyData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BufferAccessStrategyData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BufferAccessStrategyData>()) }
    }
}
impl New for PgPtr<TupleTableSlot> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TupleTableSlot>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TupleTableSlot>()) }
    }
}
impl New for PgPtr<TupleTableSlotOps> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TupleTableSlotOps>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TupleTableSlotOps>()) }
    }
}
impl New for PgPtr<VirtualTupleTableSlot> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<VirtualTupleTableSlot>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<VirtualTupleTableSlot>()) }
    }
}
impl New for PgPtr<HeapTupleTableSlot> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HeapTupleTableSlot>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HeapTupleTableSlot>()) }
    }
}
impl New for PgPtr<BufferHeapTupleTableSlot> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BufferHeapTupleTableSlot>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BufferHeapTupleTableSlot>()) }
    }
}
impl New for PgPtr<MinimalTupleTableSlot> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MinimalTupleTableSlot>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MinimalTupleTableSlot>()) }
    }
}
impl New for PgPtr<TupleConversionMap> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TupleConversionMap>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TupleConversionMap>()) }
    }
}
impl New for PgPtr<tm> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<tm>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<tm>()) }
    }
}
impl New for PgPtr<BufferUsage> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BufferUsage>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BufferUsage>()) }
    }
}
impl New for PgPtr<Instrumentation> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Instrumentation>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Instrumentation>()) }
    }
}
impl New for PgPtr<WorkerInstrumentation> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WorkerInstrumentation>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WorkerInstrumentation>()) }
    }
}
impl New for PgPtr<StringInfoData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<StringInfoData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<StringInfoData>()) }
    }
}
impl New for PgPtr<pairingheap_node> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<pairingheap_node>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<pairingheap_node>()) }
    }
}
impl New for PgPtr<pairingheap> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<pairingheap>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<pairingheap>()) }
    }
}
impl New for PgPtr<ParamExternData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParamExternData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParamExternData>()) }
    }
}
impl New for PgPtr<ParamListInfoData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParamListInfoData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParamListInfoData>()) }
    }
}
impl New for PgPtr<ParamExecData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParamExecData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParamExecData>()) }
    }
}
impl New for PgPtr<Bitmapset> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Bitmapset>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Bitmapset>()) }
    }
}
impl New for PgPtr<Alias> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Alias>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Alias>()) }
    }
}
impl New for PgPtr<RangeVar> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RangeVar>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RangeVar>()) }
    }
}
impl New for PgPtr<TableFunc> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TableFunc>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TableFunc>()) }
    }
}
impl New for PgPtr<IntoClause> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IntoClause>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IntoClause>()) }
    }
}
impl New for PgPtr<Expr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Expr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Expr>()) }
    }
}
impl New for PgPtr<Var> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Var>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Var>()) }
    }
}
impl New for PgPtr<Const> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Const>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Const>()) }
    }
}
impl New for PgPtr<Param> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Param>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Param>()) }
    }
}
impl New for PgPtr<Aggref> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Aggref>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Aggref>()) }
    }
}
impl New for PgPtr<GroupingFunc> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GroupingFunc>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GroupingFunc>()) }
    }
}
impl New for PgPtr<WindowFunc> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WindowFunc>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WindowFunc>()) }
    }
}
impl New for PgPtr<SubscriptingRef> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SubscriptingRef>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SubscriptingRef>()) }
    }
}
impl New for PgPtr<FuncExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FuncExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FuncExpr>()) }
    }
}
impl New for PgPtr<NamedArgExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<NamedArgExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<NamedArgExpr>()) }
    }
}
impl New for PgPtr<OpExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<OpExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<OpExpr>()) }
    }
}
impl New for PgPtr<ScalarArrayOpExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ScalarArrayOpExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ScalarArrayOpExpr>()) }
    }
}
impl New for PgPtr<BoolExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BoolExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BoolExpr>()) }
    }
}
impl New for PgPtr<SubLink> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SubLink>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SubLink>()) }
    }
}
impl New for PgPtr<SubPlan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SubPlan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SubPlan>()) }
    }
}
impl New for PgPtr<AlternativeSubPlan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlternativeSubPlan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlternativeSubPlan>()) }
    }
}
impl New for PgPtr<FieldSelect> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FieldSelect>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FieldSelect>()) }
    }
}
impl New for PgPtr<FieldStore> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FieldStore>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FieldStore>()) }
    }
}
impl New for PgPtr<RelabelType> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RelabelType>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RelabelType>()) }
    }
}
impl New for PgPtr<CoerceViaIO> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CoerceViaIO>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CoerceViaIO>()) }
    }
}
impl New for PgPtr<ArrayCoerceExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ArrayCoerceExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ArrayCoerceExpr>()) }
    }
}
impl New for PgPtr<ConvertRowtypeExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ConvertRowtypeExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ConvertRowtypeExpr>()) }
    }
}
impl New for PgPtr<CollateExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CollateExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CollateExpr>()) }
    }
}
impl New for PgPtr<CaseExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CaseExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CaseExpr>()) }
    }
}
impl New for PgPtr<CaseWhen> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CaseWhen>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CaseWhen>()) }
    }
}
impl New for PgPtr<CaseTestExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CaseTestExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CaseTestExpr>()) }
    }
}
impl New for PgPtr<ArrayExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ArrayExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ArrayExpr>()) }
    }
}
impl New for PgPtr<RowExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RowExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RowExpr>()) }
    }
}
impl New for PgPtr<RowCompareExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RowCompareExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RowCompareExpr>()) }
    }
}
impl New for PgPtr<CoalesceExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CoalesceExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CoalesceExpr>()) }
    }
}
impl New for PgPtr<MinMaxExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MinMaxExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MinMaxExpr>()) }
    }
}
impl New for PgPtr<SQLValueFunction> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SQLValueFunction>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SQLValueFunction>()) }
    }
}
impl New for PgPtr<XmlExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<XmlExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<XmlExpr>()) }
    }
}
impl New for PgPtr<NullTest> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<NullTest>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<NullTest>()) }
    }
}
impl New for PgPtr<BooleanTest> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BooleanTest>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BooleanTest>()) }
    }
}
impl New for PgPtr<CoerceToDomain> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CoerceToDomain>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CoerceToDomain>()) }
    }
}
impl New for PgPtr<CoerceToDomainValue> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CoerceToDomainValue>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CoerceToDomainValue>()) }
    }
}
impl New for PgPtr<SetToDefault> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SetToDefault>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SetToDefault>()) }
    }
}
impl New for PgPtr<CurrentOfExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CurrentOfExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CurrentOfExpr>()) }
    }
}
impl New for PgPtr<NextValueExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<NextValueExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<NextValueExpr>()) }
    }
}
impl New for PgPtr<InferenceElem> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<InferenceElem>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<InferenceElem>()) }
    }
}
impl New for PgPtr<TargetEntry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TargetEntry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TargetEntry>()) }
    }
}
impl New for PgPtr<RangeTblRef> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RangeTblRef>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RangeTblRef>()) }
    }
}
impl New for PgPtr<JoinExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JoinExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JoinExpr>()) }
    }
}
impl New for PgPtr<FromExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FromExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FromExpr>()) }
    }
}
impl New for PgPtr<OnConflictExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<OnConflictExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<OnConflictExpr>()) }
    }
}
impl New for PgPtr<PlannedStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PlannedStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PlannedStmt>()) }
    }
}
impl New for PgPtr<Plan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Plan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Plan>()) }
    }
}
impl New for PgPtr<Result> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Result>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Result>()) }
    }
}
impl New for PgPtr<ProjectSet> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ProjectSet>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ProjectSet>()) }
    }
}
impl New for PgPtr<ModifyTable> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ModifyTable>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ModifyTable>()) }
    }
}
impl New for PgPtr<Append> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Append>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Append>()) }
    }
}
impl New for PgPtr<MergeAppend> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MergeAppend>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MergeAppend>()) }
    }
}
impl New for PgPtr<RecursiveUnion> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RecursiveUnion>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RecursiveUnion>()) }
    }
}
impl New for PgPtr<BitmapAnd> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BitmapAnd>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BitmapAnd>()) }
    }
}
impl New for PgPtr<BitmapOr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BitmapOr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BitmapOr>()) }
    }
}
impl New for PgPtr<Scan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Scan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Scan>()) }
    }
}
impl New for PgPtr<SampleScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SampleScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SampleScan>()) }
    }
}
impl New for PgPtr<IndexScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexScan>()) }
    }
}
impl New for PgPtr<IndexOnlyScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexOnlyScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexOnlyScan>()) }
    }
}
impl New for PgPtr<BitmapIndexScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BitmapIndexScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BitmapIndexScan>()) }
    }
}
impl New for PgPtr<BitmapHeapScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BitmapHeapScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BitmapHeapScan>()) }
    }
}
impl New for PgPtr<TidScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TidScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TidScan>()) }
    }
}
impl New for PgPtr<SubqueryScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SubqueryScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SubqueryScan>()) }
    }
}
impl New for PgPtr<FunctionScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FunctionScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FunctionScan>()) }
    }
}
impl New for PgPtr<ValuesScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ValuesScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ValuesScan>()) }
    }
}
impl New for PgPtr<TableFuncScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TableFuncScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TableFuncScan>()) }
    }
}
impl New for PgPtr<CteScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CteScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CteScan>()) }
    }
}
impl New for PgPtr<NamedTuplestoreScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<NamedTuplestoreScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<NamedTuplestoreScan>()) }
    }
}
impl New for PgPtr<WorkTableScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WorkTableScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WorkTableScan>()) }
    }
}
impl New for PgPtr<ForeignScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ForeignScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ForeignScan>()) }
    }
}
impl New for PgPtr<CustomScan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CustomScan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CustomScan>()) }
    }
}
impl New for PgPtr<Join> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Join>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Join>()) }
    }
}
impl New for PgPtr<NestLoop> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<NestLoop>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<NestLoop>()) }
    }
}
impl New for PgPtr<NestLoopParam> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<NestLoopParam>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<NestLoopParam>()) }
    }
}
impl New for PgPtr<MergeJoin> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MergeJoin>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MergeJoin>()) }
    }
}
impl New for PgPtr<HashJoin> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HashJoin>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HashJoin>()) }
    }
}
impl New for PgPtr<Material> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Material>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Material>()) }
    }
}
impl New for PgPtr<Sort> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Sort>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Sort>()) }
    }
}
impl New for PgPtr<Group> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Group>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Group>()) }
    }
}
impl New for PgPtr<Agg> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Agg>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Agg>()) }
    }
}
impl New for PgPtr<WindowAgg> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WindowAgg>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WindowAgg>()) }
    }
}
impl New for PgPtr<Unique> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Unique>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Unique>()) }
    }
}
impl New for PgPtr<Gather> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Gather>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Gather>()) }
    }
}
impl New for PgPtr<GatherMerge> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GatherMerge>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GatherMerge>()) }
    }
}
impl New for PgPtr<Hash> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Hash>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Hash>()) }
    }
}
impl New for PgPtr<SetOp> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SetOp>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SetOp>()) }
    }
}
impl New for PgPtr<LockRows> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LockRows>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LockRows>()) }
    }
}
impl New for PgPtr<Limit> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Limit>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Limit>()) }
    }
}
impl New for PgPtr<PlanRowMark> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PlanRowMark>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PlanRowMark>()) }
    }
}
impl New for PgPtr<PartitionPruneInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionPruneInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionPruneInfo>()) }
    }
}
impl New for PgPtr<PartitionedRelPruneInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionedRelPruneInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionedRelPruneInfo>()) }
    }
}
impl New for PgPtr<PartitionPruneStep> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionPruneStep>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionPruneStep>()) }
    }
}
impl New for PgPtr<PartitionPruneStepOp> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionPruneStepOp>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionPruneStepOp>()) }
    }
}
impl New for PgPtr<PartitionPruneStepCombine> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionPruneStepCombine>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionPruneStepCombine>()) }
    }
}
impl New for PgPtr<PlanInvalItem> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PlanInvalItem>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PlanInvalItem>()) }
    }
}
impl New for PgPtr<PartitionBoundInfoData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionBoundInfoData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionBoundInfoData>()) }
    }
}
impl New for PgPtr<PartitionKeyData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionKeyData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionKeyData>()) }
    }
}
impl New for PgPtr<PartitionDescData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionDescData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionDescData>()) }
    }
}
impl New for PgPtr<PartitionDirectoryData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionDirectoryData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionDirectoryData>()) }
    }
}
impl New for PgPtr<HASHELEMENT> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HASHELEMENT>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HASHELEMENT>()) }
    }
}
impl New for PgPtr<HASHHDR> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HASHHDR>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HASHHDR>()) }
    }
}
impl New for PgPtr<HTAB> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HTAB>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HTAB>()) }
    }
}
impl New for PgPtr<HASHCTL> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HASHCTL>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HASHCTL>()) }
    }
}
impl New for PgPtr<HASH_SEQ_STATUS> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HASH_SEQ_STATUS>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HASH_SEQ_STATUS>()) }
    }
}
impl New for PgPtr<EphemeralNamedRelationMetadataData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<EphemeralNamedRelationMetadataData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<EphemeralNamedRelationMetadataData>()) }
    }
}
impl New for PgPtr<EphemeralNamedRelationData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<EphemeralNamedRelationData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<EphemeralNamedRelationData>()) }
    }
}
impl New for PgPtr<QueryEnvironment> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<QueryEnvironment>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<QueryEnvironment>()) }
    }
}
impl New for PgPtr<Trigger> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Trigger>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Trigger>()) }
    }
}
impl New for PgPtr<TriggerDesc> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TriggerDesc>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TriggerDesc>()) }
    }
}
impl New for PgPtr<dirent> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<dirent>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<dirent>()) }
    }
}
impl New for PgPtr<DIR> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DIR>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DIR>()) }
    }
}
impl New for PgPtr<dsm_segment> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<dsm_segment>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<dsm_segment>()) }
    }
}
impl New for PgPtr<PGShmemHeader> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PGShmemHeader>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PGShmemHeader>()) }
    }
}
impl New for PgPtr<SpinDelayStatus> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SpinDelayStatus>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SpinDelayStatus>()) }
    }
}
impl New for PgPtr<SharedFileSet> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedFileSet>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedFileSet>()) }
    }
}
impl New for PgPtr<SharedTuplestore> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedTuplestore>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedTuplestore>()) }
    }
}
impl New for PgPtr<SharedTuplestoreAccessor> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedTuplestoreAccessor>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedTuplestoreAccessor>()) }
    }
}
impl New for PgPtr<Interval> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Interval>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Interval>()) }
    }
}
impl New for PgPtr<SnapshotData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SnapshotData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SnapshotData>()) }
    }
}
impl New for PgPtr<SortSupportData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SortSupportData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SortSupportData>()) }
    }
}
impl New for PgPtr<Tuplestorestate> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Tuplestorestate>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Tuplestorestate>()) }
    }
}
impl New for PgPtr<IndexTupleData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexTupleData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexTupleData>()) }
    }
}
impl New for PgPtr<IndexAttributeBitMapData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexAttributeBitMapData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexAttributeBitMapData>()) }
    }
}
impl New for PgPtr<Tuplesortstate> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Tuplesortstate>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Tuplesortstate>()) }
    }
}
impl New for PgPtr<Sharedsort> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Sharedsort>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Sharedsort>()) }
    }
}
impl New for PgPtr<SortCoordinateData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SortCoordinateData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SortCoordinateData>()) }
    }
}
impl New for PgPtr<TuplesortInstrumentation> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TuplesortInstrumentation>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TuplesortInstrumentation>()) }
    }
}
impl New for PgPtr<pg_atomic_flag> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<pg_atomic_flag>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<pg_atomic_flag>()) }
    }
}
impl New for PgPtr<pg_atomic_uint32> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<pg_atomic_uint32>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<pg_atomic_uint32>()) }
    }
}
impl New for PgPtr<pg_atomic_uint64> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<pg_atomic_uint64>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<pg_atomic_uint64>()) }
    }
}
impl New for PgPtr<dsa_area> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<dsa_area>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<dsa_area>()) }
    }
}
impl New for PgPtr<TIDBitmap> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TIDBitmap>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TIDBitmap>()) }
    }
}
impl New for PgPtr<TBMIterator> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TBMIterator>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TBMIterator>()) }
    }
}
impl New for PgPtr<TBMSharedIterator> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TBMSharedIterator>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TBMSharedIterator>()) }
    }
}
impl New for PgPtr<TBMIterateResult> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TBMIterateResult>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TBMIterateResult>()) }
    }
}
impl New for PgPtr<proclist_node> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<proclist_node>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<proclist_node>()) }
    }
}
impl New for PgPtr<proclist_head> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<proclist_head>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<proclist_head>()) }
    }
}
impl New for PgPtr<proclist_mutable_iter> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<proclist_mutable_iter>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<proclist_mutable_iter>()) }
    }
}
impl New for PgPtr<ConditionVariable> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ConditionVariable>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ConditionVariable>()) }
    }
}
impl New for PgPtr<PartitionRoutingInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionRoutingInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionRoutingInfo>()) }
    }
}
impl New for PgPtr<ParallelHashJoinState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParallelHashJoinState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParallelHashJoinState>()) }
    }
}
impl New for PgPtr<ExprEvalStep> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExprEvalStep>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExprEvalStep>()) }
    }
}
impl New for PgPtr<CopyMultiInsertBuffer> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CopyMultiInsertBuffer>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CopyMultiInsertBuffer>()) }
    }
}
impl New for PgPtr<ExprState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExprState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExprState>()) }
    }
}
impl New for PgPtr<IndexInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexInfo>()) }
    }
}
impl New for PgPtr<ExprContext_CB> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExprContext_CB>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExprContext_CB>()) }
    }
}
impl New for PgPtr<ExprContext> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExprContext>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExprContext>()) }
    }
}
impl New for PgPtr<ReturnSetInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ReturnSetInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ReturnSetInfo>()) }
    }
}
impl New for PgPtr<ProjectionInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ProjectionInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ProjectionInfo>()) }
    }
}
impl New for PgPtr<JunkFilter> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JunkFilter>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JunkFilter>()) }
    }
}
impl New for PgPtr<OnConflictSetState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<OnConflictSetState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<OnConflictSetState>()) }
    }
}
impl New for PgPtr<ResultRelInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ResultRelInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ResultRelInfo>()) }
    }
}
impl New for PgPtr<EState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<EState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<EState>()) }
    }
}
impl New for PgPtr<ExecRowMark> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExecRowMark>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExecRowMark>()) }
    }
}
impl New for PgPtr<ExecAuxRowMark> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExecAuxRowMark>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExecAuxRowMark>()) }
    }
}
impl New for PgPtr<TupleHashEntryData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TupleHashEntryData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TupleHashEntryData>()) }
    }
}
impl New for PgPtr<tuplehash_hash> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<tuplehash_hash>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<tuplehash_hash>()) }
    }
}
impl New for PgPtr<tuplehash_iterator> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<tuplehash_iterator>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<tuplehash_iterator>()) }
    }
}
impl New for PgPtr<TupleHashTableData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TupleHashTableData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TupleHashTableData>()) }
    }
}
impl New for PgPtr<AggrefExprState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AggrefExprState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AggrefExprState>()) }
    }
}
impl New for PgPtr<WindowFuncExprState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WindowFuncExprState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WindowFuncExprState>()) }
    }
}
impl New for PgPtr<SetExprState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SetExprState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SetExprState>()) }
    }
}
impl New for PgPtr<SubPlanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SubPlanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SubPlanState>()) }
    }
}
impl New for PgPtr<AlternativeSubPlanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlternativeSubPlanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlternativeSubPlanState>()) }
    }
}
impl New for PgPtr<DomainConstraintState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DomainConstraintState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DomainConstraintState>()) }
    }
}
impl New for PgPtr<PlanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PlanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PlanState>()) }
    }
}
impl New for PgPtr<EPQState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<EPQState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<EPQState>()) }
    }
}
impl New for PgPtr<ResultState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ResultState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ResultState>()) }
    }
}
impl New for PgPtr<ProjectSetState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ProjectSetState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ProjectSetState>()) }
    }
}
impl New for PgPtr<ModifyTableState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ModifyTableState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ModifyTableState>()) }
    }
}
impl New for PgPtr<ParallelAppendState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParallelAppendState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParallelAppendState>()) }
    }
}
impl New for PgPtr<PartitionPruneState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionPruneState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionPruneState>()) }
    }
}
impl New for PgPtr<AppendState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AppendState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AppendState>()) }
    }
}
impl New for PgPtr<MergeAppendState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MergeAppendState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MergeAppendState>()) }
    }
}
impl New for PgPtr<RecursiveUnionState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RecursiveUnionState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RecursiveUnionState>()) }
    }
}
impl New for PgPtr<BitmapAndState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BitmapAndState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BitmapAndState>()) }
    }
}
impl New for PgPtr<BitmapOrState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BitmapOrState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BitmapOrState>()) }
    }
}
impl New for PgPtr<ScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ScanState>()) }
    }
}
impl New for PgPtr<SeqScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SeqScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SeqScanState>()) }
    }
}
impl New for PgPtr<SampleScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SampleScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SampleScanState>()) }
    }
}
impl New for PgPtr<IndexRuntimeKeyInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexRuntimeKeyInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexRuntimeKeyInfo>()) }
    }
}
impl New for PgPtr<IndexArrayKeyInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexArrayKeyInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexArrayKeyInfo>()) }
    }
}
impl New for PgPtr<IndexScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexScanState>()) }
    }
}
impl New for PgPtr<IndexOnlyScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexOnlyScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexOnlyScanState>()) }
    }
}
impl New for PgPtr<BitmapIndexScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BitmapIndexScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BitmapIndexScanState>()) }
    }
}
impl New for PgPtr<ParallelBitmapHeapState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParallelBitmapHeapState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParallelBitmapHeapState>()) }
    }
}
impl New for PgPtr<BitmapHeapScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BitmapHeapScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BitmapHeapScanState>()) }
    }
}
impl New for PgPtr<TidScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TidScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TidScanState>()) }
    }
}
impl New for PgPtr<SubqueryScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SubqueryScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SubqueryScanState>()) }
    }
}
impl New for PgPtr<FunctionScanPerFuncState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FunctionScanPerFuncState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FunctionScanPerFuncState>()) }
    }
}
impl New for PgPtr<FunctionScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FunctionScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FunctionScanState>()) }
    }
}
impl New for PgPtr<ValuesScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ValuesScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ValuesScanState>()) }
    }
}
impl New for PgPtr<TableFuncScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TableFuncScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TableFuncScanState>()) }
    }
}
impl New for PgPtr<CteScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CteScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CteScanState>()) }
    }
}
impl New for PgPtr<NamedTuplestoreScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<NamedTuplestoreScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<NamedTuplestoreScanState>()) }
    }
}
impl New for PgPtr<WorkTableScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WorkTableScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WorkTableScanState>()) }
    }
}
impl New for PgPtr<ForeignScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ForeignScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ForeignScanState>()) }
    }
}
impl New for PgPtr<CustomScanState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CustomScanState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CustomScanState>()) }
    }
}
impl New for PgPtr<JoinState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JoinState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JoinState>()) }
    }
}
impl New for PgPtr<NestLoopState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<NestLoopState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<NestLoopState>()) }
    }
}
impl New for PgPtr<MergeJoinClauseData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MergeJoinClauseData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MergeJoinClauseData>()) }
    }
}
impl New for PgPtr<MergeJoinState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MergeJoinState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MergeJoinState>()) }
    }
}
impl New for PgPtr<HashJoinTupleData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HashJoinTupleData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HashJoinTupleData>()) }
    }
}
impl New for PgPtr<HashJoinTableData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HashJoinTableData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HashJoinTableData>()) }
    }
}
impl New for PgPtr<HashJoinState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HashJoinState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HashJoinState>()) }
    }
}
impl New for PgPtr<MaterialState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MaterialState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MaterialState>()) }
    }
}
impl New for PgPtr<SharedSortInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedSortInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedSortInfo>()) }
    }
}
impl New for PgPtr<SortState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SortState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SortState>()) }
    }
}
impl New for PgPtr<GroupState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GroupState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GroupState>()) }
    }
}
impl New for PgPtr<AggStatePerAggData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AggStatePerAggData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AggStatePerAggData>()) }
    }
}
impl New for PgPtr<AggStatePerTransData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AggStatePerTransData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AggStatePerTransData>()) }
    }
}
impl New for PgPtr<AggStatePerGroupData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AggStatePerGroupData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AggStatePerGroupData>()) }
    }
}
impl New for PgPtr<AggStatePerPhaseData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AggStatePerPhaseData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AggStatePerPhaseData>()) }
    }
}
impl New for PgPtr<AggStatePerHashData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AggStatePerHashData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AggStatePerHashData>()) }
    }
}
impl New for PgPtr<AggState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AggState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AggState>()) }
    }
}
impl New for PgPtr<WindowStatePerFuncData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WindowStatePerFuncData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WindowStatePerFuncData>()) }
    }
}
impl New for PgPtr<WindowStatePerAggData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WindowStatePerAggData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WindowStatePerAggData>()) }
    }
}
impl New for PgPtr<WindowAggState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WindowAggState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WindowAggState>()) }
    }
}
impl New for PgPtr<UniqueState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<UniqueState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<UniqueState>()) }
    }
}
impl New for PgPtr<GatherState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GatherState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GatherState>()) }
    }
}
impl New for PgPtr<GMReaderTupleBuffer> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GMReaderTupleBuffer>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GMReaderTupleBuffer>()) }
    }
}
impl New for PgPtr<GatherMergeState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GatherMergeState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GatherMergeState>()) }
    }
}
impl New for PgPtr<HashInstrumentation> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HashInstrumentation>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HashInstrumentation>()) }
    }
}
impl New for PgPtr<SharedHashInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedHashInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedHashInfo>()) }
    }
}
impl New for PgPtr<HashState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HashState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HashState>()) }
    }
}
impl New for PgPtr<SetOpStatePerGroupData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SetOpStatePerGroupData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SetOpStatePerGroupData>()) }
    }
}
impl New for PgPtr<SetOpState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SetOpState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SetOpState>()) }
    }
}
impl New for PgPtr<LockRowsState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LockRowsState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LockRowsState>()) }
    }
}
impl New for PgPtr<LimitState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LimitState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LimitState>()) }
    }
}
impl New for PgPtr<QueryDesc> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<QueryDesc>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<QueryDesc>()) }
    }
}
impl New for PgPtr<Value> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Value>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Value>()) }
    }
}
impl New for PgPtr<Value_ValUnion> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Value_ValUnion>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Value_ValUnion>()) }
    }
}
impl New for PgPtr<Query> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Query>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Query>()) }
    }
}
impl New for PgPtr<TypeName> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TypeName>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TypeName>()) }
    }
}
impl New for PgPtr<ColumnRef> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ColumnRef>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ColumnRef>()) }
    }
}
impl New for PgPtr<ParamRef> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParamRef>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParamRef>()) }
    }
}
impl New for PgPtr<A_Expr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<A_Expr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<A_Expr>()) }
    }
}
impl New for PgPtr<A_Const> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<A_Const>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<A_Const>()) }
    }
}
impl New for PgPtr<TypeCast> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TypeCast>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TypeCast>()) }
    }
}
impl New for PgPtr<CollateClause> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CollateClause>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CollateClause>()) }
    }
}
impl New for PgPtr<RoleSpec> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RoleSpec>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RoleSpec>()) }
    }
}
impl New for PgPtr<FuncCall> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FuncCall>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FuncCall>()) }
    }
}
impl New for PgPtr<A_Star> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<A_Star>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<A_Star>()) }
    }
}
impl New for PgPtr<A_Indices> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<A_Indices>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<A_Indices>()) }
    }
}
impl New for PgPtr<A_Indirection> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<A_Indirection>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<A_Indirection>()) }
    }
}
impl New for PgPtr<A_ArrayExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<A_ArrayExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<A_ArrayExpr>()) }
    }
}
impl New for PgPtr<ResTarget> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ResTarget>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ResTarget>()) }
    }
}
impl New for PgPtr<MultiAssignRef> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MultiAssignRef>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MultiAssignRef>()) }
    }
}
impl New for PgPtr<SortBy> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SortBy>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SortBy>()) }
    }
}
impl New for PgPtr<WindowDef> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WindowDef>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WindowDef>()) }
    }
}
impl New for PgPtr<RangeSubselect> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RangeSubselect>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RangeSubselect>()) }
    }
}
impl New for PgPtr<RangeFunction> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RangeFunction>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RangeFunction>()) }
    }
}
impl New for PgPtr<RangeTableFunc> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RangeTableFunc>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RangeTableFunc>()) }
    }
}
impl New for PgPtr<RangeTableFuncCol> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RangeTableFuncCol>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RangeTableFuncCol>()) }
    }
}
impl New for PgPtr<RangeTableSample> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RangeTableSample>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RangeTableSample>()) }
    }
}
impl New for PgPtr<ColumnDef> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ColumnDef>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ColumnDef>()) }
    }
}
impl New for PgPtr<TableLikeClause> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TableLikeClause>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TableLikeClause>()) }
    }
}
impl New for PgPtr<IndexElem> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexElem>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexElem>()) }
    }
}
impl New for PgPtr<DefElem> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DefElem>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DefElem>()) }
    }
}
impl New for PgPtr<LockingClause> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LockingClause>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LockingClause>()) }
    }
}
impl New for PgPtr<XmlSerialize> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<XmlSerialize>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<XmlSerialize>()) }
    }
}
impl New for PgPtr<PartitionElem> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionElem>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionElem>()) }
    }
}
impl New for PgPtr<PartitionSpec> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionSpec>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionSpec>()) }
    }
}
impl New for PgPtr<PartitionBoundSpec> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionBoundSpec>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionBoundSpec>()) }
    }
}
impl New for PgPtr<PartitionRangeDatum> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionRangeDatum>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionRangeDatum>()) }
    }
}
impl New for PgPtr<PartitionCmd> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionCmd>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionCmd>()) }
    }
}
impl New for PgPtr<RangeTblEntry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RangeTblEntry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RangeTblEntry>()) }
    }
}
impl New for PgPtr<RangeTblFunction> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RangeTblFunction>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RangeTblFunction>()) }
    }
}
impl New for PgPtr<TableSampleClause> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TableSampleClause>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TableSampleClause>()) }
    }
}
impl New for PgPtr<WithCheckOption> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WithCheckOption>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WithCheckOption>()) }
    }
}
impl New for PgPtr<SortGroupClause> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SortGroupClause>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SortGroupClause>()) }
    }
}
impl New for PgPtr<GroupingSet> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GroupingSet>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GroupingSet>()) }
    }
}
impl New for PgPtr<WindowClause> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WindowClause>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WindowClause>()) }
    }
}
impl New for PgPtr<RowMarkClause> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RowMarkClause>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RowMarkClause>()) }
    }
}
impl New for PgPtr<WithClause> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WithClause>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WithClause>()) }
    }
}
impl New for PgPtr<InferClause> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<InferClause>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<InferClause>()) }
    }
}
impl New for PgPtr<OnConflictClause> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<OnConflictClause>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<OnConflictClause>()) }
    }
}
impl New for PgPtr<CommonTableExpr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CommonTableExpr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CommonTableExpr>()) }
    }
}
impl New for PgPtr<TriggerTransition> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TriggerTransition>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TriggerTransition>()) }
    }
}
impl New for PgPtr<RawStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RawStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RawStmt>()) }
    }
}
impl New for PgPtr<InsertStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<InsertStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<InsertStmt>()) }
    }
}
impl New for PgPtr<DeleteStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DeleteStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DeleteStmt>()) }
    }
}
impl New for PgPtr<UpdateStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<UpdateStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<UpdateStmt>()) }
    }
}
impl New for PgPtr<SelectStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SelectStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SelectStmt>()) }
    }
}
impl New for PgPtr<SetOperationStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SetOperationStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SetOperationStmt>()) }
    }
}
impl New for PgPtr<CreateSchemaStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateSchemaStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateSchemaStmt>()) }
    }
}
impl New for PgPtr<AlterTableStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterTableStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterTableStmt>()) }
    }
}
impl New for PgPtr<ReplicaIdentityStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ReplicaIdentityStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ReplicaIdentityStmt>()) }
    }
}
impl New for PgPtr<AlterTableCmd> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterTableCmd>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterTableCmd>()) }
    }
}
impl New for PgPtr<AlterCollationStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterCollationStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterCollationStmt>()) }
    }
}
impl New for PgPtr<AlterDomainStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterDomainStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterDomainStmt>()) }
    }
}
impl New for PgPtr<GrantStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GrantStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GrantStmt>()) }
    }
}
impl New for PgPtr<ObjectWithArgs> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ObjectWithArgs>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ObjectWithArgs>()) }
    }
}
impl New for PgPtr<AccessPriv> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AccessPriv>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AccessPriv>()) }
    }
}
impl New for PgPtr<GrantRoleStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GrantRoleStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GrantRoleStmt>()) }
    }
}
impl New for PgPtr<AlterDefaultPrivilegesStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterDefaultPrivilegesStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterDefaultPrivilegesStmt>()) }
    }
}
impl New for PgPtr<CopyStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CopyStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CopyStmt>()) }
    }
}
impl New for PgPtr<VariableSetStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<VariableSetStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<VariableSetStmt>()) }
    }
}
impl New for PgPtr<VariableShowStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<VariableShowStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<VariableShowStmt>()) }
    }
}
impl New for PgPtr<CreateStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateStmt>()) }
    }
}
impl New for PgPtr<Constraint> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Constraint>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Constraint>()) }
    }
}
impl New for PgPtr<CreateTableSpaceStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateTableSpaceStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateTableSpaceStmt>()) }
    }
}
impl New for PgPtr<DropTableSpaceStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DropTableSpaceStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DropTableSpaceStmt>()) }
    }
}
impl New for PgPtr<AlterTableSpaceOptionsStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterTableSpaceOptionsStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterTableSpaceOptionsStmt>()) }
    }
}
impl New for PgPtr<AlterTableMoveAllStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterTableMoveAllStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterTableMoveAllStmt>()) }
    }
}
impl New for PgPtr<CreateExtensionStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateExtensionStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateExtensionStmt>()) }
    }
}
impl New for PgPtr<AlterExtensionStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterExtensionStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterExtensionStmt>()) }
    }
}
impl New for PgPtr<AlterExtensionContentsStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterExtensionContentsStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterExtensionContentsStmt>()) }
    }
}
impl New for PgPtr<CreateFdwStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateFdwStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateFdwStmt>()) }
    }
}
impl New for PgPtr<AlterFdwStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterFdwStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterFdwStmt>()) }
    }
}
impl New for PgPtr<CreateForeignServerStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateForeignServerStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateForeignServerStmt>()) }
    }
}
impl New for PgPtr<AlterForeignServerStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterForeignServerStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterForeignServerStmt>()) }
    }
}
impl New for PgPtr<CreateForeignTableStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateForeignTableStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateForeignTableStmt>()) }
    }
}
impl New for PgPtr<CreateUserMappingStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateUserMappingStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateUserMappingStmt>()) }
    }
}
impl New for PgPtr<AlterUserMappingStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterUserMappingStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterUserMappingStmt>()) }
    }
}
impl New for PgPtr<DropUserMappingStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DropUserMappingStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DropUserMappingStmt>()) }
    }
}
impl New for PgPtr<ImportForeignSchemaStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ImportForeignSchemaStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ImportForeignSchemaStmt>()) }
    }
}
impl New for PgPtr<CreatePolicyStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreatePolicyStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreatePolicyStmt>()) }
    }
}
impl New for PgPtr<AlterPolicyStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterPolicyStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterPolicyStmt>()) }
    }
}
impl New for PgPtr<CreateAmStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateAmStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateAmStmt>()) }
    }
}
impl New for PgPtr<CreateTrigStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateTrigStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateTrigStmt>()) }
    }
}
impl New for PgPtr<CreateEventTrigStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateEventTrigStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateEventTrigStmt>()) }
    }
}
impl New for PgPtr<AlterEventTrigStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterEventTrigStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterEventTrigStmt>()) }
    }
}
impl New for PgPtr<CreatePLangStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreatePLangStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreatePLangStmt>()) }
    }
}
impl New for PgPtr<CreateRoleStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateRoleStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateRoleStmt>()) }
    }
}
impl New for PgPtr<AlterRoleStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterRoleStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterRoleStmt>()) }
    }
}
impl New for PgPtr<AlterRoleSetStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterRoleSetStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterRoleSetStmt>()) }
    }
}
impl New for PgPtr<DropRoleStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DropRoleStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DropRoleStmt>()) }
    }
}
impl New for PgPtr<CreateSeqStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateSeqStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateSeqStmt>()) }
    }
}
impl New for PgPtr<AlterSeqStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterSeqStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterSeqStmt>()) }
    }
}
impl New for PgPtr<DefineStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DefineStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DefineStmt>()) }
    }
}
impl New for PgPtr<CreateDomainStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateDomainStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateDomainStmt>()) }
    }
}
impl New for PgPtr<CreateOpClassStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateOpClassStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateOpClassStmt>()) }
    }
}
impl New for PgPtr<CreateOpClassItem> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateOpClassItem>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateOpClassItem>()) }
    }
}
impl New for PgPtr<CreateOpFamilyStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateOpFamilyStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateOpFamilyStmt>()) }
    }
}
impl New for PgPtr<AlterOpFamilyStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterOpFamilyStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterOpFamilyStmt>()) }
    }
}
impl New for PgPtr<DropStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DropStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DropStmt>()) }
    }
}
impl New for PgPtr<TruncateStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TruncateStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TruncateStmt>()) }
    }
}
impl New for PgPtr<CommentStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CommentStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CommentStmt>()) }
    }
}
impl New for PgPtr<SecLabelStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SecLabelStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SecLabelStmt>()) }
    }
}
impl New for PgPtr<DeclareCursorStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DeclareCursorStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DeclareCursorStmt>()) }
    }
}
impl New for PgPtr<ClosePortalStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ClosePortalStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ClosePortalStmt>()) }
    }
}
impl New for PgPtr<FetchStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FetchStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FetchStmt>()) }
    }
}
impl New for PgPtr<IndexStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexStmt>()) }
    }
}
impl New for PgPtr<CreateStatsStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateStatsStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateStatsStmt>()) }
    }
}
impl New for PgPtr<CreateFunctionStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateFunctionStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateFunctionStmt>()) }
    }
}
impl New for PgPtr<FunctionParameter> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FunctionParameter>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FunctionParameter>()) }
    }
}
impl New for PgPtr<AlterFunctionStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterFunctionStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterFunctionStmt>()) }
    }
}
impl New for PgPtr<DoStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DoStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DoStmt>()) }
    }
}
impl New for PgPtr<InlineCodeBlock> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<InlineCodeBlock>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<InlineCodeBlock>()) }
    }
}
impl New for PgPtr<CallStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CallStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CallStmt>()) }
    }
}
impl New for PgPtr<CallContext> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CallContext>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CallContext>()) }
    }
}
impl New for PgPtr<RenameStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RenameStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RenameStmt>()) }
    }
}
impl New for PgPtr<AlterObjectDependsStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterObjectDependsStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterObjectDependsStmt>()) }
    }
}
impl New for PgPtr<AlterObjectSchemaStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterObjectSchemaStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterObjectSchemaStmt>()) }
    }
}
impl New for PgPtr<AlterOwnerStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterOwnerStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterOwnerStmt>()) }
    }
}
impl New for PgPtr<AlterOperatorStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterOperatorStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterOperatorStmt>()) }
    }
}
impl New for PgPtr<RuleStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RuleStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RuleStmt>()) }
    }
}
impl New for PgPtr<NotifyStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<NotifyStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<NotifyStmt>()) }
    }
}
impl New for PgPtr<ListenStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ListenStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ListenStmt>()) }
    }
}
impl New for PgPtr<UnlistenStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<UnlistenStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<UnlistenStmt>()) }
    }
}
impl New for PgPtr<TransactionStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TransactionStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TransactionStmt>()) }
    }
}
impl New for PgPtr<CompositeTypeStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CompositeTypeStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CompositeTypeStmt>()) }
    }
}
impl New for PgPtr<CreateEnumStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateEnumStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateEnumStmt>()) }
    }
}
impl New for PgPtr<CreateRangeStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateRangeStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateRangeStmt>()) }
    }
}
impl New for PgPtr<AlterEnumStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterEnumStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterEnumStmt>()) }
    }
}
impl New for PgPtr<ViewStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ViewStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ViewStmt>()) }
    }
}
impl New for PgPtr<LoadStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LoadStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LoadStmt>()) }
    }
}
impl New for PgPtr<CreatedbStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreatedbStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreatedbStmt>()) }
    }
}
impl New for PgPtr<AlterDatabaseStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterDatabaseStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterDatabaseStmt>()) }
    }
}
impl New for PgPtr<AlterDatabaseSetStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterDatabaseSetStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterDatabaseSetStmt>()) }
    }
}
impl New for PgPtr<DropdbStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DropdbStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DropdbStmt>()) }
    }
}
impl New for PgPtr<AlterSystemStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterSystemStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterSystemStmt>()) }
    }
}
impl New for PgPtr<ClusterStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ClusterStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ClusterStmt>()) }
    }
}
impl New for PgPtr<VacuumStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<VacuumStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<VacuumStmt>()) }
    }
}
impl New for PgPtr<VacuumRelation> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<VacuumRelation>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<VacuumRelation>()) }
    }
}
impl New for PgPtr<ExplainStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExplainStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExplainStmt>()) }
    }
}
impl New for PgPtr<CreateTableAsStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateTableAsStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateTableAsStmt>()) }
    }
}
impl New for PgPtr<RefreshMatViewStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RefreshMatViewStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RefreshMatViewStmt>()) }
    }
}
impl New for PgPtr<CheckPointStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CheckPointStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CheckPointStmt>()) }
    }
}
impl New for PgPtr<DiscardStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DiscardStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DiscardStmt>()) }
    }
}
impl New for PgPtr<LockStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LockStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LockStmt>()) }
    }
}
impl New for PgPtr<ConstraintsSetStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ConstraintsSetStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ConstraintsSetStmt>()) }
    }
}
impl New for PgPtr<ReindexStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ReindexStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ReindexStmt>()) }
    }
}
impl New for PgPtr<CreateConversionStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateConversionStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateConversionStmt>()) }
    }
}
impl New for PgPtr<CreateCastStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateCastStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateCastStmt>()) }
    }
}
impl New for PgPtr<CreateTransformStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateTransformStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateTransformStmt>()) }
    }
}
impl New for PgPtr<PrepareStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PrepareStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PrepareStmt>()) }
    }
}
impl New for PgPtr<ExecuteStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExecuteStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExecuteStmt>()) }
    }
}
impl New for PgPtr<DeallocateStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DeallocateStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DeallocateStmt>()) }
    }
}
impl New for PgPtr<DropOwnedStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DropOwnedStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DropOwnedStmt>()) }
    }
}
impl New for PgPtr<ReassignOwnedStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ReassignOwnedStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ReassignOwnedStmt>()) }
    }
}
impl New for PgPtr<AlterTSDictionaryStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterTSDictionaryStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterTSDictionaryStmt>()) }
    }
}
impl New for PgPtr<AlterTSConfigurationStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterTSConfigurationStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterTSConfigurationStmt>()) }
    }
}
impl New for PgPtr<CreatePublicationStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreatePublicationStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreatePublicationStmt>()) }
    }
}
impl New for PgPtr<AlterPublicationStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterPublicationStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterPublicationStmt>()) }
    }
}
impl New for PgPtr<CreateSubscriptionStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateSubscriptionStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateSubscriptionStmt>()) }
    }
}
impl New for PgPtr<AlterSubscriptionStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AlterSubscriptionStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AlterSubscriptionStmt>()) }
    }
}
impl New for PgPtr<DropSubscriptionStmt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DropSubscriptionStmt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DropSubscriptionStmt>()) }
    }
}
impl New for PgPtr<MemoryContextCounters> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MemoryContextCounters>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MemoryContextCounters>()) }
    }
}
impl New for PgPtr<MemoryContextMethods> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MemoryContextMethods>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MemoryContextMethods>()) }
    }
}
impl New for PgPtr<MemoryContextData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MemoryContextData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MemoryContextData>()) }
    }
}
impl New for PgPtr<TupOutputState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TupOutputState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TupOutputState>()) }
    }
}
impl New for PgPtr<AttInMetadata> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AttInMetadata>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AttInMetadata>()) }
    }
}
impl New for PgPtr<FuncCallContext> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FuncCallContext>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FuncCallContext>()) }
    }
}
impl New for PgPtr<pg_tm> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<pg_tm>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<pg_tm>()) }
    }
}
impl New for PgPtr<pg_tz> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<pg_tz>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<pg_tz>()) }
    }
}
impl New for PgPtr<pg_tzenum> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<pg_tzenum>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<pg_tzenum>()) }
    }
}
impl New for PgPtr<Port> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Port>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Port>()) }
    }
}
impl New for PgPtr<sockaddr_un> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<sockaddr_un>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<sockaddr_un>()) }
    }
}
impl New for PgPtr<SockAddr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SockAddr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SockAddr>()) }
    }
}
impl New for PgPtr<StartupPacket> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<StartupPacket>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<StartupPacket>()) }
    }
}
impl New for PgPtr<CancelRequestPacket> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CancelRequestPacket>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CancelRequestPacket>()) }
    }
}
impl New for PgPtr<RelFileNode> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RelFileNode>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RelFileNode>()) }
    }
}
impl New for PgPtr<RelFileNodeBackend> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RelFileNodeBackend>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RelFileNodeBackend>()) }
    }
}
impl New for PgPtr<XLogRecord> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<XLogRecord>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<XLogRecord>()) }
    }
}
impl New for PgPtr<XLogRecordBlockHeader> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<XLogRecordBlockHeader>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<XLogRecordBlockHeader>()) }
    }
}
impl New for PgPtr<XLogRecordBlockImageHeader> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<XLogRecordBlockImageHeader>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<XLogRecordBlockImageHeader>()) }
    }
}
impl New for PgPtr<XLogRecordBlockCompressHeader> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<XLogRecordBlockCompressHeader>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<XLogRecordBlockCompressHeader>()) }
    }
}
impl New for PgPtr<XLogRecordDataHeaderShort> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<XLogRecordDataHeaderShort>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<XLogRecordDataHeaderShort>()) }
    }
}
impl New for PgPtr<XLogRecordDataHeaderLong> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<XLogRecordDataHeaderLong>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<XLogRecordDataHeaderLong>()) }
    }
}
impl New for PgPtr<DecodedBkpBlock> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DecodedBkpBlock>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DecodedBkpBlock>()) }
    }
}
impl New for PgPtr<XLogReaderState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<XLogReaderState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<XLogReaderState>()) }
    }
}
impl New for PgPtr<xl_clog_truncate> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_clog_truncate>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_clog_truncate>()) }
    }
}
impl New for PgPtr<dlist_node> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<dlist_node>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<dlist_node>()) }
    }
}
impl New for PgPtr<dlist_head> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<dlist_head>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<dlist_head>()) }
    }
}
impl New for PgPtr<dlist_iter> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<dlist_iter>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<dlist_iter>()) }
    }
}
impl New for PgPtr<dlist_mutable_iter> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<dlist_mutable_iter>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<dlist_mutable_iter>()) }
    }
}
impl New for PgPtr<slist_node> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<slist_node>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<slist_node>()) }
    }
}
impl New for PgPtr<slist_head> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<slist_head>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<slist_head>()) }
    }
}
impl New for PgPtr<slist_iter> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<slist_iter>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<slist_iter>()) }
    }
}
impl New for PgPtr<slist_mutable_iter> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<slist_mutable_iter>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<slist_mutable_iter>()) }
    }
}
impl New for PgPtr<Latch> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Latch>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Latch>()) }
    }
}
impl New for PgPtr<WaitEvent> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WaitEvent>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WaitEvent>()) }
    }
}
impl New for PgPtr<WaitEventSet> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WaitEventSet>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WaitEventSet>()) }
    }
}
impl New for PgPtr<xl_standby_lock> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_standby_lock>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_standby_lock>()) }
    }
}
impl New for PgPtr<LWLock> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LWLock>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LWLock>()) }
    }
}
impl New for PgPtr<LWLockPadded> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LWLockPadded>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LWLockPadded>()) }
    }
}
impl New for PgPtr<LWLockMinimallyPadded> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LWLockMinimallyPadded>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LWLockMinimallyPadded>()) }
    }
}
impl New for PgPtr<NamedLWLockTranche> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<NamedLWLockTranche>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<NamedLWLockTranche>()) }
    }
}
impl New for PgPtr<SHM_QUEUE> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SHM_QUEUE>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SHM_QUEUE>()) }
    }
}
impl New for PgPtr<ShmemIndexEnt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ShmemIndexEnt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ShmemIndexEnt>()) }
    }
}
impl New for PgPtr<PROC_QUEUE> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PROC_QUEUE>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PROC_QUEUE>()) }
    }
}
impl New for PgPtr<VirtualTransactionId> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<VirtualTransactionId>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<VirtualTransactionId>()) }
    }
}
impl New for PgPtr<LockMethodData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LockMethodData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LockMethodData>()) }
    }
}
impl New for PgPtr<LOCKTAG> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LOCKTAG>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LOCKTAG>()) }
    }
}
impl New for PgPtr<LOCK> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LOCK>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LOCK>()) }
    }
}
impl New for PgPtr<PROCLOCKTAG> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PROCLOCKTAG>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PROCLOCKTAG>()) }
    }
}
impl New for PgPtr<PROCLOCK> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PROCLOCK>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PROCLOCK>()) }
    }
}
impl New for PgPtr<LOCALLOCKTAG> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LOCALLOCKTAG>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LOCALLOCKTAG>()) }
    }
}
impl New for PgPtr<LOCALLOCKOWNER> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LOCALLOCKOWNER>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LOCALLOCKOWNER>()) }
    }
}
impl New for PgPtr<LOCALLOCK> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LOCALLOCK>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LOCALLOCK>()) }
    }
}
impl New for PgPtr<LockInstanceData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LockInstanceData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LockInstanceData>()) }
    }
}
impl New for PgPtr<LockData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LockData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LockData>()) }
    }
}
impl New for PgPtr<BlockedProcData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BlockedProcData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BlockedProcData>()) }
    }
}
impl New for PgPtr<BlockedProcsData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BlockedProcsData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BlockedProcsData>()) }
    }
}
impl New for PgPtr<PGSemaphoreData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PGSemaphoreData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PGSemaphoreData>()) }
    }
}
impl New for PgPtr<XidCache> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<XidCache>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<XidCache>()) }
    }
}
impl New for PgPtr<PGPROC> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PGPROC>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PGPROC>()) }
    }
}
impl New for PgPtr<PGXACT> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PGXACT>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PGXACT>()) }
    }
}
impl New for PgPtr<PROC_HDR> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PROC_HDR>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PROC_HDR>()) }
    }
}
impl New for PgPtr<PgStat_TableCounts> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_TableCounts>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_TableCounts>()) }
    }
}
impl New for PgPtr<PgStat_TableStatus> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_TableStatus>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_TableStatus>()) }
    }
}
impl New for PgPtr<PgStat_TableXactStatus> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_TableXactStatus>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_TableXactStatus>()) }
    }
}
impl New for PgPtr<PgStat_MsgHdr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgHdr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgHdr>()) }
    }
}
impl New for PgPtr<PgStat_MsgDummy> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgDummy>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgDummy>()) }
    }
}
impl New for PgPtr<PgStat_MsgInquiry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgInquiry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgInquiry>()) }
    }
}
impl New for PgPtr<PgStat_TableEntry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_TableEntry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_TableEntry>()) }
    }
}
impl New for PgPtr<PgStat_MsgTabstat> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgTabstat>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgTabstat>()) }
    }
}
impl New for PgPtr<PgStat_MsgTabpurge> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgTabpurge>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgTabpurge>()) }
    }
}
impl New for PgPtr<PgStat_MsgDropdb> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgDropdb>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgDropdb>()) }
    }
}
impl New for PgPtr<PgStat_MsgResetcounter> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgResetcounter>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgResetcounter>()) }
    }
}
impl New for PgPtr<PgStat_MsgResetsharedcounter> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgResetsharedcounter>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgResetsharedcounter>()) }
    }
}
impl New for PgPtr<PgStat_MsgResetsinglecounter> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgResetsinglecounter>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgResetsinglecounter>()) }
    }
}
impl New for PgPtr<PgStat_MsgAutovacStart> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgAutovacStart>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgAutovacStart>()) }
    }
}
impl New for PgPtr<PgStat_MsgVacuum> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgVacuum>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgVacuum>()) }
    }
}
impl New for PgPtr<PgStat_MsgAnalyze> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgAnalyze>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgAnalyze>()) }
    }
}
impl New for PgPtr<PgStat_MsgArchiver> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgArchiver>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgArchiver>()) }
    }
}
impl New for PgPtr<PgStat_MsgBgWriter> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgBgWriter>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgBgWriter>()) }
    }
}
impl New for PgPtr<PgStat_MsgRecoveryConflict> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgRecoveryConflict>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgRecoveryConflict>()) }
    }
}
impl New for PgPtr<PgStat_MsgTempFile> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgTempFile>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgTempFile>()) }
    }
}
impl New for PgPtr<PgStat_FunctionCounts> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_FunctionCounts>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_FunctionCounts>()) }
    }
}
impl New for PgPtr<PgStat_BackendFunctionEntry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_BackendFunctionEntry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_BackendFunctionEntry>()) }
    }
}
impl New for PgPtr<PgStat_FunctionEntry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_FunctionEntry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_FunctionEntry>()) }
    }
}
impl New for PgPtr<PgStat_MsgFuncstat> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgFuncstat>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgFuncstat>()) }
    }
}
impl New for PgPtr<PgStat_MsgFuncpurge> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgFuncpurge>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgFuncpurge>()) }
    }
}
impl New for PgPtr<PgStat_MsgDeadlock> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgDeadlock>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgDeadlock>()) }
    }
}
impl New for PgPtr<PgStat_MsgChecksumFailure> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_MsgChecksumFailure>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_MsgChecksumFailure>()) }
    }
}
impl New for PgPtr<PgStat_Msg> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_Msg>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_Msg>()) }
    }
}
impl New for PgPtr<PgStat_StatDBEntry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_StatDBEntry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_StatDBEntry>()) }
    }
}
impl New for PgPtr<PgStat_StatTabEntry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_StatTabEntry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_StatTabEntry>()) }
    }
}
impl New for PgPtr<PgStat_StatFuncEntry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_StatFuncEntry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_StatFuncEntry>()) }
    }
}
impl New for PgPtr<PgStat_ArchiverStats> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_ArchiverStats>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_ArchiverStats>()) }
    }
}
impl New for PgPtr<PgStat_GlobalStats> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_GlobalStats>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_GlobalStats>()) }
    }
}
impl New for PgPtr<PgBackendSSLStatus> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgBackendSSLStatus>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgBackendSSLStatus>()) }
    }
}
impl New for PgPtr<PgBackendGSSStatus> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgBackendGSSStatus>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgBackendGSSStatus>()) }
    }
}
impl New for PgPtr<PgBackendStatus> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgBackendStatus>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgBackendStatus>()) }
    }
}
impl New for PgPtr<LocalPgBackendStatus> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LocalPgBackendStatus>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LocalPgBackendStatus>()) }
    }
}
impl New for PgPtr<PgStat_FunctionCallUsage> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PgStat_FunctionCallUsage>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PgStat_FunctionCallUsage>()) }
    }
}
impl New for PgPtr<ScanKeyData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ScanKeyData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ScanKeyData>()) }
    }
}
impl New for PgPtr<IndexBuildResult> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexBuildResult>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexBuildResult>()) }
    }
}
impl New for PgPtr<IndexVacuumInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexVacuumInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexVacuumInfo>()) }
    }
}
impl New for PgPtr<IndexBulkDeleteResult> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexBulkDeleteResult>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexBulkDeleteResult>()) }
    }
}
impl New for PgPtr<IndexOrderByDistance> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexOrderByDistance>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexOrderByDistance>()) }
    }
}
impl New for PgPtr<IndexAmRoutine> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexAmRoutine>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexAmRoutine>()) }
    }
}
impl New for PgPtr<relopt_gen> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<relopt_gen>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<relopt_gen>()) }
    }
}
impl New for PgPtr<relopt_value> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<relopt_value>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<relopt_value>()) }
    }
}
impl New for PgPtr<relopt_value__bindgen_ty_1> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<relopt_value__bindgen_ty_1>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<relopt_value__bindgen_ty_1>()) }
    }
}
impl New for PgPtr<relopt_bool> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<relopt_bool>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<relopt_bool>()) }
    }
}
impl New for PgPtr<relopt_int> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<relopt_int>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<relopt_int>()) }
    }
}
impl New for PgPtr<relopt_real> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<relopt_real>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<relopt_real>()) }
    }
}
impl New for PgPtr<relopt_string> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<relopt_string>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<relopt_string>()) }
    }
}
impl New for PgPtr<relopt_parse_elt> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<relopt_parse_elt>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<relopt_parse_elt>()) }
    }
}
impl New for PgPtr<TableScanDescData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TableScanDescData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TableScanDescData>()) }
    }
}
impl New for PgPtr<ParallelTableScanDescData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParallelTableScanDescData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParallelTableScanDescData>()) }
    }
}
impl New for PgPtr<ParallelBlockTableScanDescData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParallelBlockTableScanDescData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParallelBlockTableScanDescData>()) }
    }
}
impl New for PgPtr<IndexFetchTableData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexFetchTableData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexFetchTableData>()) }
    }
}
impl New for PgPtr<IndexScanDescData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexScanDescData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexScanDescData>()) }
    }
}
impl New for PgPtr<ParallelIndexScanDescData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParallelIndexScanDescData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParallelIndexScanDescData>()) }
    }
}
impl New for PgPtr<SysScanDescData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SysScanDescData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SysScanDescData>()) }
    }
}
impl New for PgPtr<ExpandedObjectMethods> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExpandedObjectMethods>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExpandedObjectMethods>()) }
    }
}
impl New for PgPtr<ExpandedObjectHeader> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExpandedObjectHeader>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExpandedObjectHeader>()) }
    }
}
impl New for PgPtr<ArrayType> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ArrayType>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ArrayType>()) }
    }
}
impl New for PgPtr<ExpandedArrayHeader> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExpandedArrayHeader>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExpandedArrayHeader>()) }
    }
}
impl New for PgPtr<AnyArrayType> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AnyArrayType>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AnyArrayType>()) }
    }
}
impl New for PgPtr<ArrayBuildState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ArrayBuildState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ArrayBuildState>()) }
    }
}
impl New for PgPtr<ArrayBuildStateArr> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ArrayBuildStateArr>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ArrayBuildStateArr>()) }
    }
}
impl New for PgPtr<ArrayBuildStateAny> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ArrayBuildStateAny>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ArrayBuildStateAny>()) }
    }
}
impl New for PgPtr<ArrayMetaState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ArrayMetaState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ArrayMetaState>()) }
    }
}
impl New for PgPtr<ArrayMapState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ArrayMapState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ArrayMapState>()) }
    }
}
impl New for PgPtr<ArrayIteratorData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ArrayIteratorData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ArrayIteratorData>()) }
    }
}
impl New for PgPtr<ConfigVariable> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ConfigVariable>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ConfigVariable>()) }
    }
}
impl New for PgPtr<config_enum_entry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<config_enum_entry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<config_enum_entry>()) }
    }
}
impl New for PgPtr<CheckpointStatsData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CheckpointStatsData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CheckpointStatsData>()) }
    }
}
impl New for PgPtr<XLogRecData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<XLogRecData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<XLogRecData>()) }
    }
}
impl New for PgPtr<FormData_pg_class> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FormData_pg_class>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FormData_pg_class>()) }
    }
}
impl New for PgPtr<FormData_pg_index> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FormData_pg_index>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FormData_pg_index>()) }
    }
}
impl New for PgPtr<ParseState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParseState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParseState>()) }
    }
}
impl New for PgPtr<ParseNamespaceItem> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParseNamespaceItem>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParseNamespaceItem>()) }
    }
}
impl New for PgPtr<ParseCallbackState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParseCallbackState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParseCallbackState>()) }
    }
}
impl New for PgPtr<AclItem> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AclItem>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AclItem>()) }
    }
}
impl New for PgPtr<ObjectAddress> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ObjectAddress>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ObjectAddress>()) }
    }
}
impl New for PgPtr<FormData_pg_publication> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FormData_pg_publication>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FormData_pg_publication>()) }
    }
}
impl New for PgPtr<PublicationActions> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PublicationActions>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PublicationActions>()) }
    }
}
impl New for PgPtr<Publication> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Publication>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Publication>()) }
    }
}
impl New for PgPtr<RewriteRule> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RewriteRule>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RewriteRule>()) }
    }
}
impl New for PgPtr<RuleLock> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RuleLock>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RuleLock>()) }
    }
}
impl New for PgPtr<LockRelId> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LockRelId>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LockRelId>()) }
    }
}
impl New for PgPtr<LockInfoData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LockInfoData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LockInfoData>()) }
    }
}
impl New for PgPtr<ForeignKeyCacheInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ForeignKeyCacheInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ForeignKeyCacheInfo>()) }
    }
}
impl New for PgPtr<AutoVacOpts> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AutoVacOpts>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AutoVacOpts>()) }
    }
}
impl New for PgPtr<StdRdOptions> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<StdRdOptions>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<StdRdOptions>()) }
    }
}
impl New for PgPtr<ViewOptions> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ViewOptions>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ViewOptions>()) }
    }
}
impl New for PgPtr<BulkInsertStateData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BulkInsertStateData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BulkInsertStateData>()) }
    }
}
impl New for PgPtr<VacuumParams> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<VacuumParams>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<VacuumParams>()) }
    }
}
impl New for PgPtr<TM_FailureData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TM_FailureData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TM_FailureData>()) }
    }
}
impl New for PgPtr<TableAmRoutine> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TableAmRoutine>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TableAmRoutine>()) }
    }
}
impl New for PgPtr<SharedInvalCatcacheMsg> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedInvalCatcacheMsg>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedInvalCatcacheMsg>()) }
    }
}
impl New for PgPtr<SharedInvalCatalogMsg> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedInvalCatalogMsg>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedInvalCatalogMsg>()) }
    }
}
impl New for PgPtr<SharedInvalRelcacheMsg> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedInvalRelcacheMsg>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedInvalRelcacheMsg>()) }
    }
}
impl New for PgPtr<SharedInvalSmgrMsg> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedInvalSmgrMsg>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedInvalSmgrMsg>()) }
    }
}
impl New for PgPtr<SharedInvalRelmapMsg> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedInvalRelmapMsg>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedInvalRelmapMsg>()) }
    }
}
impl New for PgPtr<SharedInvalSnapshotMsg> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedInvalSnapshotMsg>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedInvalSnapshotMsg>()) }
    }
}
impl New for PgPtr<SharedInvalidationMessage> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedInvalidationMessage>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedInvalidationMessage>()) }
    }
}
impl New for PgPtr<tzEntry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<tzEntry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<tzEntry>()) }
    }
}
impl New for PgPtr<datetkn> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<datetkn>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<datetkn>()) }
    }
}
impl New for PgPtr<TimeZoneAbbrevTable> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TimeZoneAbbrevTable>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TimeZoneAbbrevTable>()) }
    }
}
impl New for PgPtr<DynamicZoneAbbrev> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DynamicZoneAbbrev>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DynamicZoneAbbrev>()) }
    }
}
impl New for PgPtr<xl_xact_assignment> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_xact_assignment>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_xact_assignment>()) }
    }
}
impl New for PgPtr<xl_xact_xinfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_xact_xinfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_xact_xinfo>()) }
    }
}
impl New for PgPtr<xl_xact_dbinfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_xact_dbinfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_xact_dbinfo>()) }
    }
}
impl New for PgPtr<xl_xact_subxacts> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_xact_subxacts>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_xact_subxacts>()) }
    }
}
impl New for PgPtr<xl_xact_relfilenodes> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_xact_relfilenodes>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_xact_relfilenodes>()) }
    }
}
impl New for PgPtr<xl_xact_invals> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_xact_invals>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_xact_invals>()) }
    }
}
impl New for PgPtr<xl_xact_twophase> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_xact_twophase>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_xact_twophase>()) }
    }
}
impl New for PgPtr<xl_xact_origin> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_xact_origin>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_xact_origin>()) }
    }
}
impl New for PgPtr<xl_xact_commit> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_xact_commit>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_xact_commit>()) }
    }
}
impl New for PgPtr<xl_xact_abort> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_xact_abort>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_xact_abort>()) }
    }
}
impl New for PgPtr<xl_xact_parsed_commit> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_xact_parsed_commit>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_xact_parsed_commit>()) }
    }
}
impl New for PgPtr<xl_xact_parsed_abort> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_xact_parsed_abort>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_xact_parsed_abort>()) }
    }
}
impl New for PgPtr<ValidateIndexState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ValidateIndexState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ValidateIndexState>()) }
    }
}
impl New for PgPtr<OverrideSearchPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<OverrideSearchPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<OverrideSearchPath>()) }
    }
}
impl New for PgPtr<FormData_pg_enum> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FormData_pg_enum>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FormData_pg_enum>()) }
    }
}
impl New for PgPtr<FormData_pg_proc> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FormData_pg_proc>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FormData_pg_proc>()) }
    }
}
impl New for PgPtr<FormData_pg_type> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FormData_pg_type>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FormData_pg_type>()) }
    }
}
impl New for PgPtr<ObjectAddresses> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ObjectAddresses>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ObjectAddresses>()) }
    }
}
impl New for PgPtr<FormData_pg_event_trigger> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FormData_pg_event_trigger>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FormData_pg_event_trigger>()) }
    }
}
impl New for PgPtr<InternalGrant> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<InternalGrant>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<InternalGrant>()) }
    }
}
impl New for PgPtr<CollectedATSubcmd> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CollectedATSubcmd>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CollectedATSubcmd>()) }
    }
}
impl New for PgPtr<CollectedCommand> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CollectedCommand>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CollectedCommand>()) }
    }
}
impl New for PgPtr<CollectedCommand__bindgen_ty_1> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CollectedCommand__bindgen_ty_1>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CollectedCommand__bindgen_ty_1>()) }
    }
}
impl New for PgPtr<CollectedCommand__bindgen_ty_1__bindgen_ty_1> {
    #[inline]
    fn new() -> Self {
        unsafe {
            crate::pgptr::palloc(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_1,
            >())
        }
    }
    #[inline]
    fn new0() -> Self {
        unsafe {
            crate::pgptr::palloc0(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_1,
            >())
        }
    }
}
impl New for PgPtr<CollectedCommand__bindgen_ty_1__bindgen_ty_2> {
    #[inline]
    fn new() -> Self {
        unsafe {
            crate::pgptr::palloc(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_2,
            >())
        }
    }
    #[inline]
    fn new0() -> Self {
        unsafe {
            crate::pgptr::palloc0(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_2,
            >())
        }
    }
}
impl New for PgPtr<CollectedCommand__bindgen_ty_1__bindgen_ty_3> {
    #[inline]
    fn new() -> Self {
        unsafe {
            crate::pgptr::palloc(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_3,
            >())
        }
    }
    #[inline]
    fn new0() -> Self {
        unsafe {
            crate::pgptr::palloc0(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_3,
            >())
        }
    }
}
impl New for PgPtr<CollectedCommand__bindgen_ty_1__bindgen_ty_4> {
    #[inline]
    fn new() -> Self {
        unsafe {
            crate::pgptr::palloc(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_4,
            >())
        }
    }
    #[inline]
    fn new0() -> Self {
        unsafe {
            crate::pgptr::palloc0(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_4,
            >())
        }
    }
}
impl New for PgPtr<CollectedCommand__bindgen_ty_1__bindgen_ty_5> {
    #[inline]
    fn new() -> Self {
        unsafe {
            crate::pgptr::palloc(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_5,
            >())
        }
    }
    #[inline]
    fn new0() -> Self {
        unsafe {
            crate::pgptr::palloc0(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_5,
            >())
        }
    }
}
impl New for PgPtr<CollectedCommand__bindgen_ty_1__bindgen_ty_6> {
    #[inline]
    fn new() -> Self {
        unsafe {
            crate::pgptr::palloc(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_6,
            >())
        }
    }
    #[inline]
    fn new0() -> Self {
        unsafe {
            crate::pgptr::palloc0(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_6,
            >())
        }
    }
}
impl New for PgPtr<CollectedCommand__bindgen_ty_1__bindgen_ty_7> {
    #[inline]
    fn new() -> Self {
        unsafe {
            crate::pgptr::palloc(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_7,
            >())
        }
    }
    #[inline]
    fn new0() -> Self {
        unsafe {
            crate::pgptr::palloc0(std::mem::size_of::<
                CollectedCommand__bindgen_ty_1__bindgen_ty_7,
            >())
        }
    }
}
impl New for PgPtr<EventTriggerData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<EventTriggerData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<EventTriggerData>()) }
    }
}
impl New for PgPtr<FormData_pg_trigger> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FormData_pg_trigger>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FormData_pg_trigger>()) }
    }
}
impl New for PgPtr<TriggerData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TriggerData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TriggerData>()) }
    }
}
impl New for PgPtr<AfterTriggersTableData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AfterTriggersTableData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AfterTriggersTableData>()) }
    }
}
impl New for PgPtr<TransitionCaptureState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TransitionCaptureState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TransitionCaptureState>()) }
    }
}
impl New for PgPtr<CachedPlanSource> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CachedPlanSource>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CachedPlanSource>()) }
    }
}
impl New for PgPtr<CachedPlan> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CachedPlan>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CachedPlan>()) }
    }
}
impl New for PgPtr<CachedExpression> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CachedExpression>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CachedExpression>()) }
    }
}
impl New for PgPtr<PortalData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PortalData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PortalData>()) }
    }
}
impl New for PgPtr<SPITupleTable> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SPITupleTable>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SPITupleTable>()) }
    }
}
impl New for PgPtr<BackgroundWorker> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BackgroundWorker>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BackgroundWorker>()) }
    }
}
impl New for PgPtr<BackgroundWorkerHandle> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BackgroundWorkerHandle>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BackgroundWorkerHandle>()) }
    }
}
impl New for PgPtr<shm_mq> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<shm_mq>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<shm_mq>()) }
    }
}
impl New for PgPtr<shm_mq_handle> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<shm_mq_handle>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<shm_mq_handle>()) }
    }
}
impl New for PgPtr<shm_mq_iovec> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<shm_mq_iovec>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<shm_mq_iovec>()) }
    }
}
impl New for PgPtr<shm_toc> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<shm_toc>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<shm_toc>()) }
    }
}
impl New for PgPtr<shm_toc_estimator> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<shm_toc_estimator>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<shm_toc_estimator>()) }
    }
}
impl New for PgPtr<ParallelWorkerInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParallelWorkerInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParallelWorkerInfo>()) }
    }
}
impl New for PgPtr<ParallelContext> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParallelContext>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParallelContext>()) }
    }
}
impl New for PgPtr<ParallelWorkerContext> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParallelWorkerContext>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParallelWorkerContext>()) }
    }
}
impl New for PgPtr<QualCost> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<QualCost>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<QualCost>()) }
    }
}
impl New for PgPtr<AggClauseCosts> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AggClauseCosts>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AggClauseCosts>()) }
    }
}
impl New for PgPtr<PlannerGlobal> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PlannerGlobal>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PlannerGlobal>()) }
    }
}
impl New for PgPtr<PlannerInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PlannerInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PlannerInfo>()) }
    }
}
impl New for PgPtr<PartitionSchemeData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionSchemeData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionSchemeData>()) }
    }
}
impl New for PgPtr<RelOptInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RelOptInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RelOptInfo>()) }
    }
}
impl New for PgPtr<IndexOptInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexOptInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexOptInfo>()) }
    }
}
impl New for PgPtr<ForeignKeyOptInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ForeignKeyOptInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ForeignKeyOptInfo>()) }
    }
}
impl New for PgPtr<StatisticExtInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<StatisticExtInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<StatisticExtInfo>()) }
    }
}
impl New for PgPtr<EquivalenceClass> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<EquivalenceClass>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<EquivalenceClass>()) }
    }
}
impl New for PgPtr<EquivalenceMember> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<EquivalenceMember>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<EquivalenceMember>()) }
    }
}
impl New for PgPtr<PathKey> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PathKey>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PathKey>()) }
    }
}
impl New for PgPtr<PathTarget> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PathTarget>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PathTarget>()) }
    }
}
impl New for PgPtr<ParamPathInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParamPathInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParamPathInfo>()) }
    }
}
impl New for PgPtr<Path> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Path>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Path>()) }
    }
}
impl New for PgPtr<IndexPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexPath>()) }
    }
}
impl New for PgPtr<IndexClause> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IndexClause>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IndexClause>()) }
    }
}
impl New for PgPtr<BitmapHeapPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BitmapHeapPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BitmapHeapPath>()) }
    }
}
impl New for PgPtr<BitmapAndPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BitmapAndPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BitmapAndPath>()) }
    }
}
impl New for PgPtr<BitmapOrPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BitmapOrPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BitmapOrPath>()) }
    }
}
impl New for PgPtr<TidPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TidPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TidPath>()) }
    }
}
impl New for PgPtr<SubqueryScanPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SubqueryScanPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SubqueryScanPath>()) }
    }
}
impl New for PgPtr<ForeignPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ForeignPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ForeignPath>()) }
    }
}
impl New for PgPtr<CustomPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CustomPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CustomPath>()) }
    }
}
impl New for PgPtr<AppendPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AppendPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AppendPath>()) }
    }
}
impl New for PgPtr<MergeAppendPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MergeAppendPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MergeAppendPath>()) }
    }
}
impl New for PgPtr<GroupResultPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GroupResultPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GroupResultPath>()) }
    }
}
impl New for PgPtr<MaterialPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MaterialPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MaterialPath>()) }
    }
}
impl New for PgPtr<UniquePath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<UniquePath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<UniquePath>()) }
    }
}
impl New for PgPtr<GatherPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GatherPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GatherPath>()) }
    }
}
impl New for PgPtr<GatherMergePath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GatherMergePath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GatherMergePath>()) }
    }
}
impl New for PgPtr<JoinPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JoinPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JoinPath>()) }
    }
}
impl New for PgPtr<MergePath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MergePath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MergePath>()) }
    }
}
impl New for PgPtr<HashPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<HashPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<HashPath>()) }
    }
}
impl New for PgPtr<ProjectionPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ProjectionPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ProjectionPath>()) }
    }
}
impl New for PgPtr<ProjectSetPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ProjectSetPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ProjectSetPath>()) }
    }
}
impl New for PgPtr<SortPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SortPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SortPath>()) }
    }
}
impl New for PgPtr<GroupPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GroupPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GroupPath>()) }
    }
}
impl New for PgPtr<UpperUniquePath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<UpperUniquePath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<UpperUniquePath>()) }
    }
}
impl New for PgPtr<AggPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AggPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AggPath>()) }
    }
}
impl New for PgPtr<GroupingSetData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GroupingSetData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GroupingSetData>()) }
    }
}
impl New for PgPtr<RollupData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RollupData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RollupData>()) }
    }
}
impl New for PgPtr<GroupingSetsPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GroupingSetsPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GroupingSetsPath>()) }
    }
}
impl New for PgPtr<MinMaxAggPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MinMaxAggPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MinMaxAggPath>()) }
    }
}
impl New for PgPtr<WindowAggPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WindowAggPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WindowAggPath>()) }
    }
}
impl New for PgPtr<SetOpPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SetOpPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SetOpPath>()) }
    }
}
impl New for PgPtr<RecursiveUnionPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RecursiveUnionPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RecursiveUnionPath>()) }
    }
}
impl New for PgPtr<LockRowsPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LockRowsPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LockRowsPath>()) }
    }
}
impl New for PgPtr<ModifyTablePath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ModifyTablePath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ModifyTablePath>()) }
    }
}
impl New for PgPtr<LimitPath> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LimitPath>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LimitPath>()) }
    }
}
impl New for PgPtr<RestrictInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RestrictInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RestrictInfo>()) }
    }
}
impl New for PgPtr<MergeScanSelCache> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MergeScanSelCache>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MergeScanSelCache>()) }
    }
}
impl New for PgPtr<PlaceHolderVar> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PlaceHolderVar>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PlaceHolderVar>()) }
    }
}
impl New for PgPtr<SpecialJoinInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SpecialJoinInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SpecialJoinInfo>()) }
    }
}
impl New for PgPtr<AppendRelInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AppendRelInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AppendRelInfo>()) }
    }
}
impl New for PgPtr<PlaceHolderInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PlaceHolderInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PlaceHolderInfo>()) }
    }
}
impl New for PgPtr<MinMaxAggInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<MinMaxAggInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<MinMaxAggInfo>()) }
    }
}
impl New for PgPtr<PlannerParamItem> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PlannerParamItem>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PlannerParamItem>()) }
    }
}
impl New for PgPtr<SemiAntiJoinFactors> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SemiAntiJoinFactors>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SemiAntiJoinFactors>()) }
    }
}
impl New for PgPtr<JoinPathExtraData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JoinPathExtraData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JoinPathExtraData>()) }
    }
}
impl New for PgPtr<GroupPathExtraData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GroupPathExtraData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GroupPathExtraData>()) }
    }
}
impl New for PgPtr<FinalPathExtraData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FinalPathExtraData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FinalPathExtraData>()) }
    }
}
impl New for PgPtr<JoinCostWorkspace> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JoinCostWorkspace>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JoinCostWorkspace>()) }
    }
}
impl New for PgPtr<FdwRoutine> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<FdwRoutine>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<FdwRoutine>()) }
    }
}
impl New for PgPtr<ForeignDataWrapper> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ForeignDataWrapper>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ForeignDataWrapper>()) }
    }
}
impl New for PgPtr<ForeignServer> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ForeignServer>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ForeignServer>()) }
    }
}
impl New for PgPtr<UserMapping> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<UserMapping>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<UserMapping>()) }
    }
}
impl New for PgPtr<ForeignTable> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ForeignTable>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ForeignTable>()) }
    }
}
impl New for PgPtr<ExplainState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExplainState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExplainState>()) }
    }
}
impl New for PgPtr<ExtensibleNode> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExtensibleNode>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExtensibleNode>()) }
    }
}
impl New for PgPtr<ExtensibleNodeMethods> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ExtensibleNodeMethods>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ExtensibleNodeMethods>()) }
    }
}
impl New for PgPtr<CustomPathMethods> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CustomPathMethods>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CustomPathMethods>()) }
    }
}
impl New for PgPtr<CustomScanMethods> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CustomScanMethods>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CustomScanMethods>()) }
    }
}
impl New for PgPtr<CustomExecMethods> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CustomExecMethods>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CustomExecMethods>()) }
    }
}
impl New for PgPtr<IdentifySystemCmd> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<IdentifySystemCmd>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<IdentifySystemCmd>()) }
    }
}
impl New for PgPtr<BaseBackupCmd> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BaseBackupCmd>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BaseBackupCmd>()) }
    }
}
impl New for PgPtr<CreateReplicationSlotCmd> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CreateReplicationSlotCmd>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CreateReplicationSlotCmd>()) }
    }
}
impl New for PgPtr<DropReplicationSlotCmd> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DropReplicationSlotCmd>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DropReplicationSlotCmd>()) }
    }
}
impl New for PgPtr<StartReplicationCmd> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<StartReplicationCmd>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<StartReplicationCmd>()) }
    }
}
impl New for PgPtr<TimeLineHistoryCmd> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TimeLineHistoryCmd>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TimeLineHistoryCmd>()) }
    }
}
impl New for PgPtr<SQLCmd> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SQLCmd>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SQLCmd>()) }
    }
}
impl New for PgPtr<SupportRequestSimplify> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SupportRequestSimplify>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SupportRequestSimplify>()) }
    }
}
impl New for PgPtr<SupportRequestSelectivity> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SupportRequestSelectivity>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SupportRequestSelectivity>()) }
    }
}
impl New for PgPtr<SupportRequestCost> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SupportRequestCost>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SupportRequestCost>()) }
    }
}
impl New for PgPtr<SupportRequestRows> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SupportRequestRows>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SupportRequestRows>()) }
    }
}
impl New for PgPtr<SupportRequestIndexCondition> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SupportRequestIndexCondition>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SupportRequestIndexCondition>()) }
    }
}
impl New for PgPtr<WindowFuncLists> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WindowFuncLists>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WindowFuncLists>()) }
    }
}
impl New for PgPtr<xl_standby_locks> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_standby_locks>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_standby_locks>()) }
    }
}
impl New for PgPtr<xl_running_xacts> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_running_xacts>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_running_xacts>()) }
    }
}
impl New for PgPtr<xl_invalidations> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<xl_invalidations>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<xl_invalidations>()) }
    }
}
impl New for PgPtr<RunningTransactionsData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RunningTransactionsData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RunningTransactionsData>()) }
    }
}
impl New for PgPtr<TimeTzADT> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TimeTzADT>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TimeTzADT>()) }
    }
}
impl New for PgPtr<Point> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Point>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Point>()) }
    }
}
impl New for PgPtr<LSEG> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LSEG>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LSEG>()) }
    }
}
impl New for PgPtr<PATH> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PATH>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PATH>()) }
    }
}
impl New for PgPtr<LINE> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<LINE>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<LINE>()) }
    }
}
impl New for PgPtr<BOX> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<BOX>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<BOX>()) }
    }
}
impl New for PgPtr<POLYGON> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<POLYGON>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<POLYGON>()) }
    }
}
impl New for PgPtr<CIRCLE> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<CIRCLE>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<CIRCLE>()) }
    }
}
impl New for PgPtr<NumericData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<NumericData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<NumericData>()) }
    }
}
impl New for PgPtr<JsonbContainer> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JsonbContainer>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JsonbContainer>()) }
    }
}
impl New for PgPtr<Jsonb> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<Jsonb>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<Jsonb>()) }
    }
}
impl New for PgPtr<JsonbValue> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JsonbValue>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JsonbValue>()) }
    }
}
impl New for PgPtr<JsonbValue__bindgen_ty_1> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JsonbValue__bindgen_ty_1>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JsonbValue__bindgen_ty_1>()) }
    }
}
impl New for PgPtr<JsonbValue__bindgen_ty_1__bindgen_ty_1> {
    #[inline]
    fn new() -> Self {
        unsafe {
            crate::pgptr::palloc(std::mem::size_of::<JsonbValue__bindgen_ty_1__bindgen_ty_1>())
        }
    }
    #[inline]
    fn new0() -> Self {
        unsafe {
            crate::pgptr::palloc0(std::mem::size_of::<JsonbValue__bindgen_ty_1__bindgen_ty_1>())
        }
    }
}
impl New for PgPtr<JsonbValue__bindgen_ty_1__bindgen_ty_2> {
    #[inline]
    fn new() -> Self {
        unsafe {
            crate::pgptr::palloc(std::mem::size_of::<JsonbValue__bindgen_ty_1__bindgen_ty_2>())
        }
    }
    #[inline]
    fn new0() -> Self {
        unsafe {
            crate::pgptr::palloc0(std::mem::size_of::<JsonbValue__bindgen_ty_1__bindgen_ty_2>())
        }
    }
}
impl New for PgPtr<JsonbValue__bindgen_ty_1__bindgen_ty_3> {
    #[inline]
    fn new() -> Self {
        unsafe {
            crate::pgptr::palloc(std::mem::size_of::<JsonbValue__bindgen_ty_1__bindgen_ty_3>())
        }
    }
    #[inline]
    fn new0() -> Self {
        unsafe {
            crate::pgptr::palloc0(std::mem::size_of::<JsonbValue__bindgen_ty_1__bindgen_ty_3>())
        }
    }
}
impl New for PgPtr<JsonbValue__bindgen_ty_1__bindgen_ty_4> {
    #[inline]
    fn new() -> Self {
        unsafe {
            crate::pgptr::palloc(std::mem::size_of::<JsonbValue__bindgen_ty_1__bindgen_ty_4>())
        }
    }
    #[inline]
    fn new0() -> Self {
        unsafe {
            crate::pgptr::palloc0(std::mem::size_of::<JsonbValue__bindgen_ty_1__bindgen_ty_4>())
        }
    }
}
impl New for PgPtr<JsonbPair> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JsonbPair>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JsonbPair>()) }
    }
}
impl New for PgPtr<JsonbParseState> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JsonbParseState>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JsonbParseState>()) }
    }
}
impl New for PgPtr<JsonbIterator> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JsonbIterator>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JsonbIterator>()) }
    }
}
impl New for PgPtr<catclist> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<catclist>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<catclist>()) }
    }
}
impl New for PgPtr<OpBtreeInterpretation> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<OpBtreeInterpretation>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<OpBtreeInterpretation>()) }
    }
}
impl New for PgPtr<AttStatsSlot> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AttStatsSlot>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AttStatsSlot>()) }
    }
}
impl New for PgPtr<VariableStatData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<VariableStatData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<VariableStatData>()) }
    }
}
impl New for PgPtr<GenericCosts> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<GenericCosts>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<GenericCosts>()) }
    }
}
impl New for PgPtr<DomainConstraintCache> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DomainConstraintCache>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DomainConstraintCache>()) }
    }
}
impl New for PgPtr<TypeCacheEnumData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TypeCacheEnumData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TypeCacheEnumData>()) }
    }
}
impl New for PgPtr<TypeCacheEntry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TypeCacheEntry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TypeCacheEntry>()) }
    }
}
impl New for PgPtr<DomainConstraintRef> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<DomainConstraintRef>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<DomainConstraintRef>()) }
    }
}
impl New for PgPtr<SharedRecordTypmodRegistry> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedRecordTypmodRegistry>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedRecordTypmodRegistry>()) }
    }
}
impl New for PgPtr<AttrMissing> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<AttrMissing>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<AttrMissing>()) }
    }
}
impl New for PgPtr<JitContext> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JitContext>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JitContext>()) }
    }
}
impl New for PgPtr<JitInstrumentation> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<JitInstrumentation>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<JitInstrumentation>()) }
    }
}
impl New for PgPtr<SharedJitInstrumentation> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SharedJitInstrumentation>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SharedJitInstrumentation>()) }
    }
}
impl New for PgPtr<PartitionTupleRouting> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<PartitionTupleRouting>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<PartitionTupleRouting>()) }
    }
}
impl New for PgPtr<binaryheap> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<binaryheap>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<binaryheap>()) }
    }
}
impl New for PgPtr<TsmRoutine> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TsmRoutine>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TsmRoutine>()) }
    }
}
impl New for PgPtr<TableFuncRoutine> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TableFuncRoutine>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TableFuncRoutine>()) }
    }
}
impl New for PgPtr<WindowObjectData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<WindowObjectData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<WindowObjectData>()) }
    }
}
impl New for PgPtr<ParallelExecutorInfo> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ParallelExecutorInfo>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ParallelExecutorInfo>()) }
    }
}
impl New for PgPtr<TupleQueueReader> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<TupleQueueReader>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<TupleQueueReader>()) }
    }
}
impl New for PgPtr<ResourceOwnerData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<ResourceOwnerData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<ResourceOwnerData>()) }
    }
}
impl New for PgPtr<SMgrRelationData> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<SMgrRelationData>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<SMgrRelationData>()) }
    }
}
impl New for PgPtr<RowSecurityDesc> {
    #[inline]
    fn new() -> Self {
        unsafe { crate::pgptr::palloc(std::mem::size_of::<RowSecurityDesc>()) }
    }
    #[inline]
    fn new0() -> Self {
        unsafe { crate::pgptr::palloc0(std::mem::size_of::<RowSecurityDesc>()) }
    }
}
